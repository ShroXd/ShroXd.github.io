<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="React 学习笔记（一）"><meta name="keywords" content="React,Runtime,Hooks"><meta name="author" content="ShroXd"><meta name="copyright" content="ShroXd"><title>React 学习笔记（一） | Space Cowboy</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.8.2"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.8.2"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css?version=1.8.2"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  hexoVersion: '4.2.0'
} </script><meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="Space Cowboy" type="application/atom+xml">
</head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#react-设计思想"><span class="toc-number">1.</span> <span class="toc-text"> React 设计思想</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#现代前端框架存在的意义"><span class="toc-number">1.1.</span> <span class="toc-text"> 现代前端框架存在的意义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#渲染策略"><span class="toc-number">1.2.</span> <span class="toc-text"> 渲染策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#immutable"><span class="toc-number">1.3.</span> <span class="toc-text"> immutable</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#默认渲染行为"><span class="toc-number">1.4.</span> <span class="toc-text"> 默认渲染行为</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#不同的心智模型"><span class="toc-number">1.5.</span> <span class="toc-text"> 不同的心智模型</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#react-编程模型"><span class="toc-number">2.</span> <span class="toc-text"> React 编程模型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#宿主树与渲染器"><span class="toc-number">2.1.</span> <span class="toc-text"> 宿主树与渲染器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#两个阶段与批量更新"><span class="toc-number">2.2.</span> <span class="toc-text"> 两个阶段与批量更新</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#比纯净更重要的是幂等性"><span class="toc-number">2.3.</span> <span class="toc-text"> 比纯净更重要的是幂等性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ioc"><span class="toc-number">2.4.</span> <span class="toc-text"> IoC</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#批量更新"><span class="toc-number">2.5.</span> <span class="toc-text"> 批量更新</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#函数式组件与类组件"><span class="toc-number">3.</span> <span class="toc-text"> 函数式组件与类组件</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#hooks"><span class="toc-number">4.</span> <span class="toc-text"> Hooks</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#为什么-hooks-有这么多规则"><span class="toc-number">4.1.</span> <span class="toc-text"> 为什么 Hooks 有这么多规则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#useeffect-与数据请求"><span class="toc-number">4.2.</span> <span class="toc-text"> useEffect 与数据请求</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#捕获"><span class="toc-number">4.2.1.</span> <span class="toc-text"> 捕获</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#同步而非生命周期"><span class="toc-number">4.2.2.</span> <span class="toc-text"> 同步，而非生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#依赖"><span class="toc-number">4.2.3.</span> <span class="toc-text"> 依赖</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#think-in-react"><span class="toc-number">5.</span> <span class="toc-text"> Think in React</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://bebopfzj.oss-cn-hangzhou.aliyuncs.com/uPic/2020-03-09-bxgaD3.png"></div><div class="author-info__name text-center">ShroXd</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">56</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">114</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">8</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://bebopfzj.oss-cn-hangzhou.aliyuncs.com/uPic/2020-10-18-WIuOpc.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Space Cowboy</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">React 学习笔记（一）</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-04-08</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E6%A1%86%E6%9E%B6/">框架</a><div class="post-meta-wordcount"><span>Word count: </span><span class="word-count">4.9k</span><span class="post-meta__separator">|</span><span>Reading time: 16 min</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="react-设计思想"><a class="markdownIt-Anchor" href="#react-设计思想"></a> React 设计思想</h1>
<p>如果想要理解一个新框架，搞清楚其所解决的问题和解决思路是第一步。只要把握住了这一点，就能很容易理解那些看起来很奇怪的 API 设计。<br />
如果你像笔者一样，之前有 Vue 的使用经验，就更应该注意到这一点。因为这两个框架虽然都在解决相同的问题，但其解决思路确实大不相同的，甚至在一些地方的设计上是截然相反的。如果仅仅将它们看做两个 API 不同的框架，用 Vue 的经验去写 React 代码，结果就只能是“深入金山空手归”了。</p>
<h2 id="现代前端框架存在的意义"><a class="markdownIt-Anchor" href="#现代前端框架存在的意义"></a> 现代前端框架存在的意义</h2>
<p>从手写 HTML、CSS、JavaScript 代码，到 <code>jQuery</code> 的横空出世，再到现在前端框架三足鼎立的局面。框架作者总是考虑着更好的解决方案。<br />
但是什么促使社区从 <code>jQuery</code> 转向了三大框架呢？原因就是 <strong>手动同步 state 与 UI 是非常困难的</strong>。<br />
我们需要一种抽象，来完成繁琐的 DOM 销毁、创建、重排工作。这也就是现代前端框架存在的意义。</p>
<blockquote>
<p>关于这个问题，你可以进一步阅读 <a href="https://medium.com/dailyjs/the-deepest-reason-why-modern-javascript-frameworks-exist-933b86ebc445" target="_blank" rel="noopener">The deepest reason why modern JavaScript frameworks exist</a></p>
</blockquote>
<p>相较于 <code>Vue</code> 借助响应式系统进行细粒度更新的设计，<code>React</code> 的渲染则更为粗粒度。<br />
你可能会觉得这种设计是在傻跑渲染函数，更进一步的，如果你对 <code>React</code> 有所了解，你应该会知道 <code>React</code> 默认的渲染策略是，如果父组件改变了，子组件也会跟着重新渲染，而不论子组件的 <code>props</code> 有没有改变。<br />
简单来说，这都是因为 <code>React</code> 本身的设计和一些工程上的妥协导致的结果。一旦理解了背后的原因，你会发现它们不会再那么别扭了。</p>
<h2 id="渲染策略"><a class="markdownIt-Anchor" href="#渲染策略"></a> 渲染策略</h2>
<p>正如前面提到的，<code>React</code> 的渲染是比较粗粒度的。<code>React</code> 将组件看为一个个的 <code>pure function</code>，<code>state</code> 是其内部状态，<code>props</code> 是外来的状态，任何一方改变了都会引起重新渲染。</p>
<p>另外的，<code>React</code> 的默认渲染行为是：一旦 parent 重新渲染了，child 也会被重新渲染。</p>
<p>这一切设计的根源就在于 <strong>immutable</strong>。</p>
<blockquote>
<p>关于渲染，你可以进一步阅读 <a href="https://blog.isquaredsoftware.com/2020/05/blogged-answers-a-mostly-complete-guide-to-react-rendering-behavior/#immutability-and-rerendering" target="_blank" rel="noopener">Blogged Answers: A (Mostly) Complete Guide to React Rendering Behavior</a></p>
</blockquote>
<h2 id="immutable"><a class="markdownIt-Anchor" href="#immutable"></a> immutable</h2>
<p>在讨论 immutable data 之前，我们先看看 JavaScript 中老生常谈的 mutable data。在学习 JavaScript 初期，你应当见识过如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123;</span><br><span class="line">    name: <span class="string">'Spike'</span>,</span><br><span class="line">    age: <span class="number">24</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> obj2 = obj1;</span><br><span class="line"></span><br><span class="line">obj2.name = <span class="string">'Jet'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj1.name);     <span class="comment">// Jet</span></span><br></pre></td></tr></table></figure>
<p>原因很简单，<code>obj2</code> 通过赋值操作拿到的仅仅是源对象的 reference，它并没有真正的持有那个对象。由此而来的解决方案便是“深拷贝”。只要让 <code>obj2</code> 拿到一份独立的数据，对它的任何操作就不会再影响到 <code>obj1</code> 了。</p>
<p>而 immutable data 就不一样了，它是一旦创建，就不能被更改的数据。如果你执意要修改它们，就都会得到一份新的 immutable 对象。</p>
<blockquote>
<p>如果你想知道这是怎么做到的，<a href="https://immutable-js.github.io/immutable-js/" target="_blank" rel="noopener">immutable.js</a> 的源码会是非常好的阅读材料</p>
</blockquote>
<p>在 React 的语境下，这种设计带来的极大的遍历。即如果我们想要知道两个数据是否相同，直接比较他们的 reference 就行了，没必要再去做麻烦的深度递归比较。</p>
<blockquote>
<p>当然了，深度比较并不总是麻烦事，<a href="https://tvcutsem.github.io/membranes" target="_blank" rel="noopener">Membranes pattern</a>可以帮助你很容易的完成这件事</p>
</blockquote>
<p>这意味着你不能像往常一样这样写代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [todos, setTodos] = useState(todosArray);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> onClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    todos[<span class="number">2</span>].completed = <span class="literal">true</span>;</span><br><span class="line">    setTodos(todos);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>尽管这很符合开发直觉，但在 React 中这样写，你可能会纠结于为什么这个组件<strong>不</strong>会正确的重新渲染。原因也说过了，就是因为 React 并不会监测非基本类型数据深层属性的更改。<br />
换句话说，你得这么写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [todos, setTodos] = useState(todosArray);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> onClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> updatedTodos = todos.map(<span class="function"><span class="params">todo</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (todo === selectedTodo) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123; ...todo, <span class="attr">completed</span>: !todo.completed &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> todo;</span><br><span class="line">    &#125;);</span><br><span class="line">    setTodos(tods);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时刻保证你 set 进去的东西是一个新的对象。</p>
<p>不过显而易见的是，这种设计会导致很多的垃圾，不过 V8 在垃圾回收方面做的很棒，所以理论上来说并不会造成多大的性能影响。</p>
<blockquote>
<p>如果你对 V8 的垃圾回收感兴趣，你可以阅读 <a href="https://deepu.tech/memory-management-in-v8/" target="_blank" rel="noopener">Visualizing memory management in V8 Engine (JavaScript, NodeJS, Deno, WebAssembly)</a></p>
</blockquote>
<h2 id="默认渲染行为"><a class="markdownIt-Anchor" href="#默认渲染行为"></a> 默认渲染行为</h2>
<p>尽管通过 immutable 的设计，我们避免了麻烦的对象深度递归比较。但躲得了一时，躲不了一世。我们依然有个麻烦需要解决，也即 props 的比较。</p>
<p>在 React 的设计中，props 就像是函数的参数一样，作为修改组件行为的外部信号，是编写组件逻辑非常重要的一环。更进一步的说，props 的变化一定会导致组件的重新渲染。那么一个很容易想到的工作是，我们是不是得在适当的时机比较组件 props ，以确认它们是否发生变化了？</p>
<p>这是很正确的想法，且在理论上也没什么问题。但现实情况是，比较算法的时间复杂度是 O(props length) 的。尽管它并不是什么高消耗的逻辑，但每次判断都需要重新跑一遍，累积起来的损耗也是很大的。所以 React 在这里做了工程上的妥协，即：<br />
<strong>只要父组件重新渲染了，就重新渲染子组件，不论子组件的 props 是否发生了变化。</strong></p>
<p>Dan 在 twitter 上也<a href="https://twitter.com/dan_abramov/status/1095661142477811717" target="_blank" rel="noopener">回答</a>过这个问题。</p>
<h2 id="不同的心智模型"><a class="markdownIt-Anchor" href="#不同的心智模型"></a> 不同的心智模型</h2>
<p>一个常见的 Functional Component 是这样的：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;&gt;</span><br><span class="line">            &lt;h1&gt; You clicked &#123;count&#125; times&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">            &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;</span></span><br><span class="line"><span class="regexp">                Click me</span></span><br><span class="line"><span class="regexp">            &lt;/</span>button&gt;</span><br><span class="line">        &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>如果你没有了解过 React 内部的渲染逻辑，你可能会认为这个组件仅会在初始化时被调用。拿到函数返回的 JSX 代码后交由 render 模块进行渲染工作。</p>
<p>但事实并非如此。在每一次点击后，React 实际上都会得到一个新的组件函数，然后 React 每次都会调用它并渲染结果。为了理解这种工作方式，我们可以使用“代换模型”来理解：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// first render</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> &lt;h1&gt;You clicker &#123;count&#125; times&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ second render</span></span><br><span class="line"><span class="regexp">function Counter() &#123;</span></span><br><span class="line"><span class="regexp">    const count = 1;</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ ...</span></span><br><span class="line"><span class="regexp">    return &lt;h1&gt;You clicker &#123;count&#125; times&lt;/</span>h1&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// third render</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> count = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> &lt;h1&gt;You clicker &#123;count&#125; times&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>换句话说，你得注意到我们实际上是在每次渲染都执行函数拿到新的 virtual node。从理论上讲，我们写的这个 functional component 应当是一个 pure function。</p>
<p>更进一步的，诸如 <code>props</code>、<code>effect</code> 等东西，在每一次渲染时实际上都是独立的个体。每一次渲染所依赖的本地状态也都是独立的。</p>
<p>这意味着一个使用过 Vue 的程序员可能会感到别扭。因为 Vue 的逻辑更符合直觉，即 setup 函数只执行一次。如果我们想要依据某些数据源加点副作用，我们就得使用 <code>watch</code> 来做。</p>
<h1 id="react-编程模型"><a class="markdownIt-Anchor" href="#react-编程模型"></a> React 编程模型</h1>
<p>React 运行时做了很多特殊处理，理解这些原理有助于你写出更加地道的 React 代码，但这部分内容不是必须的。</p>
<h2 id="宿主树与渲染器"><a class="markdownIt-Anchor" href="#宿主树与渲染器"></a> 宿主树与渲染器</h2>
<p>在设计一个复杂系统，特别是有多端复用需求的系统时，<strong>分层</strong>就是一个显而易见的解决方案。<br />
将框架的核心逻辑抽象出来，然后针对特定的平台编写特定的适配代码。只要各层都遵守了信息交互的约定，为一个新平台编写适配代码将会变得非常容易。<br />
以 React / Vue 为代表的前端框架选择的分层方案是：Virtual DOM。<br />
简单来说，就是用 JavaScript Object 来描述 DOM 结构，这种描述方案只与 UI 界面结构相关，而与特定平台无关。而这个用来描述 DOM 结构的 JavaScript Object 就是 Virtual DOM，你也可以将其称之为<strong>宿主树</strong>（这个定义与 Dan 的定义相比稍显狭隘）。React / Vue 借助这个由编译器生成的对象，可以完整的掌握 UI 界面的一切信息，之后的渲染工作也就顺理成章了。</p>
<p>那么，接下来的问题是，我们该如何将这个掌握了 UI 界面所有信息的 Object 转换成 UI 界面呢？答案就是编写特定平台的渲染器。<br />
这个渲染器将会依据编译器给出的宿主树，调用平台的 API 来渲染特定元素。例如在浏览器中，可以这样创建一个 ‘div’ 节点。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br></pre></td></tr></table></figure>
<h2 id="两个阶段与批量更新"><a class="markdownIt-Anchor" href="#两个阶段与批量更新"></a> 两个阶段与批量更新</h2>
<p>如果你看过 React 官方的生命周期图，你会发现组件的生命周期被分为了两个部分：</p>
<ul>
<li>Render 阶段</li>
<li>Commit 阶段</li>
</ul>
<blockquote>
<p>完整的<a href="https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/" target="_blank" rel="noopener">生命周期图</a></p>
</blockquote>
<p>这样设计的原因是为了避免重复的子组件渲染。换句话说，React 不在乎源数据变化的过程，而只在乎结果。</p>
<p>而这两个阶段最大的区别就是：在一次修改中，Render 阶段的方法可能会被多次调用，而 Commit 阶段的方法则仅会被调用一次（当然是在 production mode 下）。这也就是说，记的不要把一些副作用函数放在 Render 阶段的生命周期方法里。</p>
<blockquote>
<p>你可以阅读这篇<a href="https://techdoma.in/react-16-tutorial/what-are-render-phase-and-commit-phase-in-react" target="_blank" rel="noopener">文章</a>来获取更多有关两个阶段的信息。</p>
</blockquote>
<p>实际上，这种设计也就意味着，React 会先合并所有的修改，再进行批量更新。更准确的说发法是：<br />
<strong>React 会在组件内所有事件触发完成后再进行批量更新</strong></p>
<p>这种设计乍看起来很美妙，但对于初次使用 React 的开发者来说，他们可能会遇到很多莫名其妙的问题，猜猜看这段代码的结果是什么？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">increment</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    setCount(count + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleClick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    increment();</span><br><span class="line">    increment();</span><br><span class="line">    increment();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>事实上，这段代码只是执行了三次 <code>setCount(1)</code>。如果你理解了上面提到的批量更新，你应当可以想到这段代码的行为为什么会是这样了吧。</p>
<p>问题有了，处理办法呢？给 setState 传一个函数就行了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">increment</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    setCount(<span class="function"><span class="params">c</span> =&gt;</span> c + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleClick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    increment();</span><br><span class="line">    increment();</span><br><span class="line">    increment();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就保证了 state 是被链式更新的。</p>
<p>React 内部应当实现了一个和 Vue 相同思路的调度器。维护了传入 <code>setState</code> 的函数，借助 JavaScript 引擎的 task queue，在适当时机遍历并调用他们。</p>
<p>另外的，多说一句，如果一下子 setState 很多，那你可以考虑使用 <code>useReducer</code>。</p>
<h2 id="比纯净更重要的是幂等性"><a class="markdownIt-Anchor" href="#比纯净更重要的是幂等性"></a> 比纯净更重要的是幂等性</h2>
<p>局部的 props 突变是允许的</p>
<h2 id="ioc"><a class="markdownIt-Anchor" href="#ioc"></a> IoC</h2>
<h2 id="批量更新"><a class="markdownIt-Anchor" href="#批量更新"></a> 批量更新</h2>
<p>？放入了 macro task queue 中吗</p>
<h1 id="函数式组件与类组件"><a class="markdownIt-Anchor" href="#函数式组件与类组件"></a> 函数式组件与类组件</h1>
<p>一言以蔽之：<strong>函数式组件捕获了渲染所用的值</strong></p>
<p>在 Class 写法中，你可能会通过 <code>this.props.name</code> 这样的方式来获取一个 prop 的值。尽管 props 是不可变的，但 this 却会改变。这意味着如果你需要一个数据来完成异步逻辑，在该逻辑执行完成之前就改变了 this 的值，这个异步逻辑可能会基于一个“过于新”的值来执行。</p>
<p>这个行为从理论上来说无懈可击，因为代码关注的是“真实”的值。但问题在于，我们编写的是 UI 代码。不论是从开发者还是用户的角度来看，<strong>事件处理程序应当属于一个拥有特定 props 和 state 的特定渲染</strong>。也就是说，在用户点下按钮的瞬间，处理逻辑得到的数据就不应该再变化了，所见应当是所得。</p>
<p>当然了，Class 写法虽然有这种问题，但很好解决。思路实际上和 JavaScript 中老生常谈的 “this 捕获” 是一样的。比如你可以这样写组件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">const</span> props = <span class="keyword">this</span>.props;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理逻辑</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;props.name&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过你应当注意到了，这种写法下，class 根本就没有存在的必要嘛。在 render 下写这么一大堆处理逻辑的代码，还不如直接用 functional component 的写法来实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyComponent</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 处理逻辑...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;props.name&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你还可以借助 ES6 的解构赋值来让这个“捕获”行为更加清晰：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyComponent</span>(<span class="params">&#123; name &#125;</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 处理逻辑...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;name&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样的道理，这个原则也适用于 state：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyComponent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [name, setName] = useState(<span class="string">'Spike'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理逻辑...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;name&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数一开始的解构赋值实际上就“捕获”了当前的 state。</p>
<blockquote>
<p>关于这个主题，你可以阅读 Dan 的 <a href="https://overreacted.io/how-are-function-components-different-from-classes/" target="_blank" rel="noopener">How Are Function Components Different from Classes?</a> 以获取更多信息。</p>
</blockquote>
<h1 id="hooks"><a class="markdownIt-Anchor" href="#hooks"></a> Hooks</h1>
<p>在以数据驱动的前端开发中，一个容易想到的分层就是将<em>特定数据</em>与<em>处理逻辑</em>分离开。因为业务逻辑虽然是多变的，但是其中很多行为都是重复的。例如对员工的删减和对学生的删减，虽然这是两个截然不同的需求，但很容易看出它们背后的逻辑几乎是一致的。我们没有必要为了这两个需求完全重写处理逻辑。</p>
<p>更进一步的说，我们可以借鉴 Unix 中的思路，通过某种方法去创建一系列仅专注于单一任务的模块，在实现业务逻辑时，再将它们组合起来，完成复杂的任务。而实现这一需求的办法就是 Hooks。</p>
<p>Hooks 的思想实际上就是将处理逻辑与数据本身剥离开，以得到更好的复用能力。</p>
<h2 id="为什么-hooks-有这么多规则"><a class="markdownIt-Anchor" href="#为什么-hooks-有这么多规则"></a> 为什么 Hooks 有这么多规则</h2>
<p>关于 Hooks，你可能知道一些使用规则：</p>
<ul>
<li>不要在循环、条件语句或嵌套函数中使用 Hooks</li>
<li>只在 React Functional Component 中使用 Hooks</li>
</ul>
<p>为了解释清楚这些看起来匪夷所思的规则，你需要对 Hooks 内部的运行机制有所了解。简单来说，每一次你调用 <code>useState</code> 时，state 与 setState 会合起来作为一层加入到底层的数据结构中。实际实现中用的是链表，但如果你理解为数组也无关紧要。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> states = []</span><br><span class="line"><span class="keyword">const</span> setStates = []</span><br><span class="line"><span class="keyword">let</span> cursor = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在调用一次 setState(0) 之后</span></span><br><span class="line">states = [name]</span><br><span class="line">setStates = [setName]</span><br></pre></td></tr></table></figure>
<p>对于每一个 <code>setState</code> 函数，我们都可以根据其下标，唯一的找到对应的 <code>state</code>。<br />
可如果你违反了规则，在条件语句或是什么东西中使用了 <code>useState</code>，数组就会被推入一个“影子层”，它可能存在也可能不存在。这就会导致 <code>setState</code> 的调用可能会出问题。</p>
<blockquote>
<p>关于 Hooks 的运行机制，你可以阅读 <a href="https://medium.com/@ryardley/react-hooks-not-magic-just-arrays-cd4f1857236e" target="_blank" rel="noopener">React hooks: not magic, just arrays</a> 以获得更多信息。</p>
</blockquote>
<h2 id="useeffect-与数据请求"><a class="markdownIt-Anchor" href="#useeffect-与数据请求"></a> useEffect 与数据请求</h2>
<blockquote>
<p>这一部分是阅读 <a href="https://overreacted.io/a-complete-guide-to-useeffect/" target="_blank" rel="noopener">A Complete Guide to useEffect</a> 的笔记</p>
</blockquote>
<h3 id="捕获"><a class="markdownIt-Anchor" href="#捕获"></a> 捕获</h3>
<p>想要完全理解并用好 <code>useEffect</code>，你需要明确一件已经被重复提到很多次的事实：<br />
<strong>每一个组件内的函数（包括事件处理器、effects、定时器或 API 调用）都会捕获某次渲染中定义的 props/state</strong></p>
<p>这句话实际上等效于这段代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyComponent</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> count = props.count;</span><br><span class="line">    useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(count);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类似于我们以前常写的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> self = <span class="keyword">this</span>;</span><br></pre></td></tr></table></figure>
<p>我们实际上是捕获了这一次的 props/state 值。</p>
<h3 id="同步而非生命周期"><a class="markdownIt-Anchor" href="#同步而非生命周期"></a> 同步，而非生命周期</h3>
<p>在 Class 写法中，我们经常会根据生命周期来编写组件逻辑。但换到了函数式写法时，我们应当放弃熟悉的 mount/update/unmount 的心智模型，转而这样考虑：<br />
我们实际上是在将当前的 props 和 state 同步到 DOM。</p>
<p>换句话说，React 不在乎经历了什么，它只在乎结果。</p>
<h3 id="依赖"><a class="markdownIt-Anchor" href="#依赖"></a> 依赖</h3>
<p>在默认行为中，每一次渲染后都会运行所有的 effects。不过这种逻辑实在是有点不管不顾。所以 React 为 useEffect 提供了第二个参数，我们可以传入依赖项，告诉 React：依赖项变了你再运行这个 effect。</p>
<p>不过如果你只是理解了这件事，你只在第一层。这个逻辑的第二层是：当前 effect <strong>仅</strong>依赖了在第二个参数中传入的东西。<br />
这意味着一旦你传入了错误的依赖项，可能会导致一些完全无法理解的运行逻辑。</p>
<p>除此之外，还有第三层：不要理所当然的认为，依赖项是我们需要 effect 重复运行时才要去设置的。这是错误的认识。<strong>依赖是我们给 React 的暗示，告诉 React 我们使用了哪些值</strong>，看一个设置定时器的例子：</p>
<p>如果我们使用了<em>错误</em>的心智模型。即认为只有在需要 effect 反复运行时才去设置依赖。我们可能会这样实现这个组件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyComponent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> id = setinterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            setCount(count + <span class="number">1</span>);</span><br><span class="line">        &#125;, <span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> clearInterval(id);</span><br><span class="line">    &#125;, []);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;count&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基于错误的心智模型，我们很容易想到，定时器初始化只初始化一次，那将依赖写成 <code>[]</code> 不就完事了？然而这种写法是完全错误的。依赖不是去控制 effect 是否重复执行的，它是告诉 React effect 使用了哪些数据的通道。<br />
也就是说，我们应该这样实现这个组件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyComponent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> id = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            setCount(count + <span class="number">1</span>);</span><br><span class="line">        &#125;, <span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> clearInterval(id);</span><br><span class="line">    &#125;, [count])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过这种解决办法有点拆东墙补西墙的意思。更好的办法是修改 effect 中的代码，以确保它包含的值只会在需要的时候发生变更。也就是说，减少依赖项。</p>
<p>比如这个计时器例子，我们在 effect 中的逻辑实际上是根据当前值进行累加。所以当前值具体什么根本不关我们的事，我们可以使用之前谈论过的，向 <code>setState</code> 中传入一个函数来完成这件事。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyComponent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> id = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            setCount(<span class="function"><span class="params">c</span> =&gt;</span> c + <span class="number">1</span>);</span><br><span class="line">        &#125;, <span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> clearInterval(id);</span><br><span class="line">    &#125;, [])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="think-in-react"><a class="markdownIt-Anchor" href="#think-in-react"></a> Think in React</h1>
<p>这里有一些步骤来帮助你更好的 Think in React，写出更加地道的代码：</p>
<ol>
<li>自下而上的拆分组件，组合成完整的应用</li>
<li>保持 state 的最小化：
<ul>
<li>如果数据是由父组件通过 props 传入的，就不是 state</li>
<li>如果数据随着时间不变，就不是 state</li>
<li>如果可以根据 state 或 props 计算出数据的值，就不是 state</li>
</ul>
</li>
<li>确定 state 的位置：让一个包含了所有使用这个 state 的父组件持有该 state</li>
<li>通过使用 props 传入函数来增加反向数据流的能力</li>
</ol>
<p>注意，state 是那些随着时间变化的，且无法通过其他数据计算而来的数据。</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">ShroXd</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://www.bebopser.com/2021/04/08/ReactNote1/">http://www.bebopser.com/2021/04/08/ReactNote1/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/React/">React</a><a class="post-meta__tags" href="/tags/Runtime/">Runtime</a><a class="post-meta__tags" href="/tags/Hooks/">Hooks</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2021/04/25/ReactNote2/"><i class="fa fa-chevron-left">  </i><span>React 学习笔记（二）</span></a></div><div class="next-post pull-right"><a href="/2021/03/04/TypescriptPerformance/"><span>TypeScript 性能手册</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: 'ec5cfb9ea4555ffd29ce',
  clientSecret: 'a0747147682b2ae812bb8aceb071ec64a6ddacf6',
  repo: 'ShroXd.github.io',
  owner: 'ShroXd',
  admin: 'ShroXd',
  id: md5(decodeURI(location.pathname)),
  language: 'zh-CN'
})
gitalk.render('gitalk-container')</script></div></div><footer class="footer-bg" style="background-image: url(https://bebopfzj.oss-cn-hangzhou.aliyuncs.com/uPic/2020-10-18-WIuOpc.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2020 - 2021 By ShroXd</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="icp"><a href="http://www.beian.miit.gov.cn/" target="_blank" rel="noopener"><img class="icp-icon" src="/img/icp.png"><span>鲁ICP备19050480号-1</span></a></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.8.2"></script><script src="/js/fancybox.js?version=1.8.2"></script><script src="/js/sidebar.js?version=1.8.2"></script><script src="/js/copy.js?version=1.8.2"></script><script src="/js/fireworks.js?version=1.8.2"></script><script src="/js/transition.js?version=1.8.2"></script><script src="/js/scroll.js?version=1.8.2"></script><script src="/js/head.js?version=1.8.2"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>