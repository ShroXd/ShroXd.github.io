<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Space Cowboy</title>
  <icon>http://www.bebopser.com/icon.png</icon>
  <subtitle>生死去来 棚头傀儡 一线断时 落落磊磊</subtitle>
  <link href="http://www.bebopser.com/atom.xml" rel="self"/>
  
  <link href="http://www.bebopser.com/"/>
  <updated>2021-05-18T12:45:32.802Z</updated>
  <id>http://www.bebopser.com/</id>
  
  <author>
    <name>ShroXd</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Styled Component</title>
    <link href="http://www.bebopser.com/2021/05/16/styledcomponent/"/>
    <id>http://www.bebopser.com/2021/05/16/styledcomponent/</id>
    <published>2021-05-16T02:27:01.000Z</published>
    <updated>2021-05-18T12:45:32.802Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;难以隔离的-css&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#难以隔离的-css&quot;&gt;&lt;/a&gt; 难以隔离的 CSS&lt;/h1&gt;
&lt;p&gt;你可能已经知道了，CSS 样式的应用是基于选择器的。例如如下代码：&lt;/p&gt;
&lt;figure</summary>
        
      
    
    
    
    <category term="框架" scheme="http://www.bebopser.com/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="CSS in JS" scheme="http://www.bebopser.com/tags/CSS-in-JS/"/>
    
    <category term="Styled-Component" scheme="http://www.bebopser.com/tags/Styled-Component/"/>
    
  </entry>
  
  <entry>
    <title>当我们谈论前端测试时，我们谈些什么</title>
    <link href="http://www.bebopser.com/2021/05/11/FrontendTest/"/>
    <id>http://www.bebopser.com/2021/05/11/FrontendTest/</id>
    <published>2021-05-11T12:41:31.000Z</published>
    <updated>2021-05-12T13:00:26.383Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;测试以及前端测试&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#测试以及前端测试&quot;&gt;&lt;/a&gt; 测试，以及前端测试&lt;/h1&gt;
&lt;p&gt;一般地说，测试的目的是为了保证代码如 &lt;strong&gt;预期&lt;/strong&gt; 那样运行。&lt;br</summary>
        
      
    
    
    
    <category term="核心概念" scheme="http://www.bebopser.com/categories/%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/"/>
    
    
    <category term="frontend" scheme="http://www.bebopser.com/tags/frontend/"/>
    
    <category term="test" scheme="http://www.bebopser.com/tags/test/"/>
    
  </entry>
  
  <entry>
    <title>React 学习笔记（二）</title>
    <link href="http://www.bebopser.com/2021/04/25/ReactNote2/"/>
    <id>http://www.bebopser.com/2021/04/25/ReactNote2/</id>
    <published>2021-04-25T13:04:54.000Z</published>
    <updated>2021-04-27T07:23:18.306Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;渲染调度的意义&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#渲染调度的意义&quot;&gt;&lt;/a&gt; 渲染调度的意义&lt;/h1&gt;
&lt;p&gt;如果你阅读过 &lt;a</summary>
        
      
    
    
    
    <category term="框架" scheme="http://www.bebopser.com/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="React" scheme="http://www.bebopser.com/tags/React/"/>
    
    <category term="Fiber" scheme="http://www.bebopser.com/tags/Fiber/"/>
    
    <category term="Scheduler" scheme="http://www.bebopser.com/tags/Scheduler/"/>
    
  </entry>
  
  <entry>
    <title>React 学习笔记（一）</title>
    <link href="http://www.bebopser.com/2021/04/08/ReactNote1/"/>
    <id>http://www.bebopser.com/2021/04/08/ReactNote1/</id>
    <published>2021-04-08T02:44:53.000Z</published>
    <updated>2021-04-19T13:38:26.527Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;react-设计思想&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#react-设计思想&quot;&gt;&lt;/a&gt; React</summary>
        
      
    
    
    
    <category term="框架" scheme="http://www.bebopser.com/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="React" scheme="http://www.bebopser.com/tags/React/"/>
    
    <category term="Runtime" scheme="http://www.bebopser.com/tags/Runtime/"/>
    
    <category term="Hooks" scheme="http://www.bebopser.com/tags/Hooks/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript 性能手册</title>
    <link href="http://www.bebopser.com/2021/03/04/TypescriptPerformance/"/>
    <id>http://www.bebopser.com/2021/03/04/TypescriptPerformance/</id>
    <published>2021-03-04T03:36:30.000Z</published>
    <updated>2021-03-05T07:16:36.824Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文是对 &lt;a href=&quot;https://github.com/microsoft/TypeScript/wiki/Performance#filing-an-issue&quot; target=&quot;_blank&quot;</summary>
        
      
    
    
    
    <category term="翻译" scheme="http://www.bebopser.com/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
    <category term="TypeScript" scheme="http://www.bebopser.com/tags/TypeScript/"/>
    
    <category term="performance" scheme="http://www.bebopser.com/tags/performance/"/>
    
  </entry>
  
  <entry>
    <title>Vue3 源码阅读笔记（六）—— nextTick 与调度器</title>
    <link href="http://www.bebopser.com/2021/01/22/vue3source6/"/>
    <id>http://www.bebopser.com/2021/01/22/vue3source6/</id>
    <published>2021-01-22T08:26:27.000Z</published>
    <updated>2021-01-28T04:21:18.665Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;简述&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#简述&quot;&gt;&lt;/a&gt; 简述&lt;/h1&gt;
&lt;p&gt;尽管我们可以从逻辑上简单的将 &lt;code&gt;Vue&lt;/code&gt; 的实现拆分为：响应式系统和渲染器。因为现代前端框架所关注的问题就是如何同步 &lt;code&gt;state&lt;/code&gt; 与 &lt;code&gt;UI&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;但在实际工程中，&lt;code&gt;UI&lt;/code&gt; 的渲染并不是一次性的。根据数据的变化，它是会随之不断变化的。从理论上来说，我们可以对数据的变化应收尽收。也就是说，只要 &lt;code&gt;state&lt;/code&gt; 发生了变化，我们就去更新 &lt;code&gt;UI&lt;/code&gt;。这种&lt;s&gt;罗永浩式&lt;/s&gt;不管不顾的做法尽管也不是不能用，但却会大大降低渲染更新的速度。所以我们就需要一种机制，来控制渲染。&lt;/p&gt;
&lt;p&gt;任何逻辑只要足够通用、足够复杂，就有价值抽象出来单独研究。&lt;/p&gt;
&lt;p&gt;另外的，调度器与调度策略是一个很复杂的问题。在操作系统设计中，你可能看到过很多精妙的设计与研究。这里我们并不打算过于深入这个主题，而是恰到好处的阐述，来完成我们的工程目标。&lt;/p&gt;</summary>
    
    
    
    <category term="源码阅读" scheme="http://www.bebopser.com/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
    
    <category term="event loop" scheme="http://www.bebopser.com/tags/event-loop/"/>
    
    <category term="promise" scheme="http://www.bebopser.com/tags/promise/"/>
    
  </entry>
  
  <entry>
    <title>浏览器与 Event Loop</title>
    <link href="http://www.bebopser.com/2021/01/13/browserEventLoop/"/>
    <id>http://www.bebopser.com/2021/01/13/browserEventLoop/</id>
    <published>2021-01-13T02:34:33.000Z</published>
    <updated>2021-01-13T07:47:21.363Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;引子&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#引子&quot;&gt;&lt;/a&gt; 引子&lt;/h1&gt;
&lt;p&gt;如果你使用 &lt;code&gt;JavaScript&lt;/code&gt; 或 &lt;code&gt;TypeScript&lt;/code&gt; 开发，那你就不能不去了解运行它们的环境。我们可以笼统的将运行环境区分为浏览器和 &lt;code&gt;Node.js&lt;/code&gt;。在这篇文章，我们的讨论范围仅限于浏览器中。&lt;/p&gt;
&lt;p&gt;一个在展开讨论前的必要信息是：&lt;code&gt;JavaScript&lt;/code&gt; 是一个单线程语言。这意味着在任何时候，都只能有一个主线程来处理任务。事实上这个设计不能怪 Brendan Eich，&lt;code&gt;JavaScript&lt;/code&gt; 语言的设计者。他当年捣鼓这个东西的时候，也没有想到互联网能发展成今天这个样子。&lt;/p&gt;
&lt;p&gt;如果我们考虑单线程这件事，我们会意识到，这个设计会带来灾难性的后果。比如用户在网站上发起了一个网络请求，这个网络请求所需要的时间可能长达几秒，在这期间，整个网站的渲染线程是被挂起的，从用户的角度来看，网站就像卡住了。这种浏览体验可能是所有用户都不愿意见到的。&lt;/p&gt;
&lt;p&gt;说到这，你可能会想：不对啊，我平常上网怎么没遇到过这种情况？的确没有，这就要归功于 &lt;code&gt;Event Loop&lt;/code&gt; 了。&lt;br /&gt;
简单来说，&lt;code&gt;Event Loop&lt;/code&gt; 这个设计，使得浏览器可以将 &lt;code&gt;JavaScript&lt;/code&gt; 代码中 &lt;strong&gt;同步&lt;/strong&gt; 和 &lt;strong&gt;异步&lt;/strong&gt; 任务区分开。这种设计是有重大意义的。这使得浏览器可以在处理诸如网络请求这种高延时工作的时候，依然可以为用户提供流畅的渲染体验。&lt;/p&gt;</summary>
    
    
    
    <category term="核心概念" scheme="http://www.bebopser.com/categories/%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/"/>
    
    
    <category term="browser" scheme="http://www.bebopser.com/tags/browser/"/>
    
    <category term="task" scheme="http://www.bebopser.com/tags/task/"/>
    
    <category term="micro task" scheme="http://www.bebopser.com/tags/micro-task/"/>
    
    <category term="event loop" scheme="http://www.bebopser.com/tags/event-loop/"/>
    
  </entry>
  
  <entry>
    <title>二叉树的遍历</title>
    <link href="http://www.bebopser.com/2021/01/02/%E4%BA%8C%E5%8F%89%E6%A0%911/"/>
    <id>http://www.bebopser.com/2021/01/02/%E4%BA%8C%E5%8F%89%E6%A0%911/</id>
    <published>2021-01-02T08:06:34.000Z</published>
    <updated>2021-03-08T08:54:06.003Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;简述&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#简述&quot;&gt;&lt;/a&gt; 简述&lt;/h1&gt;
&lt;p&gt;二叉树的遍历是解 leetcode 树类型题目的基础。搞清楚每一种遍历的细节和复杂度是解题的关键。&lt;br /&gt;
leetcode</summary>
        
      
    
    
    
    <category term="数据结构与算法" scheme="http://www.bebopser.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="二叉树" scheme="http://www.bebopser.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    <category term="递归" scheme="http://www.bebopser.com/tags/%E9%80%92%E5%BD%92/"/>
    
    <category term="迭代" scheme="http://www.bebopser.com/tags/%E8%BF%AD%E4%BB%A3/"/>
    
  </entry>
  
  <entry>
    <title>好耶！是 BST</title>
    <link href="http://www.bebopser.com/2020/12/29/BST1/"/>
    <id>http://www.bebopser.com/2020/12/29/BST1/</id>
    <published>2020-12-29T02:58:36.000Z</published>
    <updated>2020-12-29T07:08:46.281Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;关于-bst&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#关于-bst&quot;&gt;&lt;/a&gt; 关于 BST&lt;/h1&gt;
&lt;p&gt;BST 算是 leetcode 关于树的考察的一个重点了。不过这并不意味着它是一个可以广泛运用的数据结构。主要原因就在于其查找、插入、删除操作的时间复杂度均与树高度成正比，换句话说，就是 &lt;code&gt;O(logn)&lt;/code&gt; 。这意味着在很多情况下，时间消耗都比较大。所以我们会转而使用平衡树。比如红黑树，B+，B-等等（不过这些还没学会，就不说了&lt;/p&gt;
&lt;p&gt;回到 BST，它有一个重要的特性，就是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;左低右高：若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值&lt;/li&gt;
&lt;li&gt;左右子树也均为 BST&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这也就意味着，它中序遍历的结果是一个递增数列。&lt;/p&gt;
&lt;p&gt;另外还有两个关于 BST 的概念。这两个概念是依附于 BST 本身的性质而提出的，并不是独立的概念。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;前驱节点(predecessor)：比当前节点小的最大节点&lt;/li&gt;
&lt;li&gt;后继节点(successor)：比当前节点大的最小节点&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="http://www.bebopser.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="BST" scheme="http://www.bebopser.com/tags/BST/"/>
    
    <category term="中序遍历" scheme="http://www.bebopser.com/tags/%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    
    <category term="前驱节点" scheme="http://www.bebopser.com/tags/%E5%89%8D%E9%A9%B1%E8%8A%82%E7%82%B9/"/>
    
    <category term="后继节点" scheme="http://www.bebopser.com/tags/%E5%90%8E%E7%BB%A7%E8%8A%82%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>Vue3 源码阅读笔记（五）—— diff 算法解析</title>
    <link href="http://www.bebopser.com/2020/12/20/vue3source5/"/>
    <id>http://www.bebopser.com/2020/12/20/vue3source5/</id>
    <published>2020-12-20T03:20:44.000Z</published>
    <updated>2020-12-28T14:29:45.738Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;sketch&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#sketch&quot;&gt;&lt;/a&gt; Sketch&lt;/h1&gt;
&lt;p&gt;If you have watched the &lt;a href=&quot;https://www.youtube.com/watch?v=Vp5ANvd88x0&amp;amp;t=48s&amp;amp;ab_channel=VuejsAmsterdam&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Vue3 Live Release video&lt;/a&gt;, you will know the Vue core team rewrote the diff algorithm.&lt;br /&gt;
The new diff algorithm refers to the &lt;a href=&quot;https://github.com/localvoid/ivi&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ivi&lt;/a&gt; and &lt;a href=&quot;https://github.com/infernojs/inferno&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;inferno&lt;/a&gt;, whitch make virtual nodes diff quicker. You can visit &lt;a href=&quot;https://krausest.github.io/js-framework-benchmark/current.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;this test result&lt;/a&gt; to check the accurate data.&lt;/p&gt;
&lt;p&gt;As a whole, the algorithm can divide into three parts:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;patch the repetitive prefix &amp;amp; suffix nodes&lt;/li&gt;
&lt;li&gt;sync the old &amp;amp; new virtual nodes lengths&lt;/li&gt;
&lt;li&gt;diff subsequence of the same length&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Next, we will explain the algorithm with the source code of Vue3.&lt;/p&gt;</summary>
    
    
    
    <category term="源码阅读" scheme="http://www.bebopser.com/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
    
    <category term="diff" scheme="http://www.bebopser.com/tags/diff/"/>
    
    <category term="最长递增子序列" scheme="http://www.bebopser.com/tags/%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Vue3 源码阅读笔记（四）—— 模板编译器的设计，从 AST 类型说起</title>
    <link href="http://www.bebopser.com/2020/11/12/vue3source4/"/>
    <id>http://www.bebopser.com/2020/11/12/vue3source4/</id>
    <published>2020-11-12T03:32:41.000Z</published>
    <updated>2020-12-28T14:35:05.141Z</updated>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;注意这里讨论的模板编译器源码是 Vue3 的。另外的，我并不会粘贴完整的代码，而只是基于当前讨论的主题来选取一些关键的代码句子。你可以比对着真正的源码来阅读。毕竟源码才是最好的课本。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;简述&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#简述&quot;&gt;&lt;/a&gt; 简述&lt;/h1&gt;
&lt;p&gt;Vue 的模板编译器算是除响应式系统之外的，另一个核心系统了。得益于模板编译器的支持，我们可以在写代码时使用诸如 &lt;code&gt;v-if&lt;/code&gt;，&lt;code&gt;v-slot&lt;/code&gt; 等方便的 api。&lt;br /&gt;
尽管名称中带有“编译器”三个字，但它相较于一些现代语言编译器来说，还是十分简单的。但总的来说，还是一样的，分为下面几个步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;parse&lt;/li&gt;
&lt;li&gt;transform&lt;/li&gt;
&lt;li&gt;code generate&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果你提前阅读过 Vue3 的模板编译器语法，你会发现代码量很大。但再复杂的系统，也往往都是从几个简单的核心概念一步步构建起来的。只要找到了这几个核心概念，理清楚它们解决了什么问题，又是如何相互协作的，再去一条条的考虑具体边界情况，就能很容易的搞清楚整个系统了。&lt;/p&gt;
&lt;p&gt;建议你使用官方的 &lt;a href=&quot;https://vue-next-template-explorer.netlify.app&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;模板调试工具&lt;/a&gt; 来查看一下不同模板实际产出的 AST。如果你不了解 AST，那么你可以查看 &lt;a href=&quot;https://en.wikipedia.org/wiki/Abstract_syntax_tree&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;维基百科的解释&lt;/a&gt;。&lt;br /&gt;
不过你需要注意的是，调试工具输出的 AST 是 transform 之后的产物，在这个过程中会对原先通过 parser 产出的树做一些优化处理，这主要是为最后一步 code generate 做准备。&lt;br /&gt;
如果你觉得这样看比较难受，那么你可以下载 &lt;code&gt;vue-next&lt;/code&gt; 的源码，直接调试或自己编写测试用例。&lt;/p&gt;</summary>
    
    
    
    <category term="源码阅读" scheme="http://www.bebopser.com/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
    
    <category term="TypeScript" scheme="http://www.bebopser.com/tags/TypeScript/"/>
    
    <category term="递归下降" scheme="http://www.bebopser.com/tags/%E9%80%92%E5%BD%92%E4%B8%8B%E9%99%8D/"/>
    
    <category term="类型" scheme="http://www.bebopser.com/tags/%E7%B1%BB%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>使用膜隔离应用程序的子组件</title>
    <link href="http://www.bebopser.com/2020/10/26/membranes1/"/>
    <id>http://www.bebopser.com/2020/10/26/membranes1/</id>
    <published>2020-10-26T06:01:26.000Z</published>
    <updated>2020-12-28T14:33:53.973Z</updated>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文翻译自 &lt;a href=&quot;https://tvcutsem.github.io/membranes&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Isolating application sub-components with membranes&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;膜是一种防御式的编程模式，被运用在一个应用程序的子组件之间。这种模式适用于内存安全的编程语言。&lt;/p&gt;
&lt;p&gt;这种模式被提出已经很久了，但却并不广为人知。这篇文章的目的就是讲清楚膜编程背后的思想。因为我关于 膜 的很多经验都是建立于 &lt;code&gt;Web&lt;/code&gt; 平台的，所以我会主要从 &lt;code&gt;Javascript&lt;/code&gt; 和 &lt;code&gt;Web&lt;/code&gt; 平台的用例来解释。值得注意的是，膜 模式并不是仅仅针对于 Web 编程提出的概念，它是一个可以广泛应用的模式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;历史&lt;/strong&gt;: 膜的概念来源于对 &lt;a href=&quot;https://en.wikipedia.org/wiki/Capability-based_security&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Capability-secure Systems&lt;/a&gt; 的研究。最早可追溯至功能安全操作系统，例如 &lt;a href=&quot;http://cap-lore.com/CapTheory/KK/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;KeyKOS&lt;/a&gt;。 以及功能安全语言，例如 &lt;a href=&quot;http://www.erights.org/history/joule/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Joule&lt;/a&gt; 和 &lt;a href=&quot;http://www.erights.org/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;E&lt;/a&gt;。本文对膜的介绍主要基于 &lt;code&gt;Mark S&lt;/code&gt; 中的描述。Miller 的 &lt;a href=&quot;http://erights.org/talks/thesis/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;博士论文&lt;/a&gt;。膜后来被独立地发明，并被广泛应用于函数式编程社区去实现高阶函数的契约。&lt;/p&gt;</summary>
    
    
    
    <category term="翻译" scheme="http://www.bebopser.com/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
    <category term="membranes" scheme="http://www.bebopser.com/tags/membranes/"/>
    
    <category term="proxy" scheme="http://www.bebopser.com/tags/proxy/"/>
    
  </entry>
  
  <entry>
    <title>好耶！是 Webpack（二）———— 代码分割</title>
    <link href="http://www.bebopser.com/2020/10/18/webpack2/"/>
    <id>http://www.bebopser.com/2020/10/18/webpack2/</id>
    <published>2020-10-18T09:37:08.000Z</published>
    <updated>2020-12-28T14:35:20.419Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;为什么要进行代码分割&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#为什么要进行代码分割&quot;&gt;&lt;/a&gt; 为什么要进行代码分割&lt;/h1&gt;
&lt;p&gt;事实上，尽管 &lt;code&gt;Webpack&lt;/code&gt; 的功能是打包，但将所有文件都打包到一个文件下并不是一个好的选择。过大的打包文件会让加载变慢，导致用户感受到的 &lt;code&gt;白屏时间&lt;/code&gt; 更长。&lt;br /&gt;
但如果直接加载开发环境的代码，过于零碎的模块同样会使加载变慢。这主要是因为目前主流的 &lt;code&gt;HTTP 1.1&lt;/code&gt; 对同一个域名下的并行请求有所限制。另外，过多请求的请求头也会占用流量和带宽。&lt;/p&gt;
&lt;p&gt;总而言之，代码的颗粒度并没有一个确切的值。你需要根据业务本身来作出决定。&lt;/p&gt;</summary>
    
    
    
    <category term="框架" scheme="http://www.bebopser.com/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="code-split" scheme="http://www.bebopser.com/tags/code-split/"/>
    
  </entry>
  
  <entry>
    <title>好耶！是 Webpack（一）———— 基础概念</title>
    <link href="http://www.bebopser.com/2020/10/18/webpack1/"/>
    <id>http://www.bebopser.com/2020/10/18/webpack1/</id>
    <published>2020-10-18T08:23:05.000Z</published>
    <updated>2020-12-28T14:35:14.333Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;简述&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#简述&quot;&gt;&lt;/a&gt; 简述&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;Webpack&lt;/code&gt; 是什么？官网是这样介绍的：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本质上，webpack 是一个现代 JavaScript 应用程序的静态模块打包工具。当 webpack 处理应用程序时，它会在内部构建一个 依赖图(dependency graph)，此依赖图会映射项目所需的每个模块，并生成一个或多个 bundle。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;只要你从事前端开发，就不可能绕过 &lt;code&gt;Webpack&lt;/code&gt; 这个工具。这篇文章基于 &lt;code&gt;Webpack4&lt;/code&gt;，总结其核心概念及常规用法。&lt;/p&gt;
&lt;h1 id=&quot;核心概念&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#核心概念&quot;&gt;&lt;/a&gt; 核心概念&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;Webpack&lt;/code&gt; 的核心概念分为四个：&lt;code&gt;entry&lt;/code&gt;、&lt;code&gt;output&lt;/code&gt;、&lt;code&gt;loader&lt;/code&gt; 和 &lt;code&gt;plugin&lt;/code&gt;。&lt;br /&gt;
理解这些概念是更好的使用 &lt;code&gt;Webpack&lt;/code&gt; 的保证。&lt;/p&gt;</summary>
    
    
    
    <category term="框架" scheme="http://www.bebopser.com/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="entry" scheme="http://www.bebopser.com/tags/entry/"/>
    
    <category term="output" scheme="http://www.bebopser.com/tags/output/"/>
    
    <category term="loader" scheme="http://www.bebopser.com/tags/loader/"/>
    
    <category term="plugin" scheme="http://www.bebopser.com/tags/plugin/"/>
    
  </entry>
  
  <entry>
    <title>Vue3 源码阅读笔记（三）—— 响应式？不过是数据劫持罢了</title>
    <link href="http://www.bebopser.com/2020/10/16/vue3source3/"/>
    <id>http://www.bebopser.com/2020/10/16/vue3source3/</id>
    <published>2020-10-16T01:34:58.000Z</published>
    <updated>2020-12-28T14:35:01.532Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;简述&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#简述&quot;&gt;&lt;/a&gt; 简述&lt;/h1&gt;
&lt;p&gt;事实上，响应式并不是 &lt;code&gt;Vue3&lt;/code&gt; 的新概念，它是一个核心概念。在实际代码中，响应式系统经常与组件化相提并论。更进一步的说，组件化赋予了开发者模块化代码的能力，而响应式系统则让开发者可以通过数据控制组件的呈现方式。&lt;/p&gt;
&lt;p&gt;不过这东西从本质上来讲，其实就是劫持数据的变化，在数据变化后自动的执行一些副作用函数。&lt;/p&gt;
&lt;p&gt;如果你大致的了解过这个东西，你大概会知道，&lt;code&gt;Vue2&lt;/code&gt; 和 &lt;code&gt;Vue3&lt;/code&gt; 的响应式系统实现有些略微不同。&lt;br /&gt;
从表象上来说，&lt;code&gt;Vue2&lt;/code&gt; 的响应式系统是黑盒。&lt;code&gt;Vue2&lt;/code&gt; 承包了一切工作，你只需要将数据定义在诸如 &lt;code&gt;data&lt;/code&gt;、&lt;code&gt;props&lt;/code&gt;、&lt;code&gt;computed&lt;/code&gt; 等选项中就行。而 &lt;code&gt;Vue3&lt;/code&gt; 则是把这个决定权交给了开发者。由开发者来决定究竟哪些数据应该是响应式的。&lt;br /&gt;
从实现上来说，&lt;code&gt;Vue2&lt;/code&gt; 使用 &lt;code&gt;Object.defineproperty&lt;/code&gt; 来实现数据劫持，而 &lt;code&gt;Vue3&lt;/code&gt; 则使用了 &lt;code&gt;proxy&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;从逻辑上讲，其实二者是相同的，都是为了实现核心的数据劫持。&lt;br /&gt;
不过 &lt;code&gt;Vue&lt;/code&gt; 毕竟是一个投入到实际生产中使用的框架，仅仅完成理论上的实现当然是不行的。从 &lt;code&gt;Object.defineproperty&lt;/code&gt; 到 &lt;code&gt;proxy&lt;/code&gt; 的切换实际上也表现出了一些技术上的选择。&lt;/p&gt;
&lt;p&gt;简单来说，因为 &lt;code&gt;Vue2&lt;/code&gt; 对响应式数据黑盒化的设计，在框架初始化的时候，会递归遍历所有数据，然后使用 &lt;code&gt;Object.defineproperty&lt;/code&gt; 来做劫持。这是一个解决方案，但并不够好。因为首先会付出很多性能消耗，其次，并不是每一条数据都需要变成响应式的。递归消耗的性能支出是否合算，全看开发者的具体实现方式。另外，&lt;code&gt;Object.defineproperty&lt;/code&gt; 也不能监听到对象属性的新增与删除。&lt;br /&gt;
所以 &lt;code&gt;Vue3&lt;/code&gt; 使用了 &lt;code&gt;proxy&lt;/code&gt; 和显式的 &lt;code&gt;reactice API&lt;/code&gt;。这样不仅可以让开发者自行决定哪些数据需要变成响应式的，还能减少劫持时的数据消耗。&lt;/p&gt;
&lt;p&gt;除此之外，在具体实现中，&lt;code&gt;Vue3&lt;/code&gt; 也做了一些调整来优化性能。更具体的东西，来直接看源码吧。&lt;/p&gt;</summary>
    
    
    
    <category term="源码阅读" scheme="http://www.bebopser.com/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
    
    <category term="proxy" scheme="http://www.bebopser.com/tags/proxy/"/>
    
    <category term="reactive" scheme="http://www.bebopser.com/tags/reactive/"/>
    
  </entry>
  
  <entry>
    <title>Vue3 源码阅读笔记（二）—— 响应式系统之前，是创建与渲染</title>
    <link href="http://www.bebopser.com/2020/10/14/vue3source2/"/>
    <id>http://www.bebopser.com/2020/10/14/vue3source2/</id>
    <published>2020-10-14T07:49:15.000Z</published>
    <updated>2020-12-28T14:34:57.310Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;一些说明&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#一些说明&quot;&gt;&lt;/a&gt; 一些说明&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;这篇文章并不是专注于介绍响应式 API 的文章，所以如果你想搞清楚新的 API 该怎么用，那么你应当关注官方的 &lt;a href=&quot;https://v3.vuejs.org/guide/migration/introduction.html#overview&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Migration Guide&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;为了更明确的说明一些问题，我可能会删减许多代码。但这些代码并非是不必要的，只是对于我们要阐述的主题来说，它们是毫无必要的&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;从-createapp-开始&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#从-createapp-开始&quot;&gt;&lt;/a&gt; 从 CreateApp 开始&lt;/h1&gt;
&lt;p&gt;在这一节，我们会介绍 &lt;code&gt;Vue.js&lt;/code&gt; 的入口函数 &lt;code&gt;createApp&lt;/code&gt;，以及这之后的一整套渲染过程。阅读这一部分的内容有助于你理解响应式系统在整个 &lt;code&gt;Vue.js&lt;/code&gt; 中扮演了怎样的角色。&lt;/p&gt;
&lt;p&gt;当你使用 &lt;code&gt;Vue3&lt;/code&gt; 写一个组件时，你可能会这样做：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; vm = createApp(&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// ...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;).mount(&lt;span class=&quot;string&quot;&gt;&quot;#app&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="源码阅读" scheme="http://www.bebopser.com/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
    
    <category term="event loop" scheme="http://www.bebopser.com/tags/event-loop/"/>
    
    <category term="Currying" scheme="http://www.bebopser.com/tags/Currying/"/>
    
    <category term="track" scheme="http://www.bebopser.com/tags/track/"/>
    
    <category term="trigger" scheme="http://www.bebopser.com/tags/trigger/"/>
    
  </entry>
  
  <entry>
    <title>Vue3 源码阅读笔记（一）—— 搭建环境</title>
    <link href="http://www.bebopser.com/2020/10/04/vue3source1/"/>
    <id>http://www.bebopser.com/2020/10/04/vue3source1/</id>
    <published>2020-10-04T02:32:11.000Z</published>
    <updated>2020-12-28T14:34:47.955Z</updated>
    
    
    <summary type="html">&lt;p&gt;工欲善其事必先利其器，在阅读源码前，首先要做的一步就是搭建调试源码的环境。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;从 &lt;code&gt;Github&lt;/code&gt; 下载源码：&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git clone git@github.com:vuejs&amp;#x2F;vue-next.git&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;使用 &lt;code&gt;Webstrom&lt;/code&gt; 打开项目，安装依赖&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;yarn install&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;配置项目运行&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;你可以参考我的配置，但请注意将一些个性化设置配置成你自己的。&lt;br /&gt;
注意 &lt;code&gt;Arguments&lt;/code&gt; 一栏的参数 &lt;code&gt;-s&lt;/code&gt;。这个参数会生成 &lt;code&gt;source map&lt;/code&gt; 来帮助你调试源码。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://bebopfzj.oss-cn-hangzhou.aliyuncs.com/uPic/2020-10-04-whgKh1.png&quot; alt=&quot;Vue3 源码运行配置&quot; /&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="源码阅读" scheme="http://www.bebopser.com/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
    
    <category term="调试" scheme="http://www.bebopser.com/tags/%E8%B0%83%E8%AF%95/"/>
    
    <category term="sourcemap" scheme="http://www.bebopser.com/tags/sourcemap/"/>
    
  </entry>
  
  <entry>
    <title>Tree Shaking</title>
    <link href="http://www.bebopser.com/2020/09/29/treeShaking/"/>
    <id>http://www.bebopser.com/2020/09/29/treeShaking/</id>
    <published>2020-09-29T12:31:53.000Z</published>
    <updated>2020-12-28T14:34:35.280Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;关于-treeshaking&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#关于-treeshaking&quot;&gt;&lt;/a&gt; 关于 Treeshaking&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;tree shaking&lt;/code&gt; 指的是移除 &lt;code&gt;JavaScript&lt;/code&gt; 上下文中的的未引用代码（dead-code）。这个术语和概念最先是 ES2015 打包工具 &lt;code&gt;rollup&lt;/code&gt; 发展的。&lt;/p&gt;
&lt;p&gt;事实上，消除无用代码并不是一个新的概念。这种技术被广泛运用于传统的编程语言编译器中，编译器会判断代码是否影响功能，并移除那些无用的代码，这个技术被称为 &lt;code&gt;DCE (dead code elimination)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;从先后来讲，&lt;code&gt;tree shaking&lt;/code&gt; 是 &lt;code&gt;DCE&lt;/code&gt; 的一种新的实现。不过和传统的 DCE 不一样的是，&lt;code&gt;tree shaking&lt;/code&gt; 更关注于消除没有用到的代码，而 DCE 则关注那些不可能执行的代码，由编译器将 dead code 从 AST 上删除。&lt;br /&gt;
另一方面，在大多数情况下，&lt;code&gt;JavaScript&lt;/code&gt; 都是通过网络加载的。众所周知，网络速度可是一个变化多端的东西。所以如果能缩短代码的加载时间，那么这对网络应用性能和用户体验的提升都是极大的。&lt;/p&gt;</summary>
    
    
    
    <category term="核心概念" scheme="http://www.bebopser.com/categories/%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/"/>
    
    
    <category term="module" scheme="http://www.bebopser.com/tags/module/"/>
    
    <category term="优化" scheme="http://www.bebopser.com/tags/%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Nodejs（二）—— Stream</title>
    <link href="http://www.bebopser.com/2020/09/29/NodejsStream/"/>
    <id>http://www.bebopser.com/2020/09/29/NodejsStream/</id>
    <published>2020-09-29T02:07:03.000Z</published>
    <updated>2020-12-28T14:34:06.633Z</updated>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文是 &lt;a href=&quot;https://www.freecodecamp.org/news/node-js-streams-everything-you-need-to-know-c9141306be93/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Node.js Streams: Everything you need to know&lt;/a&gt; 一文的笔记&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;流是 Nodejs 中最棒的，同时也是最被人误解的想法。&lt;br /&gt;
—— Dominic Tarr&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果想要学习 &lt;code&gt;Nodejs&lt;/code&gt;，那么 &lt;em&gt;流&lt;/em&gt; 这个概念就是无法绕过的重点。在 &lt;code&gt;Nodejs&lt;/code&gt; 中，很多内建模块都实现了流接口。例如常见的 &lt;code&gt;request&lt;/code&gt;、&lt;code&gt;zlib&lt;/code&gt; 等。&lt;br /&gt;
那么，&lt;em&gt;流&lt;/em&gt; 到底是什么呢？&lt;br /&gt;
简单来说，流是一组数据的集合。但在使用它时，程序并不会一次性的将其载入内存中使用，而是逐端使用数据。显然，这种数据类型有助于处理大体积数据，或是从外部来源逐段发来的数据。对于后者，一个常见的例子就是处理 &lt;code&gt;WebStocket&lt;/code&gt; 接口的时候。&lt;/p&gt;</summary>
    
    
    
    <category term="框架" scheme="http://www.bebopser.com/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="stream" scheme="http://www.bebopser.com/tags/stream/"/>
    
    <category term="pipe" scheme="http://www.bebopser.com/tags/pipe/"/>
    
    <category term="事件" scheme="http://www.bebopser.com/tags/%E4%BA%8B%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>Nodejs（一）—— Buffer</title>
    <link href="http://www.bebopser.com/2020/09/29/NodejsBuffer/"/>
    <id>http://www.bebopser.com/2020/09/29/NodejsBuffer/</id>
    <published>2020-09-29T01:54:41.000Z</published>
    <updated>2020-12-28T14:34:02.495Z</updated>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;参考：&lt;a href=&quot;http://www.semlinker.com/node-buffer/#Node-js-Buffer&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;深入学习 Node.js Buffer&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;关于-buffer&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#关于-buffer&quot;&gt;&lt;/a&gt; 关于 Buffer&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;Buffer&lt;/code&gt; 是 &lt;code&gt;Node.js&lt;/code&gt; 的核心模块，它使得开发者可以在 &lt;code&gt;TCP&lt;/code&gt; 流或是文件系统操作等场景中处理二进制数据。&lt;br /&gt;
&lt;code&gt;Buffer&lt;/code&gt; 的大小是固定的，且无法调整。它在 &lt;code&gt;V8&lt;/code&gt; 堆外分配物理内存。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;V8 是一个由 Google 开发的开源 JavaScript 引擎，用于 Google Chrome 及 Chromium 中。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;常见的应用是在 &lt;code&gt;流&lt;/code&gt; 中使用。流是一组数据的集合。在一般情况下，流的生产者和消费者的速度是不一致的，所以我们需要 &lt;code&gt;Buffer&lt;/code&gt; 来缓存数据。&lt;/p&gt;</summary>
    
    
    
    <category term="框架" scheme="http://www.bebopser.com/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="buffer" scheme="http://www.bebopser.com/tags/buffer/"/>
    
  </entry>
  
</feed>
