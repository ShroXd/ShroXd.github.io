<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.bebopser.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"right","width":265,"display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Sketch If you have watched the Vue3 Live Release video, you will know the Vue core team rewrote the diff algorithm. The new diff algorithm refers to the ivi and inferno, whitch make virtual nodes dif">
<meta property="og:type" content="article">
<meta property="og:title" content="Vue3 源码阅读笔记（五）—— diff 算法解析">
<meta property="og:url" content="http://www.bebopser.com/2020/12/20/vue3source5/index.html">
<meta property="og:site_name" content="Space Cowboy">
<meta property="og:description" content="Sketch If you have watched the Vue3 Live Release video, you will know the Vue core team rewrote the diff algorithm. The new diff algorithm refers to the ivi and inferno, whitch make virtual nodes dif">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://bebopfzj.oss-cn-hangzhou.aliyuncs.com/uPic/2020-12-20-7HeScz.png">
<meta property="og:image" content="https://bebopfzj.oss-cn-hangzhou.aliyuncs.com/uPic/2020-12-20-jvb3na.png">
<meta property="og:image" content="https://bebopfzj.oss-cn-hangzhou.aliyuncs.com/uPic/2020-12-20-4jo5Ay.png">
<meta property="og:image" content="https://bebopfzj.oss-cn-hangzhou.aliyuncs.com/uPic/2020-12-20-9sGsQC.png">
<meta property="og:image" content="https://bebopfzj.oss-cn-hangzhou.aliyuncs.com/uPic/2020-12-20-9yKqOm.png">
<meta property="article:published_time" content="2020-12-20T03:20:44.000Z">
<meta property="article:modified_time" content="2020-12-28T14:29:45.738Z">
<meta property="article:author" content="ShroXd">
<meta property="article:tag" content="diff">
<meta property="article:tag" content="最长递增子序列">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://bebopfzj.oss-cn-hangzhou.aliyuncs.com/uPic/2020-12-20-7HeScz.png">

<link rel="canonical" href="http://www.bebopser.com/2020/12/20/vue3source5/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Vue3 源码阅读笔记（五）—— diff 算法解析 | Space Cowboy</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Space Cowboy</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">生死去来 棚头傀儡 一线断时 落落磊磊</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.bebopser.com/2020/12/20/vue3source5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://bebopfzj.oss-cn-hangzhou.aliyuncs.com/uPic/2020-12-29-mRBWDE.JPG">
      <meta itemprop="name" content="ShroXd">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Space Cowboy">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Vue3 源码阅读笔记（五）—— diff 算法解析
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-20 11:20:44" itemprop="dateCreated datePublished" datetime="2020-12-20T11:20:44+08:00">2020-12-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-28 22:29:45" itemprop="dateModified" datetime="2020-12-28T22:29:45+08:00">2020-12-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/" itemprop="url" rel="index"><span itemprop="name">源码阅读</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="sketch"><a class="markdownIt-Anchor" href="#sketch"></a> Sketch</h1>
<p>If you have watched the <a href="https://www.youtube.com/watch?v=Vp5ANvd88x0&amp;t=48s&amp;ab_channel=VuejsAmsterdam" target="_blank" rel="noopener">Vue3 Live Release video</a>, you will know the Vue core team rewrote the diff algorithm.<br />
The new diff algorithm refers to the <a href="https://github.com/localvoid/ivi" target="_blank" rel="noopener">ivi</a> and <a href="https://github.com/infernojs/inferno" target="_blank" rel="noopener">inferno</a>, whitch make virtual nodes diff quicker. You can visit <a href="https://krausest.github.io/js-framework-benchmark/current.html" target="_blank" rel="noopener">this test result</a> to check the accurate data.</p>
<p>As a whole, the algorithm can divide into three parts:</p>
<ul>
<li>patch the repetitive prefix &amp; suffix nodes</li>
<li>sync the old &amp; new virtual nodes lengths</li>
<li>diff subsequence of the same length</li>
</ul>
<p>Next, we will explain the algorithm with the source code of Vue3.</p>
<a id="more"></a>
<h1 id="prefix-suffix"><a class="markdownIt-Anchor" href="#prefix-suffix"></a> prefix &amp; suffix</h1>
<p>At first, we need to patch the repetitive prefix &amp; suffix virtual nodes. It is not strictly part of the algorithm, but it can avoid running the diff algorithm during some situations. This strategy can improve the program’s performance.</p>
<p>So, what is the <code>repetitive prefix &amp; suffix</code>? Suppose we have the following two texts:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">I want golden wind</span><br><span class="line">I want silver wind</span><br></pre></td></tr></table></figure>
<p>Look at these two texts, and we will find that each of these texts has the same piece of text at the head &amp; end. These texts are what we call <code>repetitive prefix &amp; suffix</code>. After we patched the repetitive part, we can only just diff the middle part which we call it <code>unknown subsequence</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">golden</span><br><span class="line">silver</span><br></pre></td></tr></table></figure>
<p>In this example, the diff algorithm can just replace the words to complete the diff process. But it is not always such simple.</p>
<p>We can show this process through a figure.</p>
<p><img src="https://bebopfzj.oss-cn-hangzhou.aliyuncs.com/uPic/2020-12-20-7HeScz.png" alt="prefix &amp; suffix" /></p>
<ul>
<li>start: the last index of repetitive prefix nodes</li>
<li>prevEnd: the first index of previous virtual nodes’s repetitive suffix</li>
<li>nextEnd: the first index of next virtual nodes’s repetitive suffix</li>
</ul>
<p>The question is: Why just one index at left, but two indexes at right? <strong>Because the previous virtual nodes’ length is not always the same as the next virtual nodes</strong>.</p>
<p>Talk is cheap, show me the code. The following code is from Vue3, but I change some place to make it readable.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> start = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> prevEnd = prevChildren.length - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> nextEnd = nextChildren.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1. sync from start</span></span><br><span class="line"><span class="comment"> * (a b) c</span></span><br><span class="line"><span class="comment"> * (a b) d e</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">while</span> (start &lt;= prevEnd &amp;&amp; start &lt;= nextEnd) &#123;</span><br><span class="line">  <span class="keyword">const</span> prevVNode = prevChildren[start];</span><br><span class="line">  <span class="keyword">const</span> nextVNode = nextChildren[start];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isSameVNodeType(prevVNode, nextVNode)) &#123;</span><br><span class="line">    patch(prevVNode, nextVNode, container);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  start++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>As the code shows, we traverse both the old and new virtual nodes. In this process, we compare the old and new virtual node. If they are the same type, we invoke the <code>patch</code> function to handle them.<br />
In Vue3, the <code>isSameVNodeType</code> function is:</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">isSameVNodeType</span>(<span class="params">n1: VNode, n2: VNode</span>): <span class="title">boolean</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> n1.type === n2.type &amp;&amp; n1.key === n2.key</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Next, we need to handle repetitive suffix virtual nodes:</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 2. sync from end</span></span><br><span class="line"><span class="comment"> * a (b c)</span></span><br><span class="line"><span class="comment"> * d e (b c)</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">while</span> (start &lt;= prevEnd &amp;&amp; start &lt;= nextEnd) &#123;</span><br><span class="line">  <span class="keyword">const</span> prevVNode = prevChildren[prevEnd];</span><br><span class="line">  <span class="keyword">const</span> nextVNode = nextChildren[nextEnd];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isSameVNodeType(prevVNode, nextVNode)) &#123;</span><br><span class="line">    patch(prevVNode, nextVNode, container);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  prevEnd--;</span><br><span class="line">  nextEnd--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The logic is similar to the previous code, but we start from the end of virtual nodes this time.</p>
<p>After the above process, we will get a pair of virtual nodes whose lengths are not necessarily equal. This means that we may need to add or remove virtual nodes.</p>
<h1 id="first-type-common-sequence-mount-unmount"><a class="markdownIt-Anchor" href="#first-type-common-sequence-mount-unmount"></a> First type: common sequence + mount / unmount</h1>
<p>Before we explain code, we need to research the shape of virtual nodes. The shape is formed by the head and tail lines of the old and new virtual node groups.</p>
<p>For example, suppose we have two sets of virtual nodes:</p>
<p><img src="https://bebopfzj.oss-cn-hangzhou.aliyuncs.com/uPic/2020-12-20-jvb3na.png" alt="real virtual nodes" /></p>
<p>The shape of these will like this:<br />
<img src="https://bebopfzj.oss-cn-hangzhou.aliyuncs.com/uPic/2020-12-20-4jo5Ay.png" alt="virtual nodes shape" /></p>
<p>So, if we have a pair of virtual nodes which shape is like this. This means we need to mount nodes.<br />
<img src="https://bebopfzj.oss-cn-hangzhou.aliyuncs.com/uPic/2020-12-20-9sGsQC.png" alt="mount nodes" /></p>
<p>Also, you need to pay attention to the current index which need to be within the prevEnd and nextEnd scope.<br />
The following code is to mount new virtual nodes.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (start &gt; prevEnd) &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 3. common sequence + mount</span></span><br><span class="line"><span class="comment">   * (a b)</span></span><br><span class="line"><span class="comment">   * (a b) c</span></span><br><span class="line"><span class="comment">   * start = 2, prevEnd = 1, prevEnd = 2</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * (a b)</span></span><br><span class="line"><span class="comment">   * c (a b)</span></span><br><span class="line"><span class="comment">   * start = 0, prevEnd = -1, nextEnd = 0</span></span><br><span class="line"><span class="comment">   **/</span></span><br><span class="line">  <span class="keyword">if</span> (start &lt;= nextEnd) &#123;</span><br><span class="line">    <span class="comment">// fetch the real DOM node</span></span><br><span class="line">    <span class="keyword">const</span> ref = nextChildren?.[nextEnd + <span class="number">1</span>]?.elm;</span><br><span class="line">    <span class="keyword">while</span>(start &lt;= nextEnd) &#123;</span><br><span class="line">      mount(nextChildren[start], container, ref || <span class="literal">undefined</span>);</span><br><span class="line">      start++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Same logic, for this shape, you need to unmount nodes.<br />
<img src="https://bebopfzj.oss-cn-hangzhou.aliyuncs.com/uPic/2020-12-20-9yKqOm.png" alt="unmount nodes" /></p>
<p>The code is like this:</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 4. common sequence + unmount</span></span><br><span class="line"><span class="comment"> * (a b) c</span></span><br><span class="line"><span class="comment"> * (a b)</span></span><br><span class="line"><span class="comment"> * start = 2, prevEnd = 2, prevEnd = 1</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * c (a b)</span></span><br><span class="line"><span class="comment"> * (a b)</span></span><br><span class="line"><span class="comment"> * start = 0, prevEnd = 0, nextEnd = -1</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (start &gt; nextEnd) &#123;</span><br><span class="line">  <span class="keyword">while</span> (start &lt;= prevEnd) &#123;</span><br><span class="line">    unmount(prevChildren[start], container);</span><br><span class="line">    start++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="second-type-unknown-subsequence"><a class="markdownIt-Anchor" href="#second-type-unknown-subsequence"></a> Second type: unknown subsequence</h1>
<p>After the previous treatment, we will get an unknown subsequence. But before we start coding, we need to analyze the unknown subsequence.</p>
<p>Specifically, we need to deal with the following possible situations.</p>
<ul>
<li>unmount the node which does not exist in the new subsequence</li>
<li>mount new node</li>
<li>reorder the remaining node</li>
</ul>
<p>So, the <em>first question</em> is: How can I know the situation of the node?<br />
We can iterate over the old node group and determine whether the node still exists in the new node group.<br />
But if you have thought over this logic, you will find the most performance-consuming part is the determine process. If we use the traditional way, like iterate over new node group for every node from old node group and determine it, the complexity is going to be O(n^2). We certainly don’t accept that.<br />
However, if we can determine the node quickly, there will be no problems with this scheme.<br />
The solution is: Add unique key for each node, and determine node through hash table.<br />
Why does this work? Because the hash table lookup is O(1), and determine the node’s key also be O(1). This improvement can greatly increase the speed of finding the same node.</p>
<p>The user passes in the node’s key, and we will store it in the <code>h</code> function, which generates a virtual node.</p>
<p>We can use a <code>Map</code> to store the key-index pair. The index is the index of the node in the old node group.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// the length of new or old virtual node group is not always the same</span></span><br><span class="line"><span class="keyword">const</span> prevStart = start;</span><br><span class="line"><span class="keyword">const</span> nextStart = start;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> keyToIndexMap: Map&lt;<span class="built_in">string</span> | <span class="built_in">number</span>, <span class="built_in">number</span>&gt; = <span class="keyword">new</span> Map();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = nextStart; i &lt;= nextEnd; i++) &#123;</span><br><span class="line">  keyToIndexMap.set(nextChildren[i].key, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Now, we need to loop through old node group left to be patched and try to patch matching nodes &amp; remove nodes that are no longer present.</p>
<p>But why should we loop through the old node group? This because all node move operations operate on the old node group, so this operation can minimize the number of moves.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> needPatch = nextEnd - nextStart + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> patched = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> moved = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">let</span> maxNewindexSoFar = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// works as Map&lt;newIndex, oldIndex&gt;</span></span><br><span class="line"><span class="comment">// 1. determin if the node need to unmount</span></span><br><span class="line"><span class="comment">// 2. determin longest stable subsequence for node movement</span></span><br><span class="line"><span class="keyword">const</span> newIndexToOldIndexMap = <span class="keyword">new</span> <span class="built_in">Array</span>(needPatch).fill(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = prevStart; i &lt;= prevEnd; i++) &#123;</span><br><span class="line">  <span class="keyword">const</span> prevVNode = prevChildren[i];</span><br><span class="line">  <span class="keyword">if</span> (patched &gt;= needPatch) &#123;</span><br><span class="line">    unmount(prevVNode, container);</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> newIndex;</span><br><span class="line">  <span class="keyword">if</span> (!!prevVNode.key) &#123;</span><br><span class="line">    newIndex = keyToIndexMap.get(prevVNode.key);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// handle key-less node</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = prevStart; j &lt;= prevEnd; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (newIndexToOldIndexMap[j - prevStart] &amp;&amp; isSameVNodeType(prevVNode, nextChildren[j])) &#123;</span><br><span class="line">        newIndex = j;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (newIndex) &#123;</span><br><span class="line">    newIndexToOldIndexMap[newIndex - nextStart] = i + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (newIndex &gt;= maxNewIndexSoFar) &#123;</span><br><span class="line">      maxNewIndexSoFar = newIndex;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      moved = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    patch(prevVNode, nextChildren[newIndex], container);</span><br><span class="line">    patched++;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    unmount(prevVNode, container);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The <em>second</em> question is: How do we deal with nodes which is in a different order?<br />
Well, our goal is to minimize DOM movement. So, we need to find a way to extract information about the virtual node’s relative position.<br />
Plus, if you read the code above, you’ll notice the <code>moved</code> variable. The variable’s type is <code>boolean</code>, which means if the node has moved. Specifically, if the newIndexToOldIndexMap’s value is increasing, that means the node has not moved, the other way around, it moves.<br />
So, we need to find out how many nodes in the node group are not moving. The solution is: <strong>Longest Increasing Subsequence</strong>.</p>
<blockquote>
<p>In computer science, the <strong>Longest Increasing Subsequence</strong> problem is to find a subsequence of a given sequence in which the subsequence’s element are in sorted order, lowest to highest, and in which the subsequence is as long as possible.</p>
</blockquote>
<p>Why is it work? Because <strong>Longest Increasing Subsequence</strong>’s mathematical sense is: whether the node remains locally ordered. The problem is complicated, so I’ll treat it as a black box for now.</p>
<p>The code will be:</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 3. common sequence + mount</span></span><br><span class="line"><span class="comment"> * (a b)</span></span><br><span class="line"><span class="comment"> * (a b) c</span></span><br><span class="line"><span class="comment"> * start = 2, prevEnd = 1, prevEnd = 2</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * (a b)</span></span><br><span class="line"><span class="comment"> * c (a b)</span></span><br><span class="line"><span class="comment"> * start = 0, prevEnd = -1, nextEnd = 0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// lis function will generate longest increasing subsequence</span></span><br><span class="line"><span class="keyword">const</span> seq = moved ? lis(newIndexToOldIndexMap) : [];</span><br><span class="line"><span class="keyword">let</span> remaining = seq.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = needPatch - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">  <span class="keyword">const</span> nextVNode = nextChildren[nextStart + i];</span><br><span class="line">  <span class="comment">// If the value is 0, that means this is a new node</span></span><br><span class="line">  <span class="keyword">if</span> (newIndexToOldIndexMap[i] === <span class="number">0</span>) &#123;</span><br><span class="line">    mount(nextVNode, container, nextChildren?.[nextStart + i + <span class="number">1</span>]?.elm || <span class="literal">undefined</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (moved) &#123;</span><br><span class="line">    <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> || i != seq[remaining]) &#123;</span><br><span class="line">      container.insertBefore(nextVNode.elm <span class="keyword">as</span> Node, nextChildren?.[i + nextStart + <span class="number">1</span>]?.elm || <span class="literal">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      remaining--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="conclusion"><a class="markdownIt-Anchor" href="#conclusion"></a> Conclusion</h1>
<p>In this article, we talk about diff algorithm in Vue3. Here is the point:</p>
<ul>
<li>Before the algorithm execute, we can patch the repetitive prefix &amp; suffix nodes first.</li>
<li>If we get <code>common sequence + other node</code>, we need to mount or unmount node.</li>
<li>If we get <code>unknown sequence</code>, we need to find its <code>Longest Increasing Subsequence</code>. Move the node that need to move, mount the node that need to mount.</li>
</ul>
<h1 id="reference"><a class="markdownIt-Anchor" href="#reference"></a> Reference</h1>
<ol>
<li>vue-next: <a href="https://github.com/vuejs/vue-next" target="_blank" rel="noopener">https://github.com/vuejs/vue-next</a></li>
<li>渲染器: <a href="http://hcysun.me/vue-design/zh/renderer-diff.html#inferno-%E6%89%80%E9%87%87%E7%94%A8%E7%9A%84%E6%A0%B8%E5%BF%83-diff-%E7%AE%97%E6%B3%95%E5%8F%8A%E5%8E%9F%E7%90%86" target="_blank" rel="noopener">http://hcysun.me/vue-design/zh/renderer-diff.html#inferno-所采用的核心-diff-算法及原理</a></li>
<li>Longest increasing subsequence wikipedia: <a href="https://en.wikipedia.org/wiki/Longest_increasing_subsequence" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Longest_increasing_subsequence</a></li>
</ol>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/diff/" rel="tag"># diff</a>
              <a href="/tags/%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/" rel="tag"># 最长递增子序列</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/11/12/vue3source4/" rel="prev" title="Vue3 源码阅读笔记（四）—— 模板编译器的设计，从 AST 类型说起">
      <i class="fa fa-chevron-left"></i> Vue3 源码阅读笔记（四）—— 模板编译器的设计，从 AST 类型说起
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/12/29/BST1/" rel="next" title="好耶！是 BST">
      好耶！是 BST <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#sketch"><span class="nav-number">1.</span> <span class="nav-text"> Sketch</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#prefix-suffix"><span class="nav-number">2.</span> <span class="nav-text"> prefix &amp; suffix</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#first-type-common-sequence-mount-unmount"><span class="nav-number">3.</span> <span class="nav-text"> First type: common sequence + mount &#x2F; unmount</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#second-type-unknown-subsequence"><span class="nav-number">4.</span> <span class="nav-text"> Second type: unknown subsequence</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#conclusion"><span class="nav-number">5.</span> <span class="nav-text"> Conclusion</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#reference"><span class="nav-number">6.</span> <span class="nav-text"> Reference</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="ShroXd"
      src="https://bebopfzj.oss-cn-hangzhou.aliyuncs.com/uPic/2020-12-29-mRBWDE.JPG">
  <p class="site-author-name" itemprop="name">ShroXd</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">50</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">103</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/ShroXd" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;ShroXd" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:shroxdf@gmail.com" title="E-Mail → mailto:shroxdf@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ShroXd</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : 'ec5cfb9ea4555ffd29ce',
      clientSecret: 'a0747147682b2ae812bb8aceb071ec64a6ddacf6',
      repo        : 'ShroXd.github.io',
      owner       : 'ShroXd',
      admin       : ['ShroXd'],
      id          : 'e40a5c167ca99c62cffc81be00d5ae3b',
        language: '',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

</body>
</html>
