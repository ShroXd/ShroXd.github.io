<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="响应式编程与Combine（三）"><meta name="keywords" content="异步,IOS,响应式编程,combine"><meta name="author" content="ShroXd"><meta name="copyright" content="ShroXd"><title>响应式编程与Combine（三） | Space Cowboy</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.8.2"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.8.2"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css?version=1.8.2"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  hexoVersion: '4.2.0'
} </script><meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="Space Cowboy" type="application/atom+xml">
</head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#combine-的使用"><span class="toc-number">1.</span> <span class="toc-text"> Combine 的使用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#publisher-与-subscriber-的连接"><span class="toc-number">2.</span> <span class="toc-text"> Publisher 与 Subscriber 的连接</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#combine-发布者和订阅者的生命周期"><span class="toc-number">3.</span> <span class="toc-text"> Combine 发布者和订阅者的生命周期</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#chaining-publishers-with-operators"><span class="toc-number">4.</span> <span class="toc-text"> Chaining Publishers with Operators</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#combine-中的转换-operatorsmap-flatmap-switchtolatest"><span class="toc-number">5.</span> <span class="toc-text"> Combine 中的转换 Operators：Map、FlatMap、SwitchToLatest</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#使用-map-转换元素"><span class="toc-number">5.1.</span> <span class="toc-text"> 使用 Map 转换元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用-flatmap-转换-publisher"><span class="toc-number">5.2.</span> <span class="toc-text"> 使用 FlatMap 转换 Publisher</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用-flatmap-控制-publisher-的数量"><span class="toc-number">5.3.</span> <span class="toc-text"> 使用 FlatMap 控制 Publisher 的数量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#切换到最新的-publiser"><span class="toc-number">5.4.</span> <span class="toc-text"> 切换到最新的 Publiser</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://bebopfzj.oss-cn-hangzhou.aliyuncs.com/uPic/2020-03-09-bxgaD3.png"></div><div class="author-info__name text-center">ShroXd</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">54</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">109</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">8</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://bebopfzj.oss-cn-hangzhou.aliyuncs.com/uPic/2020-10-18-WIuOpc.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Space Cowboy</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">响应式编程与Combine（三）</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-08-28</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E6%A1%86%E6%9E%B6/">框架</a><div class="post-meta-wordcount"><span>Word count: </span><span class="word-count">1.8k</span><span class="post-meta__separator">|</span><span>Reading time: 6 min</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><blockquote>
<p>这篇文章基本翻译自 <a href="https://www.vadimbulavin.com/swift-combine-framework-tutorial-getting-started/" target="_blank" rel="noopener">Swift Combine Framework Tutorial: Getting Started</a>，删除了一些重复的内容</p>
</blockquote>
<h1 id="combine-的使用"><a class="markdownIt-Anchor" href="#combine-的使用"></a> Combine 的使用</h1>
<p>前面两篇文章已经系统的介绍了 <code>Combine</code> 框架的主要组件。在这篇文章中，我们将会介绍一下它们的基本用法。如何将各种内建组件组合起来形成一套逻辑链。</p>
<h1 id="publisher-与-subscriber-的连接"><a class="markdownIt-Anchor" href="#publisher-与-subscriber-的连接"></a> Publisher 与 Subscriber 的连接</h1>
<p><code>Combine</code> 有两个内建的 <code>Subscriber</code>：<code>Subscribers.Sink</code> 和 <code>Subscribers.Assign</code>。你可以通过调用 <code>Publisher</code> 上任何一个方法来连接它们：</p>
<ul>
<li><code>sink(receiveCompletion: receiveValue:)</code> 在闭包中处理新元素或是完成事件</li>
<li><code>assign(to: on:)</code> 将新元素写入属性</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> publisher = <span class="type">Just</span>(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">publisher.sink(</span><br><span class="line">    receiveCompletion: &#123; <span class="number">_</span> <span class="keyword">in</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"finished"</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    receiveValue: &#123; value <span class="keyword">in</span></span><br><span class="line">        <span class="built_in">print</span>(value)</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<ol>
<li>创建一个 <code>Just</code> 发布者，仅发送一个值，然后完成。<code>Combine</code> 有一堆内建的 Publisher，包括 <code>Just</code></li>
<li>连接到 <code>Subscribers.Sink</code> 订阅者</li>
</ol>
<a id="more"></a>
<p>这段代码将会打印：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">finished</span><br></pre></td></tr></table></figure>
<p>在发送 1 之后，发布者会自动的完成。我们不必处理任何错误，因为 <code>Just</code> 不会失败。</p>
<h1 id="combine-发布者和订阅者的生命周期"><a class="markdownIt-Anchor" href="#combine-发布者和订阅者的生命周期"></a> Combine 发布者和订阅者的生命周期</h1>
<p>发布者和订阅者之间的连接被称为订阅。这类连接的步骤定义了发布者订阅者的 <em>生命周期</em>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> subject = <span class="type">PassthroughSubject</span>&lt;<span class="type">Int</span>, <span class="type">Never</span>&gt; ()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> token = subject</span><br><span class="line">    .<span class="built_in">print</span>()</span><br><span class="line">    .sink(receiveValue: &#123; <span class="built_in">print</span>(<span class="string">"received by subscriber: \($0)"</span>) &#125;)</span><br><span class="line"></span><br><span class="line">subject.send(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>注意到上面代码片段的 <code>print(_: to:)</code>。它会打印所有有关发布事件的日志信息到控制台中，这些日志信息可以让我们更好的了解整个生命周期。</p>
<p>这里是我们将会在控制台得到的打印信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">receive subscription: (PassthroughSubject)</span><br><span class="line">request unlimited</span><br><span class="line">receive value: (1)</span><br><span class="line">received by subscriber: 1</span><br><span class="line">receive cancel</span><br></pre></td></tr></table></figure>
<p>这些信息给了我们关于发布者-订阅者生命周期的线索。调试日志中缺少了一些步骤，让我们从头到尾的研究一下生命周期：</p>
<ol>
<li>一个订阅者通过调用 <code>subscribe&lt;S&gt; (S)</code> 来连接到发布者</li>
<li>发布者通过在自身调用 <code>receive&lt;S&gt; (subscriber: S)</code> 来创建一个订阅</li>
<li>发布者确认订阅请求，它在订阅者上调用 <code>receive(subscription:)</code></li>
<li>订阅者请求它想要接受的元素。它在订阅上调用 <code>request(:)</code>，并且将 <code>需求</code> 当做参数传递。需求定义了发布者可以通过订阅向订阅者传递多少信息</li>
<li>发布者通过在订阅者上调用 <code>receive(_ :)</code> 来传递值。这个方法返回一个 <code>需求</code> 实例，需求显示了订阅者期望接收值的项数。订阅者只能增加或者保持不变需求，但不能减少它。</li>
<li>订阅将可能以这些结果中的一个结束：
<ul>
<li>Cancelled 这可以在订阅者被释放时自动发生，就像上面的例子一样。另一种方法是手动取消：<code>token.cancel()</code></li>
<li>Finish 成功</li>
<li>Fail 因为错误导致失败</li>
</ul>
</li>
</ol>
<blockquote>
<p>Token 实际上是订阅者，将类型擦除至满足 <code>AnyCancellable</code> 协议</p>
</blockquote>
<h1 id="chaining-publishers-with-operators"><a class="markdownIt-Anchor" href="#chaining-publishers-with-operators"></a> Chaining Publishers with Operators</h1>
<p><code>Operator</code> 是一些 <code>Publisher</code> 调用的特殊方法，并且返回其他的 <code>Publisher</code>。这允许开发者一个接一个的使用它们，创造一个链条。每一个 <code>Operator</code> 都在前一个 <code>Operator</code> 产出的 <code>Publisher</code> 上工作。</p>
<p>链条必须由一个 <code>Publisher</code> 发起，然后就可以依次应用于 <code>Operator</code> 了，我们将它们的相对顺序称为 <em>上游</em> 和 <em>下游</em>。</p>
<p>来看看我们在处理一个 HTTP URL 请求时如何连接 <code>Operator</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="keyword">let</span> url = <span class="type">URL</span>(string: <span class="string">"https://api.github.com/users/V8tr/repos"</span>)!</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="keyword">let</span> token = <span class="type">URLSession</span>.shared.dataTaskPublisher(<span class="keyword">for</span>: url)</span><br><span class="line">    .<span class="built_in">map</span> &#123; $<span class="number">0</span>.data &#125;    <span class="comment">// 3</span></span><br><span class="line">    .decode(</span><br><span class="line">        type: [<span class="type">Repository</span>].<span class="keyword">self</span>,</span><br><span class="line">        decoder: <span class="type">JSONDecoder</span>()      <span class="comment">// 4</span></span><br><span class="line">    )</span><br><span class="line">    .sink(</span><br><span class="line">        receiveCompletion: &#123; completion <span class="keyword">in</span>      <span class="comment">// 5</span></span><br><span class="line">            <span class="built_in">print</span>(completion)</span><br><span class="line">        &#125;,</span><br><span class="line">        receiveValue: &#123; repositories <span class="keyword">in</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"V8tr has \(repositories.count) repositories"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>
<ol>
<li>创建一个请求去加载我的 Github 仓库，我们可以直接使用 Github 的 api</li>
<li>Combine 可以很轻松的集成到 Swift 系统框架和 IOS SDK 中。这允许我们使用内建的 <code>Publisher</code> 去处理 <code>URLSession</code> 的数据任务</li>
<li>传递返回的数据。我们使用 <code>map(_ :)</code> operator，它可以将上游的 <code>(data: Data, response: URLResponse)</code> 转换为 <code>Data</code></li>
<li>使用 <code>JSONDecoder</code> 解码返回的内容</li>
<li>连接到 <code>sink</code> 订阅者，它将打印接收到的仓库的数量，然后完成</li>
</ol>
<p>这段代码将会打印：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">V8tr has 30 repositories</span><br><span class="line">finished</span><br></pre></td></tr></table></figure>
<h1 id="combine-中的转换-operatorsmap-flatmap-switchtolatest"><a class="markdownIt-Anchor" href="#combine-中的转换-operatorsmap-flatmap-switchtolatest"></a> Combine 中的转换 Operators：Map、FlatMap、SwitchToLatest</h1>
<p>题目中提到的三个 <code>Operator</code> 算是 <code>Combine</code> 框架中非常重要的三个了。所以熟练地掌握它们是很有必要的。下面一一来介绍。</p>
<h2 id="使用-map-转换元素"><a class="markdownIt-Anchor" href="#使用-map-转换元素"></a> 使用 Map 转换元素</h2>
<p><code>Combine</code> 里的 <code>map(_ :)</code> 算子的工作方式和 <code>Swift</code> 标准库中的 <code>map</code> 很相似，唯一的区别就是前者需要和 <code>Publisher</code> 工作。它接受一个闭包，这个闭包将一个元素转化为另一个元素。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">    .publisher</span><br><span class="line">    .<span class="built_in">map</span> &#123; $<span class="number">0</span> * <span class="number">2</span> &#125;</span><br><span class="line">    .sink &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;</span><br></pre></td></tr></table></figure>
<p>这将会打印：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">4</span><br><span class="line">6</span><br></pre></td></tr></table></figure>
<h2 id="使用-flatmap-转换-publisher"><a class="markdownIt-Anchor" href="#使用-flatmap-转换-publisher"></a> 使用 FlatMap 转换 Publisher</h2>
<p><code>flatMap(maxPublishers: _:)</code> 算子可以将一个 <code>Publisher</code> 转化为一个全新的 <code>Publisher</code>，新的发布者将以相同的方式产出元素。当你想要进入一个发布者内部并获取元素的时候，你会用得着它。</p>
<p>为了更好地理解算子，让我们从一个例子开始。假设我们有一个 <code>User</code> 结构体，它有一个作为发布者的 <code>name</code> 属性：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> name: <span class="type">CurrentValueSubject</span>&lt;<span class="type">String</span>, <span class="type">Never</span>&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了打印多个用户的一系列名字，我们创建了 <code>PassthroughSubject</code> 并且将 <code>User</code> 对象传入其中。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> userSubject = <span class="type">PassthroughSubject</span>&lt;<span class="type">User</span>, <span class="type">Never</span>&gt; ()</span><br><span class="line"></span><br><span class="line">userSubject</span><br><span class="line">    .<span class="built_in">map</span> &#123; $<span class="number">0</span>.name &#125;</span><br><span class="line">    .sink &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user = <span class="type">User</span>(name: .<span class="keyword">init</span>(<span class="string">"User 1"</span>))</span><br><span class="line">userSubject.send(user)</span><br></pre></td></tr></table></figure>
<p>这段代码会因为错误而结束，因为 <code>userSubject</code> 是发布者的发布者。<code>flatMap</code> 算子允许我们克服这个问题，并且访问到 <code>name</code> 值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">userSubject</span><br><span class="line">    .flatMap &#123; $<span class="number">0</span>.name &#125;</span><br><span class="line">    .sink &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;</span><br></pre></td></tr></table></figure>
<p>这段代码将会打印：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User</span><br></pre></td></tr></table></figure>
<h2 id="使用-flatmap-控制-publisher-的数量"><a class="markdownIt-Anchor" href="#使用-flatmap-控制-publisher-的数量"></a> 使用 FlatMap 控制 Publisher 的数量</h2>
<p><code>flatMap</code> 有一个 <code>maxPublishers</code> 的参数，这控制了其可以接收多少个 <code>Publishers</code>。默认是无限个：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> anotherUser = <span class="type">User</span>(name: .<span class="keyword">init</span>(<span class="string">"AnotherUser 1"</span>))</span><br><span class="line">userSubject.send(anotherUser)</span><br><span class="line"></span><br><span class="line">anotherUser.name.send(<span class="string">"AnotherUser 2"</span>)</span><br><span class="line"></span><br><span class="line">user.name.send(<span class="string">"User 2"</span>)</span><br></pre></td></tr></table></figure>
<p>这会打印 <code>user</code> 和 <code>anotherUser</code> 的名字：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">User 1</span><br><span class="line">AnotherUser 1</span><br><span class="line">AnotherUser 2</span><br><span class="line">User 2</span><br></pre></td></tr></table></figure>
<p>一旦我们将 <code>maxPublishers</code> 的值设置为 <code>1</code>，<code>flatMap</code> 就将只接收 <code>User</code>，并且忽略 <code>anotherUser</code> 了。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">userSubject</span><br><span class="line">    .flatMap(maxPublishers: .<span class="built_in">max</span>(<span class="number">1</span>)) &#123; $<span class="number">0</span>.name &#125;</span><br><span class="line">    .sink &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user = <span class="type">User</span>(name: .<span class="keyword">init</span>(<span class="string">"User 1"</span>))</span><br><span class="line">userSubject.send(user)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> anotherUser = <span class="type">User</span>(name: .<span class="keyword">init</span>(<span class="string">"AnotherUser 1"</span>))</span><br><span class="line">userSubject.send(anotherUser)</span><br><span class="line"></span><br><span class="line">anotherUser.name.send(<span class="string">"AnotherUser 2"</span>)</span><br><span class="line">user.name.send(<span class="string">"User 2"</span>)</span><br></pre></td></tr></table></figure>
<p>这将会打印：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">User</span> <span class="number">1</span></span><br><span class="line"><span class="type">User</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>
<h2 id="切换到最新的-publiser"><a class="markdownIt-Anchor" href="#切换到最新的-publiser"></a> 切换到最新的 Publiser</h2>
<p>正如我们在 <code>flatMap</code> 中看到的那样，我们经常会遇到要获取到一个发布者的发布者。例如，如果每点击一次按钮就会创建一个网络请求。当请求会在很短的时间就完成时，<code>response</code> 可能会无序到达。然而，我们经常只对 <em>最新</em> 的网络请求感兴趣。在 <code>Combine</code> 中，有一个可以完成这个需求的算子：<code>switchToLatest()</code>。</p>
<p>继续我们的例子，让我们看看如何切换至流中最新的 <code>Publisher</code>。唯一需要修改的地方就是订阅：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">userSubject</span><br><span class="line">    .<span class="built_in">map</span> &#123; $<span class="number">0</span>.name &#125;</span><br><span class="line">    .switchToLatest()</span><br><span class="line">    .sink &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;</span><br></pre></td></tr></table></figure>
<p>这将会打印：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">User 1</span><br><span class="line">AnotherUser 1</span><br><span class="line">AnotherUser 2</span><br></pre></td></tr></table></figure>
<p>一旦 <code>anotherUser</code> 插入到了流中，<code>userSubject</code> 就会自动的切换过去，不再传递 <code>User</code> 的值。</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">ShroXd</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://www.bebopser.com/2020/08/28/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B%E4%B8%8ECombine3/">http://www.bebopser.com/2020/08/28/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B%E4%B8%8ECombine3/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%BC%82%E6%AD%A5/">异步</a><a class="post-meta__tags" href="/tags/IOS/">IOS</a><a class="post-meta__tags" href="/tags/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B/">响应式编程</a><a class="post-meta__tags" href="/tags/combine/">combine</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/08/29/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B%E4%B8%8ECombine4/"><i class="fa fa-chevron-left">  </i><span>响应式编程与Combine（四）</span></a></div><div class="next-post pull-right"><a href="/2020/08/28/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B%E4%B8%8ECombine2/"><span>响应式编程与Combine（二）</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: 'ec5cfb9ea4555ffd29ce',
  clientSecret: 'a0747147682b2ae812bb8aceb071ec64a6ddacf6',
  repo: 'ShroXd.github.io',
  owner: 'ShroXd',
  admin: 'ShroXd',
  id: md5(decodeURI(location.pathname)),
  language: 'zh-CN'
})
gitalk.render('gitalk-container')</script></div></div><footer class="footer-bg" style="background-image: url(https://bebopfzj.oss-cn-hangzhou.aliyuncs.com/uPic/2020-10-18-WIuOpc.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2020 - 2021 By ShroXd</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="icp"><a href="http://www.beian.miit.gov.cn/" target="_blank" rel="noopener"><img class="icp-icon" src="/img/icp.png"><span>鲁ICP备19050480号-1</span></a></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.8.2"></script><script src="/js/fancybox.js?version=1.8.2"></script><script src="/js/sidebar.js?version=1.8.2"></script><script src="/js/copy.js?version=1.8.2"></script><script src="/js/fireworks.js?version=1.8.2"></script><script src="/js/transition.js?version=1.8.2"></script><script src="/js/scroll.js?version=1.8.2"></script><script src="/js/head.js?version=1.8.2"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>