<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="响应式编程与Combine（一）"><meta name="keywords" content="异步,IOS,响应式编程,combine"><meta name="author" content="ShroXd"><meta name="copyright" content="ShroXd"><title>响应式编程与Combine（一） | Space Cowboy</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.8.2"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.8.2"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css?version=1.8.2"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  hexoVersion: '4.2.0'
} </script><meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="Space Cowboy" type="application/atom+xml">
</head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#响应式编程"><span class="toc-number">1.</span> <span class="toc-text"> 响应式编程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#响应式异步编程模型"><span class="toc-number">2.</span> <span class="toc-text"> 响应式异步编程模型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#combine-介绍"><span class="toc-number">3.</span> <span class="toc-text"> Combine 介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#publisher"><span class="toc-number">3.1.</span> <span class="toc-text"> Publisher</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#subscriber"><span class="toc-number">3.2.</span> <span class="toc-text"> Subscriber</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#subject"><span class="toc-number">3.3.</span> <span class="toc-text"> Subject</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#currentvaluesubject"><span class="toc-number">3.3.1.</span> <span class="toc-text"> CurrentValueSubject</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#passthroughsubject"><span class="toc-number">3.3.2.</span> <span class="toc-text"> PassthroughSubject</span></a></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://bebopfzj.oss-cn-hangzhou.aliyuncs.com/uPic/2020-03-09-bxgaD3.png"></div><div class="author-info__name text-center">ShroXd</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">55</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">112</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">8</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://bebopfzj.oss-cn-hangzhou.aliyuncs.com/uPic/2020-10-18-WIuOpc.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Space Cowboy</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">响应式编程与Combine（一）</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-08-27</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E6%A1%86%E6%9E%B6/">框架</a><div class="post-meta-wordcount"><span>Word count: </span><span class="word-count">2k</span><span class="post-meta__separator">|</span><span>Reading time: 7 min</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="响应式编程"><a class="markdownIt-Anchor" href="#响应式编程"></a> 响应式编程</h1>
<p>借用维基百科的定义：</p>
<blockquote>
<p>在计算中，响应式编程或反应式编程（英语：Reactive programming）是一种面向数据流和变化传播的声明式编程范式。这意味着可以在编程语言中很方便地表达静态或动态的数据流，而相关的计算模型会自动将变化的值通过数据流进行传播。</p>
</blockquote>
<p>从定义中可以看出，响应式编程的核心就是：数据流和数据流的变化。<br />
数据流自不必说，很多实际的应用场景都会产生数据流。如果仅限于 <code>IOS</code> 客户端开发的话，网络请求就是一个常见的应用场景了。很多语言都给出了自己的响应式编程的解决方案，但本篇文章只谈谈苹果给出的解决方案——<code>Combine</code> 框架。</p>
<p>另外的，基于响应式编程的特点，我们很容易想到可以把函数式编程与响应式编程结合起来。而函数式编程的核心就是“模糊数据与过程的界限”。函数式编程的这一特点可以让我们更加清楚的处理数据流，明确其输入和输出。</p>
<p>而这一套范式可以用来很轻松的解决异步编程的种种问题。而提到异步编程，对于前端开发的程序员来说应该不会陌生。在过去，前端工程师依赖于 <code>闭包回调</code> 这一方案来解决异步编程的问题。简单来说，就是在调用需要耗时的方法时，同时提供一个回调函数来处理方法的结果。先不说这样很容易导致回调地狱的问题，当多个异步函数同时工作的时候，你很难搞清楚在任一情况下数据到底变成了什么样子，而这也就是大多数 bug 的来源。</p>
<a id="more"></a>
<h1 id="响应式异步编程模型"><a class="markdownIt-Anchor" href="#响应式异步编程模型"></a> 响应式异步编程模型</h1>
<p>在客户端的异步编程中，最核心的概念就是：事件。换句话说，就是数据流变化的标志。比如当一个请求 api 的函数获取到了返回结果，这就是一个事件。异步编程的职责就是去处理好这些事件和事件所带有的数据。当然了，这些数据并不一定就是最终要使用的数据，我们可能需要对这些数据做点处理，才能最终应用。</p>
<p>简单来说，大概就是这样的模型：</p>
<p><img src="https://bebopfzj.oss-cn-hangzhou.aliyuncs.com/uPic/2020-08-27-P0OKcw.png" alt="响应式异步编程模型" /></p>
<p>不过在接下来的关于 <code>Combine</code> 的介绍中，我们会发现，实际中事件的出现与数据处理有时候并不是独立地，它们会经常结对出现。不过最终还是会通过一个事件的订阅者来使用这些数据。</p>
<h1 id="combine-介绍"><a class="markdownIt-Anchor" href="#combine-介绍"></a> Combine 介绍</h1>
<p>这里引用一下苹果关于 <code>Combine</code> 的 <a href="https://developer.apple.com/documentation/combine" target="_blank" rel="noopener">介绍</a>:</p>
<blockquote>
<p>The Combine framework provides a declarative Swift API for processing values over time. These values can represent many kinds of asynchronous events. Combine declares publishers to expose values that can change over time, and subscribers to receive those values from the publishers.</p>
</blockquote>
<p>可以看出，这里的核心就是 <code>values over time</code>。通过 <code>publishers</code> 来提供随时间变化的数据，然后由 <code>subscribers</code> 来接收这些数据并处理。注意到这里模糊了事件产出和数据处理的界限。因为一个数据处理的行为同样也可以产出一个事件。<code>Combine</code> 将 <code>Publisher</code> 和 <code>Subscribers</code> 定义为协议，从而控制其行为。</p>
<h2 id="publisher"><a class="markdownIt-Anchor" href="#publisher"></a> Publisher</h2>
<p>关于 <code>Publisher</code>，苹果给出了一段定义：</p>
<blockquote>
<p>The Publisher protocol declares a type that can deliver a sequence of values over time. Publishers have operators to act on the values received from upstream publishers and republish them.</p>
</blockquote>
<p>从定义可以看出，<code>Publisher</code> 实际上就是一个可以随时间交付一系列值的过程。理所当然的，你也可以组合多个不同的 <code>Publisher</code> 来形成你自己的数据更新逻辑。这里给出协议的定义：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">Publisher</span> </span>&#123;</span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">Output</span></span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">Failure</span> : <span class="type">Error</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">receive</span>&lt;S&gt; <span class="params">(subscriber: S)</span></span> <span class="keyword">where</span></span><br><span class="line">        <span class="type">S</span> : <span class="type">Subscriber</span>,</span><br><span class="line">        <span class="type">Self</span>.<span class="type">Failure</span> == <span class="type">S</span>.<span class="type">Failure</span></span><br><span class="line">        <span class="type">Self</span>.<span class="type">Output</span> == <span class="type">S</span>.<span class="type">Input</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总的来说，一个 <code>Publisher</code> 可以发布三种事件：（有一说一，从设计上来说，跟 Promise 没啥区别）</p>
<ul>
<li>Output 类型的新值</li>
<li>Failure 类型的错误</li>
<li>事件完成</li>
</ul>
<p>第一种事件是由 <code>Publisher</code> 直接发布的，后两种则是使用 <code>Subscribers.Completion</code> 来描述。它是一个含有两个成员的 <code>enum</code>，成员类型为 <code>.failure</code> 和 <code>finished</code>。</p>
<p>另外的，<code>Publisher</code> 所必须实现的 <code>receive(subscriber:)</code> 方法是用来接受 <code>Subscriber</code> 的。</p>
<p>最后，<code>Combine</code> 提供了一系列内建的 <code>Publisher</code> 来处理数据，你可以在 <a href="https://developer.apple.com/documentation/combine/publisher" target="_blank" rel="noopener">官方文档</a> 获得更多信息。</p>
<h2 id="subscriber"><a class="markdownIt-Anchor" href="#subscriber"></a> Subscriber</h2>
<p>同样的，我们直接引用苹果关于 <code>Subscriber</code> 的定义：</p>
<blockquote>
<p>At the end of a chain of publishers, a Subscriber acts on elements as it receives them. Publishers only emit values when explicitly requested to do so by subscribers. This puts your subscriber code in control of how fast it receives events from the publishers it’s connected to.</p>
</blockquote>
<p>可以看出，<code>Subscriber</code> 是作为 <code>Publisher</code> 链的结束的。这里我们给出 <code>Subscriber</code> 协议的定义：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">Subscriber</span> </span>&#123;</span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">Input</span></span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">Failure</span> : <span class="type">Error</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">receive</span> <span class="params">(subscription: Subscription)</span></span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">receive</span> <span class="params">(<span class="number">_</span> input: <span class="keyword">Self</span>.Input)</span></span> -&gt; <span class="type">Subscribers</span>.<span class="type">Demand</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">receive</span> <span class="params">(completion: Subscribers.Completion&lt;<span class="keyword">Self</span>.Failure&gt;)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果一个 <code>Subscriber</code> 想要订阅 <code>Publisher</code>，那么 <code>Subscriber</code> 的 <code>Input</code> 与 <code>Failure</code> 必须与 <code>Publisher</code> 的 <code>Output</code> 和 <code>Failure</code> 相同。</p>
<p>另外的，你可以参考这段话来理解 <code>Publisher</code> 和 <code>Subscriber</code> 的工作方式：</p>
<blockquote>
<p>You connect a subscriber to a publisher by calling the publisher’s subscribe() method. After making this call, the publisher invokes the subscriber’s receive(subscription:) method. This gives the subscriber a Subscription instance, which it uses to demand elements from the publisher, and to optionally cancel the subscription. After the subscriber makes an initial demand, the publisher calls receive(), possibly asynchronously, to deliver newly-published elements. If the publisher stops publishing, it calls receive(completion:), using a parameter of type Subscribers.Completion to indicate whether publishing completes normally or with an error.</p>
</blockquote>
<p>简单来说，大致包含以下几个部分的内容：</p>
<ol>
<li>关于订阅。<code>Subscriber</code> 通过调用 <code>Publisher</code> 的 <code>subscribe(_ :)</code> 方法来将自己与发布者连接起来。</li>
<li>关于订阅的处理。<code>Publisher</code> 会调用 <code>Subscriber</code> 的 <code>receive(subscription:)</code> 方法来为订阅者产出一个订阅实例。订阅者可以通过这个实例来从发布者获取数据，或是取消订阅。另外的，发布者可能会异步的调用自身协议实现的 <code>receive()</code>方法来为订阅者产出值。</li>
<li>关于发布者的终止。当发布者停止时，会调用 <code>receive(completion: Subscribers.Completion&lt;Self.Failure&gt;)</code> 来表示发布是正常完成还是由于错误导致终止。</li>
</ol>
<h2 id="subject"><a class="markdownIt-Anchor" href="#subject"></a> Subject</h2>
<p>其实这东西本身就是一个 <code>Publisher</code> 。单独提出来说的原因是，它是作为一座桥梁，将传统的指令式异步 API 里的事件转换到响应式的世界中。这里我们给出协议的定义：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">Subject</span>: <span class="title">AnyObject</span>, <span class="title">Publisher</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">(<span class="number">_</span> value: <span class="keyword">Self</span>.Output)</span></span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">(completion: Subscribers.Completion&lt;<span class="keyword">Self</span>.Failure&gt;)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个协议暴露了两个 <code>send</code> 方法，来让外部调用者主动发布 <code>Output</code> 值或是 <code>failure</code> ，<code>finished</code> 事件。</p>
<p><code>Combine</code> 内置了两个常用的 <code>Subject</code>。即 <code>CurrentValueSubject</code> 和 <code>PassthroughSubject</code></p>
<h3 id="currentvaluesubject"><a class="markdownIt-Anchor" href="#currentvaluesubject"></a> CurrentValueSubject</h3>
<p>官方文档已经解释的很清楚了：</p>
<blockquote>
<p>A subject that wraps a single value and publishes a new element whenever the value changes.</p>
</blockquote>
<p>这里有一个例子：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> curr = <span class="type">CurrentValueSubject</span>&lt;<span class="type">Int</span>, <span class="type">Never</span>&gt; (<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">curr.sink(</span><br><span class="line">    receiveCompletion: &#123; complete <span class="keyword">in</span></span><br><span class="line">        <span class="built_in">print</span>(complete)</span><br><span class="line">    &#125;,</span><br><span class="line">    receiveValue &#123; value <span class="keyword">in</span></span><br><span class="line">        <span class="built_in">print</span>(value)</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">curr.value = <span class="number">1</span></span><br><span class="line">curr.value = <span class="number">2</span></span><br><span class="line">curr.send(completion: .finished)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// finished</span></span><br></pre></td></tr></table></figure>
<p>在订阅后，<code>Publisher</code> 里存储的值立即被发送给了 <code>receiveValue</code>。另外的，每一次的 <code>curr.value</code> 赋值都会触发订阅者的响应。</p>
<h3 id="passthroughsubject"><a class="markdownIt-Anchor" href="#passthroughsubject"></a> PassthroughSubject</h3>
<p>同样的，直接引用官方文档的解释：</p>
<blockquote>
<p>A subject that broadcasts elements to downstream subscribers.</p>
</blockquote>
<p>比起前者，它很简单，就直接将 <code>send</code> 接收到的值转发给了下游的 <code>Publisher</code> 或者是 <code>Subscriber</code>。这里是例子：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> pass = <span class="type">PassthroughSubject</span>&lt;<span class="type">Int</span>, <span class="type">Never</span>&gt; ()</span><br><span class="line"></span><br><span class="line">pass.sink(</span><br><span class="line">    receiveCompletion: &#123; complete <span class="keyword">in</span></span><br><span class="line">        <span class="built_in">print</span>(complete)</span><br><span class="line">    &#125;,</span><br><span class="line">    receiveValue: &#123; value <span class="keyword">in</span></span><br><span class="line">        <span class="built_in">print</span>(value)</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">pass.send(<span class="number">1</span>)</span><br><span class="line">pass.send(<span class="number">2</span>)</span><br><span class="line">pass.send(completion: .finished)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// finished</span></span><br></pre></td></tr></table></figure>
<p>订阅之后的第一次 <code>send</code> 才会将值传给下游。如果你在订阅前就调用了 <code>send</code>，那么下游是接收不到这个值的。</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">ShroXd</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://www.bebopser.com/2020/08/27/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B%E4%B8%8ECombine/">http://www.bebopser.com/2020/08/27/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B%E4%B8%8ECombine/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%BC%82%E6%AD%A5/">异步</a><a class="post-meta__tags" href="/tags/IOS/">IOS</a><a class="post-meta__tags" href="/tags/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B/">响应式编程</a><a class="post-meta__tags" href="/tags/combine/">combine</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/08/28/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B%E4%B8%8ECombine2/"><i class="fa fa-chevron-left">  </i><span>响应式编程与Combine（二）</span></a></div><div class="next-post pull-right"><a href="/2020/08/25/%E4%BB%8E%E8%AE%A1%E7%AE%97%E7%9A%84%E6%9C%AC%E8%B4%A8%E6%9D%A5%E8%AE%A8%E8%AE%BA%E9%80%92%E5%BD%92/"><span>从计算的本质来讨论递归</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: 'ec5cfb9ea4555ffd29ce',
  clientSecret: 'a0747147682b2ae812bb8aceb071ec64a6ddacf6',
  repo: 'ShroXd.github.io',
  owner: 'ShroXd',
  admin: 'ShroXd',
  id: md5(decodeURI(location.pathname)),
  language: 'zh-CN'
})
gitalk.render('gitalk-container')</script></div></div><footer class="footer-bg" style="background-image: url(https://bebopfzj.oss-cn-hangzhou.aliyuncs.com/uPic/2020-10-18-WIuOpc.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2020 - 2021 By ShroXd</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="icp"><a href="http://www.beian.miit.gov.cn/" target="_blank" rel="noopener"><img class="icp-icon" src="/img/icp.png"><span>鲁ICP备19050480号-1</span></a></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.8.2"></script><script src="/js/fancybox.js?version=1.8.2"></script><script src="/js/sidebar.js?version=1.8.2"></script><script src="/js/copy.js?version=1.8.2"></script><script src="/js/fireworks.js?version=1.8.2"></script><script src="/js/transition.js?version=1.8.2"></script><script src="/js/scroll.js?version=1.8.2"></script><script src="/js/head.js?version=1.8.2"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>