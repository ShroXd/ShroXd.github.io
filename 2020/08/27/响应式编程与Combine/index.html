<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.bebopser.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"right","width":265,"display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="响应式编程 借用维基百科的定义：  在计算中，响应式编程或反应式编程（英语：Reactive programming）是一种面向数据流和变化传播的声明式编程范式。这意味着可以在编程语言中很方便地表达静态或动态的数据流，而相关的计算模型会自动将变化的值通过数据流进行传播。  从定义中可以看出，响应式编程的核心就是：数据流和数据流的变化。 数据流自不必说，很多实际的应用场景都会产生数据流。如果仅限于">
<meta property="og:type" content="article">
<meta property="og:title" content="响应式编程与Combine（一）">
<meta property="og:url" content="http://www.bebopser.com/2020/08/27/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B%E4%B8%8ECombine/index.html">
<meta property="og:site_name" content="Space Cowboy">
<meta property="og:description" content="响应式编程 借用维基百科的定义：  在计算中，响应式编程或反应式编程（英语：Reactive programming）是一种面向数据流和变化传播的声明式编程范式。这意味着可以在编程语言中很方便地表达静态或动态的数据流，而相关的计算模型会自动将变化的值通过数据流进行传播。  从定义中可以看出，响应式编程的核心就是：数据流和数据流的变化。 数据流自不必说，很多实际的应用场景都会产生数据流。如果仅限于">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://bebopfzj.oss-cn-hangzhou.aliyuncs.com/uPic/2020-08-27-P0OKcw.png">
<meta property="article:published_time" content="2020-08-27T08:13:17.000Z">
<meta property="article:modified_time" content="2020-12-28T14:35:35.610Z">
<meta property="article:author" content="ShroXd">
<meta property="article:tag" content="异步">
<meta property="article:tag" content="IOS">
<meta property="article:tag" content="响应式编程">
<meta property="article:tag" content="combine">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://bebopfzj.oss-cn-hangzhou.aliyuncs.com/uPic/2020-08-27-P0OKcw.png">

<link rel="canonical" href="http://www.bebopser.com/2020/08/27/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B%E4%B8%8ECombine/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>响应式编程与Combine（一） | Space Cowboy</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Space Cowboy" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Space Cowboy</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">生死去来 棚头傀儡 一线断时 落落磊磊</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.bebopser.com/2020/08/27/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B%E4%B8%8ECombine/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://bebopfzj.oss-cn-hangzhou.aliyuncs.com/uPic/2020-12-29-mRBWDE.JPG">
      <meta itemprop="name" content="ShroXd">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Space Cowboy">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          响应式编程与Combine（一）
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-08-27 16:13:17" itemprop="dateCreated datePublished" datetime="2020-08-27T16:13:17+08:00">2020-08-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-28 22:35:35" itemprop="dateModified" datetime="2020-12-28T22:35:35+08:00">2020-12-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%A1%86%E6%9E%B6/" itemprop="url" rel="index"><span itemprop="name">框架</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="响应式编程"><a class="markdownIt-Anchor" href="#响应式编程"></a> 响应式编程</h1>
<p>借用维基百科的定义：</p>
<blockquote>
<p>在计算中，响应式编程或反应式编程（英语：Reactive programming）是一种面向数据流和变化传播的声明式编程范式。这意味着可以在编程语言中很方便地表达静态或动态的数据流，而相关的计算模型会自动将变化的值通过数据流进行传播。</p>
</blockquote>
<p>从定义中可以看出，响应式编程的核心就是：数据流和数据流的变化。<br />
数据流自不必说，很多实际的应用场景都会产生数据流。如果仅限于 <code>IOS</code> 客户端开发的话，网络请求就是一个常见的应用场景了。很多语言都给出了自己的响应式编程的解决方案，但本篇文章只谈谈苹果给出的解决方案——<code>Combine</code> 框架。</p>
<p>另外的，基于响应式编程的特点，我们很容易想到可以把函数式编程与响应式编程结合起来。而函数式编程的核心就是“模糊数据与过程的界限”。函数式编程的这一特点可以让我们更加清楚的处理数据流，明确其输入和输出。</p>
<p>而这一套范式可以用来很轻松的解决异步编程的种种问题。而提到异步编程，对于前端开发的程序员来说应该不会陌生。在过去，前端工程师依赖于 <code>闭包回调</code> 这一方案来解决异步编程的问题。简单来说，就是在调用需要耗时的方法时，同时提供一个回调函数来处理方法的结果。先不说这样很容易导致回调地狱的问题，当多个异步函数同时工作的时候，你很难搞清楚在任一情况下数据到底变成了什么样子，而这也就是大多数 bug 的来源。</p>
<a id="more"></a>
<h1 id="响应式异步编程模型"><a class="markdownIt-Anchor" href="#响应式异步编程模型"></a> 响应式异步编程模型</h1>
<p>在客户端的异步编程中，最核心的概念就是：事件。换句话说，就是数据流变化的标志。比如当一个请求 api 的函数获取到了返回结果，这就是一个事件。异步编程的职责就是去处理好这些事件和事件所带有的数据。当然了，这些数据并不一定就是最终要使用的数据，我们可能需要对这些数据做点处理，才能最终应用。</p>
<p>简单来说，大概就是这样的模型：</p>
<p><img src="https://bebopfzj.oss-cn-hangzhou.aliyuncs.com/uPic/2020-08-27-P0OKcw.png" alt="响应式异步编程模型" /></p>
<p>不过在接下来的关于 <code>Combine</code> 的介绍中，我们会发现，实际中事件的出现与数据处理有时候并不是独立地，它们会经常结对出现。不过最终还是会通过一个事件的订阅者来使用这些数据。</p>
<h1 id="combine-介绍"><a class="markdownIt-Anchor" href="#combine-介绍"></a> Combine 介绍</h1>
<p>这里引用一下苹果关于 <code>Combine</code> 的 <a href="https://developer.apple.com/documentation/combine" target="_blank" rel="noopener">介绍</a>:</p>
<blockquote>
<p>The Combine framework provides a declarative Swift API for processing values over time. These values can represent many kinds of asynchronous events. Combine declares publishers to expose values that can change over time, and subscribers to receive those values from the publishers.</p>
</blockquote>
<p>可以看出，这里的核心就是 <code>values over time</code>。通过 <code>publishers</code> 来提供随时间变化的数据，然后由 <code>subscribers</code> 来接收这些数据并处理。注意到这里模糊了事件产出和数据处理的界限。因为一个数据处理的行为同样也可以产出一个事件。<code>Combine</code> 将 <code>Publisher</code> 和 <code>Subscribers</code> 定义为协议，从而控制其行为。</p>
<h2 id="publisher"><a class="markdownIt-Anchor" href="#publisher"></a> Publisher</h2>
<p>关于 <code>Publisher</code>，苹果给出了一段定义：</p>
<blockquote>
<p>The Publisher protocol declares a type that can deliver a sequence of values over time. Publishers have operators to act on the values received from upstream publishers and republish them.</p>
</blockquote>
<p>从定义可以看出，<code>Publisher</code> 实际上就是一个可以随时间交付一系列值的过程。理所当然的，你也可以组合多个不同的 <code>Publisher</code> 来形成你自己的数据更新逻辑。这里给出协议的定义：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">Publisher</span> </span>&#123;</span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">Output</span></span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">Failure</span> : <span class="type">Error</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">receive</span>&lt;S&gt; <span class="params">(subscriber: S)</span></span> <span class="keyword">where</span></span><br><span class="line">        <span class="type">S</span> : <span class="type">Subscriber</span>,</span><br><span class="line">        <span class="type">Self</span>.<span class="type">Failure</span> == <span class="type">S</span>.<span class="type">Failure</span></span><br><span class="line">        <span class="type">Self</span>.<span class="type">Output</span> == <span class="type">S</span>.<span class="type">Input</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总的来说，一个 <code>Publisher</code> 可以发布三种事件：（有一说一，从设计上来说，跟 Promise 没啥区别）</p>
<ul>
<li>Output 类型的新值</li>
<li>Failure 类型的错误</li>
<li>事件完成</li>
</ul>
<p>第一种事件是由 <code>Publisher</code> 直接发布的，后两种则是使用 <code>Subscribers.Completion</code> 来描述。它是一个含有两个成员的 <code>enum</code>，成员类型为 <code>.failure</code> 和 <code>finished</code>。</p>
<p>另外的，<code>Publisher</code> 所必须实现的 <code>receive(subscriber:)</code> 方法是用来接受 <code>Subscriber</code> 的。</p>
<p>最后，<code>Combine</code> 提供了一系列内建的 <code>Publisher</code> 来处理数据，你可以在 <a href="https://developer.apple.com/documentation/combine/publisher" target="_blank" rel="noopener">官方文档</a> 获得更多信息。</p>
<h2 id="subscriber"><a class="markdownIt-Anchor" href="#subscriber"></a> Subscriber</h2>
<p>同样的，我们直接引用苹果关于 <code>Subscriber</code> 的定义：</p>
<blockquote>
<p>At the end of a chain of publishers, a Subscriber acts on elements as it receives them. Publishers only emit values when explicitly requested to do so by subscribers. This puts your subscriber code in control of how fast it receives events from the publishers it’s connected to.</p>
</blockquote>
<p>可以看出，<code>Subscriber</code> 是作为 <code>Publisher</code> 链的结束的。这里我们给出 <code>Subscriber</code> 协议的定义：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">Subscriber</span> </span>&#123;</span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">Input</span></span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">Failure</span> : <span class="type">Error</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">receive</span> <span class="params">(subscription: Subscription)</span></span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">receive</span> <span class="params">(<span class="number">_</span> input: <span class="keyword">Self</span>.Input)</span></span> -&gt; <span class="type">Subscribers</span>.<span class="type">Demand</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">receive</span> <span class="params">(completion: Subscribers.Completion&lt;<span class="keyword">Self</span>.Failure&gt;)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果一个 <code>Subscriber</code> 想要订阅 <code>Publisher</code>，那么 <code>Subscriber</code> 的 <code>Input</code> 与 <code>Failure</code> 必须与 <code>Publisher</code> 的 <code>Output</code> 和 <code>Failure</code> 相同。</p>
<p>另外的，你可以参考这段话来理解 <code>Publisher</code> 和 <code>Subscriber</code> 的工作方式：</p>
<blockquote>
<p>You connect a subscriber to a publisher by calling the publisher’s subscribe() method. After making this call, the publisher invokes the subscriber’s receive(subscription:) method. This gives the subscriber a Subscription instance, which it uses to demand elements from the publisher, and to optionally cancel the subscription. After the subscriber makes an initial demand, the publisher calls receive(), possibly asynchronously, to deliver newly-published elements. If the publisher stops publishing, it calls receive(completion:), using a parameter of type Subscribers.Completion to indicate whether publishing completes normally or with an error.</p>
</blockquote>
<p>简单来说，大致包含以下几个部分的内容：</p>
<ol>
<li>关于订阅。<code>Subscriber</code> 通过调用 <code>Publisher</code> 的 <code>subscribe(_ :)</code> 方法来将自己与发布者连接起来。</li>
<li>关于订阅的处理。<code>Publisher</code> 会调用 <code>Subscriber</code> 的 <code>receive(subscription:)</code> 方法来为订阅者产出一个订阅实例。订阅者可以通过这个实例来从发布者获取数据，或是取消订阅。另外的，发布者可能会异步的调用自身协议实现的 <code>receive()</code>方法来为订阅者产出值。</li>
<li>关于发布者的终止。当发布者停止时，会调用 <code>receive(completion: Subscribers.Completion&lt;Self.Failure&gt;)</code> 来表示发布是正常完成还是由于错误导致终止。</li>
</ol>
<h2 id="subject"><a class="markdownIt-Anchor" href="#subject"></a> Subject</h2>
<p>其实这东西本身就是一个 <code>Publisher</code> 。单独提出来说的原因是，它是作为一座桥梁，将传统的指令式异步 API 里的事件转换到响应式的世界中。这里我们给出协议的定义：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">Subject</span>: <span class="title">AnyObject</span>, <span class="title">Publisher</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">(<span class="number">_</span> value: <span class="keyword">Self</span>.Output)</span></span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">(completion: Subscribers.Completion&lt;<span class="keyword">Self</span>.Failure&gt;)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个协议暴露了两个 <code>send</code> 方法，来让外部调用者主动发布 <code>Output</code> 值或是 <code>failure</code> ，<code>finished</code> 事件。</p>
<p><code>Combine</code> 内置了两个常用的 <code>Subject</code>。即 <code>CurrentValueSubject</code> 和 <code>PassthroughSubject</code></p>
<h3 id="currentvaluesubject"><a class="markdownIt-Anchor" href="#currentvaluesubject"></a> CurrentValueSubject</h3>
<p>官方文档已经解释的很清楚了：</p>
<blockquote>
<p>A subject that wraps a single value and publishes a new element whenever the value changes.</p>
</blockquote>
<p>这里有一个例子：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> curr = <span class="type">CurrentValueSubject</span>&lt;<span class="type">Int</span>, <span class="type">Never</span>&gt; (<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">curr.sink(</span><br><span class="line">    receiveCompletion: &#123; complete <span class="keyword">in</span></span><br><span class="line">        <span class="built_in">print</span>(complete)</span><br><span class="line">    &#125;,</span><br><span class="line">    receiveValue &#123; value <span class="keyword">in</span></span><br><span class="line">        <span class="built_in">print</span>(value)</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">curr.value = <span class="number">1</span></span><br><span class="line">curr.value = <span class="number">2</span></span><br><span class="line">curr.send(completion: .finished)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// finished</span></span><br></pre></td></tr></table></figure>
<p>在订阅后，<code>Publisher</code> 里存储的值立即被发送给了 <code>receiveValue</code>。另外的，每一次的 <code>curr.value</code> 赋值都会触发订阅者的响应。</p>
<h3 id="passthroughsubject"><a class="markdownIt-Anchor" href="#passthroughsubject"></a> PassthroughSubject</h3>
<p>同样的，直接引用官方文档的解释：</p>
<blockquote>
<p>A subject that broadcasts elements to downstream subscribers.</p>
</blockquote>
<p>比起前者，它很简单，就直接将 <code>send</code> 接收到的值转发给了下游的 <code>Publisher</code> 或者是 <code>Subscriber</code>。这里是例子：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> pass = <span class="type">PassthroughSubject</span>&lt;<span class="type">Int</span>, <span class="type">Never</span>&gt; ()</span><br><span class="line"></span><br><span class="line">pass.sink(</span><br><span class="line">    receiveCompletion: &#123; complete <span class="keyword">in</span></span><br><span class="line">        <span class="built_in">print</span>(complete)</span><br><span class="line">    &#125;,</span><br><span class="line">    receiveValue: &#123; value <span class="keyword">in</span></span><br><span class="line">        <span class="built_in">print</span>(value)</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">pass.send(<span class="number">1</span>)</span><br><span class="line">pass.send(<span class="number">2</span>)</span><br><span class="line">pass.send(completion: .finished)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// finished</span></span><br></pre></td></tr></table></figure>
<p>订阅之后的第一次 <code>send</code> 才会将值传给下游。如果你在订阅前就调用了 <code>send</code>，那么下游是接收不到这个值的。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%BC%82%E6%AD%A5/" rel="tag"># 异步</a>
              <a href="/tags/IOS/" rel="tag"># IOS</a>
              <a href="/tags/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B/" rel="tag"># 响应式编程</a>
              <a href="/tags/combine/" rel="tag"># combine</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/08/25/%E4%BB%8E%E8%AE%A1%E7%AE%97%E7%9A%84%E6%9C%AC%E8%B4%A8%E6%9D%A5%E8%AE%A8%E8%AE%BA%E9%80%92%E5%BD%92/" rel="prev" title="从计算的本质来讨论递归">
      <i class="fa fa-chevron-left"></i> 从计算的本质来讨论递归
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/08/28/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B%E4%B8%8ECombine2/" rel="next" title="响应式编程与Combine（二）">
      响应式编程与Combine（二） <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#响应式编程"><span class="nav-number">1.</span> <span class="nav-text"> 响应式编程</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#响应式异步编程模型"><span class="nav-number">2.</span> <span class="nav-text"> 响应式异步编程模型</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#combine-介绍"><span class="nav-number">3.</span> <span class="nav-text"> Combine 介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#publisher"><span class="nav-number">3.1.</span> <span class="nav-text"> Publisher</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#subscriber"><span class="nav-number">3.2.</span> <span class="nav-text"> Subscriber</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#subject"><span class="nav-number">3.3.</span> <span class="nav-text"> Subject</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#currentvaluesubject"><span class="nav-number">3.3.1.</span> <span class="nav-text"> CurrentValueSubject</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#passthroughsubject"><span class="nav-number">3.3.2.</span> <span class="nav-text"> PassthroughSubject</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="ShroXd"
      src="https://bebopfzj.oss-cn-hangzhou.aliyuncs.com/uPic/2020-12-29-mRBWDE.JPG">
  <p class="site-author-name" itemprop="name">ShroXd</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">52</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">107</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/ShroXd" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;ShroXd" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:shroxdf@gmail.com" title="E-Mail → mailto:shroxdf@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml"><i class="fa fa-rss fa-fw"></i>RSS</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        
  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">鲁ICP备19050480号-1 </a>
      <img src="https://bebopfzj.oss-cn-hangzhou.aliyuncs.com/uPic/2020-12-30-Rzqf63.png" style="display: inline-block;">
  </div>

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ShroXd</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : 'ec5cfb9ea4555ffd29ce',
      clientSecret: 'a0747147682b2ae812bb8aceb071ec64a6ddacf6',
      repo        : 'ShroXd.github.io',
      owner       : 'ShroXd',
      admin       : ['ShroXd'],
      id          : '57ca0c7012ae38f5f57f4883e90116b4',
        language: '',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

</body>
</html>
