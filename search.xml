<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>React 学习笔记（一）</title>
      <link href="/2021/04/08/ReactNote1/"/>
      <url>/2021/04/08/ReactNote1/</url>
      
        <content type="html"><![CDATA[<h1 id="react-设计思想"><a class="markdownIt-Anchor" href="#react-设计思想"></a> React 设计思想</h1><p>如果想要理解一个新框架，搞清楚其所解决的问题和解决思路是第一步。只要把握住了这一点，就能很容易理解那些看起来很奇怪的 API 设计。<br />如果你像笔者一样，之前有 Vue 的使用经验，就更应该注意到这一点。因为这两个框架虽然都在解决相同的问题，但其解决思路确实大不相同的，甚至在一些地方的设计上是截然相反的。如果仅仅将它们看做两个 API 不同的框架，用 Vue 的经验去写 React 代码，结果就只能是“深入金山空手归”了。</p><h2 id="现代前端框架存在的意义"><a class="markdownIt-Anchor" href="#现代前端框架存在的意义"></a> 现代前端框架存在的意义</h2><p>从手写 HTML、CSS、JavaScript 代码，到 <code>jQuery</code> 的横空出世，再到现在前端框架三足鼎立的局面。框架作者总是考虑着更好的解决方案。<br />但是什么促使社区从 <code>jQuery</code> 转向了三大框架呢？原因就是 <strong>手动同步 state 与 UI 是非常困难的</strong>。<br />我们需要一种抽象，来完成繁琐的 DOM 销毁、创建、重排工作。这也就是现代前端框架存在的意义。</p><blockquote><p>关于这个问题，你可以进一步阅读 <a href="https://medium.com/dailyjs/the-deepest-reason-why-modern-javascript-frameworks-exist-933b86ebc445" target="_blank" rel="noopener">The deepest reason why modern JavaScript frameworks exist</a></p></blockquote><p>相较于 <code>Vue</code> 借助响应式系统进行细粒度更新的设计，<code>React</code> 的渲染则更为粗粒度。<br />你可能会觉得这种设计是在傻跑渲染函数，更进一步的，如果你对 <code>React</code> 有所了解，你应该会知道 <code>React</code> 默认的渲染策略是，如果父组件改变了，子组件也会跟着重新渲染，而不论子组件的 <code>props</code> 有没有改变。<br />简单来说，这都是因为 <code>React</code> 本身的设计和一些工程上的妥协导致的结果。一旦理解了背后的原因，你会发现它们不会再那么别扭了。</p><h2 id="渲染策略"><a class="markdownIt-Anchor" href="#渲染策略"></a> 渲染策略</h2><p>正如前面提到的，<code>React</code> 的渲染是比较粗粒度的。<code>React</code> 将组件看为一个个的 <code>pure function</code>，<code>state</code> 是其内部状态，<code>props</code> 是外来的状态，任何一方改变了都会引起重新渲染。</p><p>另外的，<code>React</code> 的默认渲染行为是：一旦 parent 重新渲染了，child 也会被重新渲染。</p><p>这一切设计的根源就在于 <strong>immutable</strong>。</p><blockquote><p>关于渲染，你可以进一步阅读 <a href="https://blog.isquaredsoftware.com/2020/05/blogged-answers-a-mostly-complete-guide-to-react-rendering-behavior/#immutability-and-rerendering" target="_blank" rel="noopener">Blogged Answers: A (Mostly) Complete Guide to React Rendering Behavior</a></p></blockquote><h2 id="immutable"><a class="markdownIt-Anchor" href="#immutable"></a> immutable</h2><p>在讨论 immutable data 之前，我们先看看 JavaScript 中老生常谈的 mutable data。在学习 JavaScript 初期，你应当见识过如下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123;</span><br><span class="line">    name: <span class="string">'Spike'</span>,</span><br><span class="line">    age: <span class="number">24</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> obj2 = obj1;</span><br><span class="line"></span><br><span class="line">obj2.name = <span class="string">'Jet'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj1.name);     <span class="comment">// Jet</span></span><br></pre></td></tr></table></figure><p>原因很简单，<code>obj2</code> 通过赋值操作拿到的仅仅是源对象的 reference，它并没有真正的持有那个对象。由此而来的解决方案便是“深拷贝”。只要让 <code>obj2</code> 拿到一份独立的数据，对它的任何操作就不会再影响到 <code>obj1</code> 了。</p><p>而 immutable data 就不一样了，它是一旦创建，就不能被更改的数据。如果你执意要修改它们，就都会得到一份新的 immutable 对象。</p><blockquote><p>如果你想知道这是怎么做到的，<a href="https://immutable-js.github.io/immutable-js/" target="_blank" rel="noopener">immutable.js</a> 的源码会是非常好的阅读材料</p></blockquote><p>在 React 的语境下，这种设计带来的极大的遍历。即如果我们想要知道两个数据是否相同，直接比较他们的 reference 就行了，没必要再去做麻烦的深度递归比较。</p><blockquote><p>当然了，深度比较并不总是麻烦事，<a href="https://tvcutsem.github.io/membranes" target="_blank" rel="noopener">Membranes pattern</a>可以帮助你很容易的完成这件事</p></blockquote><p>这意味着你不能像往常一样这样写代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [todos, setTodos] = useState(todosArray);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> onClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    todos[<span class="number">2</span>].completed = <span class="literal">true</span>;</span><br><span class="line">    setTodos(todos);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尽管这很符合开发直觉，但在 React 中这样写，你可能会纠结于为什么这个组件<strong>不</strong>会正确的重新渲染。原因也说过了，就是因为 React 并不会监测非基本类型数据深层属性的更改。<br />换句话说，你得这么写：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [todos, setTodos] = useState(todosArray);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> onClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> updatedTodos = todos.map(<span class="function"><span class="params">todo</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (todo === selectedTodo) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123; ...todo, <span class="attr">completed</span>: !todo.completed &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> todo;</span><br><span class="line">    &#125;);</span><br><span class="line">    setTodos(tods);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时刻保证你 set 进去的东西是一个新的对象。</p><p>不过显而易见的是，这种设计会导致很多的垃圾，不过 V8 在垃圾回收方面做的很棒，所以理论上来说并不会造成多大的性能影响。</p><blockquote><p>如果你对 V8 的垃圾回收感兴趣，你可以阅读 <a href="https://deepu.tech/memory-management-in-v8/" target="_blank" rel="noopener">Visualizing memory management in V8 Engine (JavaScript, NodeJS, Deno, WebAssembly)</a></p></blockquote><h2 id="默认渲染行为"><a class="markdownIt-Anchor" href="#默认渲染行为"></a> 默认渲染行为</h2><p>尽管通过 immutable 的设计，我们避免了麻烦的对象深度递归比较。但躲得了一时，躲不了一世。我们依然有个麻烦需要解决，也即 props 的比较。</p><p>在 React 的设计中，props 就像是函数的参数一样，作为修改组件行为的外部信号，是编写组件逻辑非常重要的一环。更进一步的说，props 的变化一定会导致组件的重新渲染。那么一个很容易想到的工作是，我们是不是得在适当的时机比较组件 props ，以确认它们是否发生变化了？</p><p>这是很正确的想法，且在理论上也没什么问题。但现实情况是，比较算法的时间复杂度是 O(props length) 的。尽管它并不是什么高消耗的逻辑，但每次判断都需要重新跑一遍，累积起来的损耗也是很大的。所以 React 在这里做了工程上的妥协，即：<br /><strong>只要父组件重新渲染了，就重新渲染子组件，不论子组件的 props 是否发生了变化。</strong></p><p>Dan 在 twitter 上也<a href="https://twitter.com/dan_abramov/status/1095661142477811717" target="_blank" rel="noopener">回答</a>过这个问题。</p><h2 id="不同的心智模型"><a class="markdownIt-Anchor" href="#不同的心智模型"></a> 不同的心智模型</h2><p>一个常见的 Functional Component 是这样的：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;&gt;</span><br><span class="line">            &lt;h1&gt; You clicked &#123;count&#125; times&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">            &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;</span></span><br><span class="line"><span class="regexp">                Click me</span></span><br><span class="line"><span class="regexp">            &lt;/</span>button&gt;</span><br><span class="line">        &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>如果你没有了解过 React 内部的渲染逻辑，你可能会认为这个组件仅会在初始化时被调用。拿到函数返回的 JSX 代码后交由 render 模块进行渲染工作。</p><p>但事实并非如此。在每一次点击后，React 实际上都会得到一个新的组件函数，然后 React 每次都会调用它并渲染结果。为了理解这种工作方式，我们可以使用“代换模型”来理解：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// first render</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> &lt;h1&gt;You clicker &#123;count&#125; times&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ second render</span></span><br><span class="line"><span class="regexp">function Counter() &#123;</span></span><br><span class="line"><span class="regexp">    const count = 1;</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ ...</span></span><br><span class="line"><span class="regexp">    return &lt;h1&gt;You clicker &#123;count&#125; times&lt;/</span>h1&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// third render</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> count = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> &lt;h1&gt;You clicker &#123;count&#125; times&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>换句话说，你得注意到我们实际上是在每次渲染都执行函数拿到新的 virtual node。从理论上讲，我们写的这个 functional component 应当是一个 pure function。</p><p>更进一步的，诸如 <code>props</code>、<code>effect</code> 等东西，在每一次渲染时实际上都是独立的个体。每一次渲染所依赖的本地状态也都是独立的。</p><p>这意味着一个使用过 Vue 的程序员可能会感到别扭。因为 Vue 的逻辑更符合直觉，即 setup 函数只执行一次。如果我们想要依据某些数据源加点副作用，我们就得使用 <code>watch</code> 来做。</p><h1 id="react-编程模型"><a class="markdownIt-Anchor" href="#react-编程模型"></a> React 编程模型</h1><p>React 运行时做了很多特殊处理，理解这些原理有助于你写出更加地道的 React 代码，但这部分内容不是必须的。</p><h2 id="宿主树与渲染器"><a class="markdownIt-Anchor" href="#宿主树与渲染器"></a> 宿主树与渲染器</h2><p>在设计一个复杂系统，特别是有多端复用需求的系统时，<strong>分层</strong>就是一个显而易见的解决方案。<br />将框架的核心逻辑抽象出来，然后针对特定的平台编写特定的适配代码。只要各层都遵守了信息交互的约定，为一个新平台编写适配代码将会变得非常容易。<br />以 React / Vue 为代表的前端框架选择的分层方案是：Virtual DOM。<br />简单来说，就是用 JavaScript Object 来描述 DOM 结构，这种描述方案只与 UI 界面结构相关，而与特定平台无关。而这个用来描述 DOM 结构的 JavaScript Object 就是 Virtual DOM，你也可以将其称之为<strong>宿主树</strong>（这个定义与 Dan 的定义相比稍显狭隘）。React / Vue 借助这个由编译器生成的对象，可以完整的掌握 UI 界面的一切信息，之后的渲染工作也就顺理成章了。</p><p>那么，接下来的问题是，我们该如何将这个掌握了 UI 界面所有信息的 Object 转换成 UI 界面呢？答案就是编写特定平台的渲染器。<br />这个渲染器将会依据编译器给出的宿主树，调用平台的 API 来渲染特定元素。例如在浏览器中，可以这样创建一个 ‘div’ 节点。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br></pre></td></tr></table></figure><h2 id="两个阶段与批量更新"><a class="markdownIt-Anchor" href="#两个阶段与批量更新"></a> 两个阶段与批量更新</h2><p>如果你看过 React 官方的生命周期图，你会发现组件的生命周期被分为了两个部分：</p><ul><li>Render 阶段</li><li>Commit 阶段</li></ul><blockquote><p>完整的<a href="https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/" target="_blank" rel="noopener">生命周期图</a></p></blockquote><p>这样设计的原因是为了避免重复的子组件渲染。换句话说，React 不在乎源数据变化的过程，而只在乎结果。</p><p>而这两个阶段最大的区别就是：在一次修改中，Render 阶段的方法可能会被多次调用，而 Commit 阶段的方法则仅会被调用一次（当然是在 production mode 下）。这也就是说，记的不要把一些副作用函数放在 Render 阶段的生命周期方法里。</p><blockquote><p>你可以阅读这篇<a href="https://techdoma.in/react-16-tutorial/what-are-render-phase-and-commit-phase-in-react" target="_blank" rel="noopener">文章</a>来获取更多有关两个阶段的信息。</p></blockquote><p>实际上，这种设计也就意味着，React 会先合并所有的修改，再进行批量更新。更准确的说发法是：<br /><strong>React 会在组件内所有事件触发完成后再进行批量更新</strong></p><p>这种设计乍看起来很美妙，但对于初次使用 React 的开发者来说，他们可能会遇到很多莫名其妙的问题，猜猜看这段代码的结果是什么？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">increment</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    setCount(count + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleClick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    increment();</span><br><span class="line">    increment();</span><br><span class="line">    increment();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事实上，这段代码只是执行了三次 <code>setCount(1)</code>。如果你理解了上面提到的批量更新，你应当可以想到这段代码的行为为什么会是这样了吧。</p><p>问题有了，处理办法呢？给 setState 传一个函数就行了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">increment</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    setCount(<span class="function"><span class="params">c</span> =&gt;</span> c + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleClick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    increment();</span><br><span class="line">    increment();</span><br><span class="line">    increment();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就保证了 state 是被链式更新的。</p><p>React 内部应当实现了一个和 Vue 相同思路的调度器。维护了传入 <code>setState</code> 的函数，借助 JavaScript 引擎的 task queue，在适当时机遍历并调用他们。</p><p>另外的，多说一句，如果一下子 setState 很多，那你可以考虑使用 <code>useReducer</code>。</p><h2 id="diff"><a class="markdownIt-Anchor" href="#diff"></a> diff</h2><h2 id="比纯净更重要的是幂等性"><a class="markdownIt-Anchor" href="#比纯净更重要的是幂等性"></a> 比纯净更重要的是幂等性</h2><p>局部的 props 突变是允许的</p><h2 id="ioc"><a class="markdownIt-Anchor" href="#ioc"></a> IoC</h2><h2 id="批量更新"><a class="markdownIt-Anchor" href="#批量更新"></a> 批量更新</h2><p>？放入了 macro task queue 中吗</p><h1 id="函数式组件与类组件"><a class="markdownIt-Anchor" href="#函数式组件与类组件"></a> 函数式组件与类组件</h1><p>一言以蔽之：<strong>函数式组件捕获了渲染所用的值</strong></p><p>在 Class 写法中，你可能会通过 <code>this.props.name</code> 这样的方式来获取一个 prop 的值。尽管 props 是不可变的，但 this 却会改变。这意味着如果你需要一个数据来完成异步逻辑，在该逻辑执行完成之前就改变了 this 的值，这个异步逻辑可能会基于一个“过于新”的值来执行。</p><p>这个行为从理论上来说无懈可击，因为代码关注的是“真实”的值。但问题在于，我们编写的是 UI 代码。不论是从开发者还是用户的角度来看，<strong>事件处理程序应当属于一个拥有特定 props 和 state 的特定渲染</strong>。也就是说，在用户点下按钮的瞬间，处理逻辑得到的数据就不应该再变化了，所见应当是所得。</p><p>当然了，Class 写法虽然有这种问题，但很好解决。思路实际上和 JavaScript 中老生常谈的 “this 捕获” 是一样的。比如你可以这样写组件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">const</span> props = <span class="keyword">this</span>.props;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理逻辑</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;props.name&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过你应当注意到了，这种写法下，class 根本就没有存在的必要嘛。在 render 下写这么一大堆处理逻辑的代码，还不如直接用 functional component 的写法来实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyComponent</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 处理逻辑...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;props.name&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你还可以借助 ES6 的解构赋值来让这个“捕获”行为更加清晰：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyComponent</span>(<span class="params">&#123; name &#125;</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 处理逻辑...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;name&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的道理，这个原则也适用于 state：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyComponent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [name, setName] = useState(<span class="string">'Spike'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理逻辑...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;name&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数一开始的解构赋值实际上就“捕获”了当前的 state。</p><blockquote><p>关于这个主题，你可以阅读 Dan 的 <a href="https://overreacted.io/how-are-function-components-different-from-classes/" target="_blank" rel="noopener">How Are Function Components Different from Classes?</a> 以获取更多信息。</p></blockquote><h1 id="hooks"><a class="markdownIt-Anchor" href="#hooks"></a> Hooks</h1><p>在以数据驱动的前端开发中，一个容易想到的分层就是将<em>特定数据</em>与<em>处理逻辑</em>分离开。因为业务逻辑虽然是多变的，但是其中很多行为都是重复的。例如对员工的删减和对学生的删减，虽然这是两个截然不同的需求，但很容易看出它们背后的逻辑几乎是一致的。我们没有必要为了这两个需求完全重写处理逻辑。</p><p>更进一步的说，我们可以借鉴 Unix 中的思路，通过某种方法去创建一系列仅专注于单一任务的模块，在实现业务逻辑时，再将它们组合起来，完成复杂的任务。而实现这一需求的办法就是 Hooks。</p><p>Hooks 的思想实际上就是将处理逻辑与数据本身剥离开，以得到更好的复用能力。</p><h2 id="为什么-hooks-有这么多规则"><a class="markdownIt-Anchor" href="#为什么-hooks-有这么多规则"></a> 为什么 Hooks 有这么多规则</h2><p>关于 Hooks，你可能知道一些使用规则：</p><ul><li>不要在循环、条件语句或嵌套函数中使用 Hooks</li><li>只在 React Functional Component 中使用 Hooks</li></ul><p>为了解释清楚这些看起来匪夷所思的规则，你需要对 Hooks 内部的运行机制有所了解。简单来说，每一次你调用 <code>useState</code> 时，state 与 setState 会合起来作为一层加入到底层的数据结构中。实际实现中用的是链表，但如果你理解为数组也无关紧要。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> states = []</span><br><span class="line"><span class="keyword">const</span> setStates = []</span><br><span class="line"><span class="keyword">let</span> cursor = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在调用一次 setState(0) 之后</span></span><br><span class="line">states = [name]</span><br><span class="line">setStates = [setName]</span><br></pre></td></tr></table></figure><p>对于每一个 <code>setState</code> 函数，我们都可以根据其下标，唯一的找到对应的 <code>state</code>。<br />可如果你违反了规则，在条件语句或是什么东西中使用了 <code>useState</code>，数组就会被推入一个“影子层”，它可能存在也可能不存在。这就会导致 <code>setState</code> 的调用可能会出问题。</p><blockquote><p>关于 Hooks 的运行机制，你可以阅读 <a href="https://medium.com/@ryardley/react-hooks-not-magic-just-arrays-cd4f1857236e" target="_blank" rel="noopener">React hooks: not magic, just arrays</a> 以获得更多信息。</p></blockquote><h2 id="useeffect-与数据请求"><a class="markdownIt-Anchor" href="#useeffect-与数据请求"></a> useEffect 与数据请求</h2><blockquote><p>这一部分是阅读 <a href="https://overreacted.io/a-complete-guide-to-useeffect/" target="_blank" rel="noopener">A Complete Guide to useEffect</a> 的笔记</p></blockquote><h3 id="捕获"><a class="markdownIt-Anchor" href="#捕获"></a> 捕获</h3><p>想要完全理解并用好 <code>useEffect</code>，你需要明确一件已经被重复提到很多次的事实：<br /><strong>每一个组件内的函数（包括事件处理器、effects、定时器或 API 调用）都会捕获某次渲染中定义的 props/state</strong></p><p>这句话实际上等效于这段代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyComponent</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> count = props.count;</span><br><span class="line">    useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(count);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类似于我们以前常写的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> self = <span class="keyword">this</span>;</span><br></pre></td></tr></table></figure><p>我们实际上是捕获了这一次的 props/state 值。</p><h3 id="同步而非生命周期"><a class="markdownIt-Anchor" href="#同步而非生命周期"></a> 同步，而非生命周期</h3><p>在 Class 写法中，我们经常会根据生命周期来编写组件逻辑。但换到了函数式写法时，我们应当放弃熟悉的 mount/update/unmount 的心智模型，转而这样考虑：<br />我们实际上是在将当前的 props 和 state 同步到 DOM。</p><p>换句话说，React 不在乎经历了什么，它只在乎结果。</p><h3 id="依赖"><a class="markdownIt-Anchor" href="#依赖"></a> 依赖</h3><p>在默认行为中，每一次渲染后都会运行所有的 effects。不过这种逻辑实在是有点不管不顾。所以 React 为 useEffect 提供了第二个参数，我们可以传入依赖项，告诉 React：依赖项变了你再运行这个 effect。</p><p>不过如果你只是理解了这件事，你只在第一层。这个逻辑的第二层是：当前 effect <strong>仅</strong>依赖了在第二个参数中传入的东西。<br />这意味着一旦你传入了错误的依赖项，可能会导致一些完全无法理解的运行逻辑。</p><p>除此之外，还有第三层：不要理所当然的认为，依赖项是我们需要 effect 重复运行时才要去设置的。这是错误的认识。<strong>依赖是我们给 React 的暗示，告诉 React 我们使用了哪些值</strong>，看一个设置定时器的例子：</p><p>如果我们使用了<em>错误</em>的心智模型。即认为只有在需要 effect 反复运行时才去设置依赖。我们可能会这样实现这个组件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyComponent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> id = setinterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            setCount(count + <span class="number">1</span>);</span><br><span class="line">        &#125;, <span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> clearInterval(id);</span><br><span class="line">    &#125;, []);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;count&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基于错误的心智模型，我们很容易想到，定时器初始化只初始化一次，那将依赖写成 <code>[]</code> 不就完事了？然而这种写法是完全错误的。依赖不是去控制 effect 是否重复执行的，它是告诉 React effect 使用了哪些数据的通道。<br />也就是说，我们应该这样实现这个组件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyComponent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> id = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            setCount(count + <span class="number">1</span>);</span><br><span class="line">        &#125;, <span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> clearInterval(id);</span><br><span class="line">    &#125;, [count])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过这种解决办法有点拆东墙补西墙的意思。更好的办法是修改 effect 中的代码，以确保它包含的值只会在需要的时候发生变更。也就是说，减少依赖项。</p><p>比如这个计时器例子，我们在 effect 中的逻辑实际上是根据当前值进行累加。所以当前值具体什么根本不关我们的事，我们可以使用之前谈论过的，向 <code>setState</code> 中传入一个函数来完成这件事。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyComponent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> id = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            setCount(<span class="function"><span class="params">c</span> =&gt;</span> c + <span class="number">1</span>);</span><br><span class="line">        &#125;, <span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> clearInterval(id);</span><br><span class="line">    &#125;, [])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="think-in-react"><a class="markdownIt-Anchor" href="#think-in-react"></a> Think in React</h1><p>这里有一些步骤来帮助你更好的 Think in React，写出更加地道的代码：</p><ol><li>自下而上的拆分组件，组合成完整的应用</li><li>保持 state 的最小化：<ul><li>如果数据是由父组件通过 props 传入的，就不是 state</li><li>如果数据随着时间不变，就不是 state</li><li>如果可以根据 state 或 props 计算出数据的值，就不是 state</li></ul></li><li>确定 state 的位置：让一个包含了所有使用这个 state 的父组件持有该 state</li><li>通过使用 props 传入函数来增加反向数据流的能力</li></ol><p>注意，state 是那些随着时间变化的，且无法通过其他数据计算而来的数据。</p>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
            <tag> Runtime </tag>
            
            <tag> Hooks </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript 性能手册</title>
      <link href="/2021/03/04/TypescriptPerformance/"/>
      <url>/2021/03/04/TypescriptPerformance/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文是对 <a href="https://github.com/microsoft/TypeScript/wiki/Performance#filing-an-issue" target="_blank" rel="noopener">TypeScript Performance</a> 的翻译。因为有些句子在英文表达中很清晰，但直译却会变得晦涩难懂，所以部分句子选择了意译。</p></blockquote><p>有一些简单的方式来配置 TypeScript，从而获得更快的编译速度和更好的编程体验。越早采用这些实践越好。在最佳实践之前，这里有一些常见的技术，用于审查缓慢的编译速度或是编程体验，一些常见的修复方法，以及一些帮助使用 TypeScript 的团队调查问题的常见方法。</p><h1 id="编写容易编译的代码"><a class="markdownIt-Anchor" href="#编写容易编译的代码"></a> 编写容易编译的代码</h1><h2 id="优先选择接口而不是交叉类型"><a class="markdownIt-Anchor" href="#优先选择接口而不是交叉类型"></a> 优先选择接口而不是交叉类型</h2><p>大多数时候，对象类型的一个简单类型别名的行为和接口是非常相似的。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Foo &#123; prop: <span class="built_in">string</span> &#125;</span><br><span class="line"><span class="keyword">type</span> Bar = &#123; prop: <span class="built_in">string</span> &#125;</span><br></pre></td></tr></table></figure><p>然而，一旦你需要组合两个或更多的类型，你就需要选择是扩展一个既定的接口，还是使用交叉类型了。这也就是差异开始显现的时候了。</p><p>接口创建一个单一的无嵌套对象类型来检测属性冲突，这对解决冲突是很重要的！另一方面，交叉类型仅是递归的合并属性，然后在某些情况下产出 <code>never</code>。接口的一致性通常会更好，而交叉类型的别名经常无法在其他交叉类型的部分中显示。接口之间的类型关系也会被缓存，而不是作为一个整体的交叉类型。最后一个不同点是当检查一个目标交叉类型前，在检查“有效/无嵌套”类型之前，会先检查类型的每一个组成成分。</p><p>根据这些理由，我们建议你借助 <code>extends</code> 来扩展 <code>interface</code>，而不是创建一个新的交叉类型。</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">- type Foo = Bar &amp; Baz &amp; &#123;</span></span><br><span class="line"><span class="deletion">-    someProp: string;</span></span><br><span class="line"><span class="deletion">- &#125;</span></span><br><span class="line"><span class="addition">+ interface Foo extends Bar, Baz &#123;</span></span><br><span class="line"><span class="addition">+    someProp: string;  </span></span><br><span class="line"><span class="addition">+ &#125;</span></span><br></pre></td></tr></table></figure><h2 id="使用类型注解"><a class="markdownIt-Anchor" href="#使用类型注解"></a> 使用类型注解</h2><p>添加类型注解，特别是返回值的类型，可以为编译器节省很多工作。在某种程度上，这是因为命名类型比匿名类型更为紧凑（编译器可能会推断出匿名类型），这会节省大量读写声明文件的时间（例如用于增量构建时）。类型推断很方便，所以没必要到处都写成这样——不过如果你已经确认了这里是导致代码缓慢的部分，那么你可以尝试这样做。</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">- import &#123; otherFunc &#125; from "other";</span></span><br><span class="line"><span class="addition">+ import &#123; otherFunc, otherType &#125; from "other";</span></span><br><span class="line"></span><br><span class="line"><span class="deletion">- export function func() &#123;</span></span><br><span class="line"><span class="addition">+ export function func(): otherType &#123;</span></span><br><span class="line">    return otherFunc();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优先选择基础类型而不是联合类型"><a class="markdownIt-Anchor" href="#优先选择基础类型而不是联合类型"></a> 优先选择基础类型而不是联合类型</h2><p>联合类型很棒——它允许你将一大堆可能的值结合为一个类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> WeekdaySchedule &#123;</span><br><span class="line">    day: <span class="string">"Monday"</span> | <span class="string">"Tuesday"</span> | <span class="string">"Wednesday"</span> | <span class="string">"Thursday"</span> | <span class="string">"Friday"</span>;</span><br><span class="line">    wake: Time;</span><br><span class="line">    startWork: Time;</span><br><span class="line">    endWork: Time;</span><br><span class="line">    sleep: Time;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> WeekendSchedule &#123;</span><br><span class="line">    day: <span class="string">"Saturday"</span> | <span class="string">"Sunday"</span>;</span><br><span class="line">    wake: Time;</span><br><span class="line">    familyMeal: Time;</span><br><span class="line">    sleep: Time</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">printSchedule</span>(<span class="params">schedule: WeekdaySchedule | WeekendSchedule</span>)</span>;</span><br></pre></td></tr></table></figure><p>然而，这经常会有性能损耗。每次向 <code>printSchedule</code> 中传递参数时，都需要将其与联合类型中的每一个部分相比较。对于仅有两个元素的联合类型，这种损耗微不足道。然而，如果联合类型有许多元素，就会在编译阶段导致相当大的麻烦。例如，为了从联合类型中消除冗余成员，就需要对元素进行两两比对，消耗是二次曲线的。这种检查可能会发生在对复杂联合类型交叉时，交叉每个联合类型成员都可能导致大量的类型，然后需要编译器消除冗余的成员。为了避免这种情况的一种方法是使用子类型，而不是联合类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Schedule &#123;</span><br><span class="line">    day: <span class="string">"Monday"</span> | <span class="string">"Tuesday"</span> | <span class="string">"Wednesday"</span> | <span class="string">"Thursday"</span> | <span class="string">"Friday"</span> | <span class="string">"Saturday"</span> | <span class="string">"Sunday"</span>;</span><br><span class="line">    wake: Time;</span><br><span class="line">    sleep: Time;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> WeekdaySchedule <span class="keyword">extends</span> Schedule &#123;</span><br><span class="line">  day: <span class="string">"Monday"</span> | <span class="string">"Tuesday"</span> | <span class="string">"Wednesday"</span> | <span class="string">"Thursday"</span> | <span class="string">"Friday"</span>;</span><br><span class="line">  startWork: Time;</span><br><span class="line">  endWork: Time;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> WeekendSchedule <span class="keyword">extends</span> Schedule &#123;</span><br><span class="line">  day: <span class="string">"Saturday"</span> | <span class="string">"Sunday"</span>;</span><br><span class="line">  familyMeal: Time;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">printSchedule</span>(<span class="params">schedule: Schedule</span>)</span>;</span><br></pre></td></tr></table></figure><p>尝试为每种内置 DOM 元素类型建模时，可能会出现一个更加现实的例子。在这种情况下，最好是创建一个含有公共成员的基本类型 <code>HtmlElement</code>。使用 <code>DivElement</code>，<code>ImgElement</code> 类扩展，而不是创建穷举的联合类型 <code>DivElement | /*...*/ | ImgElement | /*...*/</code>。</p><h1 id="使用-project-references"><a class="markdownIt-Anchor" href="#使用-project-references"></a> 使用 Project References</h1><p>当使用 TypeScript 构建一个庞大的代码库时，将代码库组织成几个独立的项目将会很有帮助。每一个项目都会有自己的 <code>tsconfig.json</code>，它们独立于其他项目。这可以避免同时编译太多文件，也可以使得代码库更容易的组合在一起。</p><p>这里有一些基础的方法来将<a href="https://www.typescriptlang.org/docs/handbook/project-references.html" target="_blank" rel="noopener">将代码库组织成多个项目</a>。例如，一个程序可能有一个客户端项目，一个服务端项目，以及一个二者共享的项目。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">              ------------</span><br><span class="line">              |          |</span><br><span class="line">              |  Shared  |</span><br><span class="line">              ^----------^</span><br><span class="line">             &#x2F;            \</span><br><span class="line">            &#x2F;              \</span><br><span class="line">------------                ------------</span><br><span class="line">|          |                |          |</span><br><span class="line">|  Client  |                |  Server  |</span><br><span class="line">-----^------                ------^-----</span><br></pre></td></tr></table></figure><p>测试也可以分别被写入各个项目中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">              ------------</span><br><span class="line">              |          |</span><br><span class="line">              |  Shared  |</span><br><span class="line">              ^-----^----^</span><br><span class="line">             &#x2F;      |     \</span><br><span class="line">            &#x2F;       |      \</span><br><span class="line">------------  ------------  ------------</span><br><span class="line">|          |  |  Shared  |  |          |</span><br><span class="line">|  Client  |  |  Tests   |  |  Server  |</span><br><span class="line">-----^------  ------------  ------^-----</span><br><span class="line">     |                            |</span><br><span class="line">     |                            |</span><br><span class="line">------------                ------------</span><br><span class="line">|  Client  |                |  Server  |</span><br><span class="line">|  Tests   |                |  Tests   |</span><br><span class="line">------------                ------------</span><br></pre></td></tr></table></figure><p>一个常见的问题是：“一个项目究竟该有多大？”。这和“一个函数究竟应该多大？”或“一个类究竟应该多大？”很相似。这在很大程度上取决于开发者的经验。一个常见的，用来分割 JS/TS 代码的方法是使用文件夹。从这里我们可以得到启发，如果一些事物之间的关系足够强到可以将它们放入一个文件夹，那么它们就该是属于同一个项目中的。在那之前，应当避免创建巨大的或是微型项目。如果一个项目庞大到是其他所有项目之和，那这就是一个警告信号了。同样的，也应当避免创建一大堆仅有单一文件的项目，因为这会徒增无用的开销。</p><p>你可以阅读更多<a href="https://www.typescriptlang.org/docs/handbook/project-references.html" target="_blank" rel="noopener">有关项目链接的信息</a>。</p><h1 id="配置-tsconfigjson-或-jsconfigjson-文件"><a class="markdownIt-Anchor" href="#配置-tsconfigjson-或-jsconfigjson-文件"></a> 配置 <code>tsconfig.json</code> 或 <code>jsconfig.json</code> 文件</h1><p>TypeScript 和 JavaScript 使用者可以通过 <code>tsconfig.json</code> 文件来配置编译过程。[JavaScript 使用者则可以通过配置 <code>jsconfig.json</code> 来修改编程体验]。</p><h2 id="指定文件"><a class="markdownIt-Anchor" href="#指定文件"></a> 指定文件</h2><p>你得确保你的配置文件没有一次性囊括了太多文件。</p><p>在 <code>tsconfig.json</code> 中，有两种方法指定项目中的文件</p><ul><li><code>files</code> 列表</li><li><code>include</code> 和 <code>exclude</code> 列表</li></ul><p>这两者之间的首要区别是 <code>files</code> 接受一个指向源文件的文件列表，而 <code>include/exclude</code> 则是全局匹配文件。</p><p>当指定了 <code>files</code> 字段，这将会允许 TypeScript 快速的直接加载文件。假如你的项目中有很多文件，却没有一小部分头部的入口文件，这种方式可能会非常笨重。另外的，也会很容易忘记向 <code>tsconfig.json</code> 中添加新文件，这意味着您可能会纠结于陌生的代码编写方式。所有的这一切都会很麻烦。</p><p><code>include/exclude</code> 可以帮助避免去选择这些文件，但是要付出一定的代价：必须要通过遍历包含的文件路径来发现文件。一旦需要遍历非常多文件夹时，就会拖慢编译的速度。另外的，有时候编译将会包含很多不需要的 <code>.d.ts</code> 文件和测试文件，这会增加编译时间和内存占用。最后，尽管 <code>exclude</code> 有一些合理的默认配置，但一些比如 mono-repos 的配置将意味着像 <code>node-modules</code> 这样的文件夹依然可以被包含。</p><p>基于一些最佳实践，我们建议你：</p><ul><li>仅指定项目的入口文件夹（例如那些你想要编译/分析的源码）</li><li>不要把其他项目的源文件混到同一个文件夹里去</li><li>如果要把测试文件都放进和其他代码相同的文件夹里，那就清楚地给出命名，这样就可以轻松的排除它们</li><li>避免构建大型构件和像是 <code>node_modules</code> 这样的依赖文件夹</li></ul><p>Note：如果没有指定 <code>exclude</code> 字段，<code>node_modules</code> 文件夹是被默认排除的；一旦你添加了，那就记得赶紧排除掉 <code>node_modules</code> 文件夹。</p><p>下面是一个用来实现这项需求的合理的 <code>tsconfig.json</code> 配置：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"compilerOptions"</span>: &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"include"</span>: [<span class="string">"src"</span>],</span><br><span class="line">    <span class="attr">"exclude"</span>: [<span class="string">"**/node_modules"</span>, <span class="string">"**/.*/"</span>],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="控制包含的-types"><a class="markdownIt-Anchor" href="#控制包含的-types"></a> 控制包含的 <code>@types</code></h2><p>TypeScript 默认情况下会自动包含在 <code>node_modules</code> 文件夹下找到的所有 <code>@types</code> 包，而不管你是不是导入了它们。这是为了可以让 Node.js，Jasmine，Mocha，Chai 等包可以正常工作。因为它们并未被导入——它们仅仅是被加载到了全局环境中。</p><p>有时候这个逻辑会拖慢程序在编译和编辑时的速度。如果几个全局包的声明冲突了，这也会导致错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Duplicate identifier &#39;IteratorResult&#39;.</span><br><span class="line">Duplicate identifier &#39;it&#39;.</span><br><span class="line">Duplicate identifier &#39;define&#39;.</span><br><span class="line">Duplicate identifier &#39;require&#39;.</span><br></pre></td></tr></table></figure><p>在不需要全局包的情况下，这个问题很好修复。在 <code>tsconfig.json</code> / <code>jsconfig.json</code> 文件中为<a href="https://www.typescriptlang.org/docs/handbook/tsconfig-json.html#types-typeroots-and-types" target="_blank" rel="noopener">&quot;types&quot; 选项</a> 指定一个空文件即可。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/tsconfig.json</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"compilerOptions"</span>: &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不要自动包含所有东西</span></span><br><span class="line">        <span class="comment">// 仅包含我们需要导入的 `@types` 包</span></span><br><span class="line">        <span class="attr">"types"</span>: []</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"files"</span>: [<span class="string">"foo.ts"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你仍然需要一些全局包，可以将它们添加到 <code>types</code> 字段中。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  tests/tsconfig.json</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"compilerOptions"</span>: &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 仅包含 `@types/node` 和 `@types/mocha`</span></span><br><span class="line">        <span class="attr">"types"</span>: [<span class="string">"node"</span>, <span class="string">"mocha"</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"files"</span>: [<span class="string">"foo.test.ts"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="增量编译"><a class="markdownIt-Anchor" href="#增量编译"></a> 增量编译</h2><p><code>--incremental</code> 标志允许 TypeScript 将最后一次编译的结果存储在 <code>.tsbuildinfo</code> 文件内。这个文件是用来找出那些可能被重新检查/提交的最小文件集合，很像 <code>--watch</code> 模式的工作方式。</p><p>当使用 Composite 标志作为项目引用时，增量编译是默认打开的。但是对于选择加入的任何项目，都可以带来相同的加速。</p><h2 id="跳过-dts-检查"><a class="markdownIt-Anchor" href="#跳过-dts-检查"></a> 跳过 <code>.d.ts</code> 检查</h2><p>默认情况下，TypeScript 会整个儿的检查项目里的 <code>.d.ts</code> 文件，从而找出问题和冲突。然而，这往往完全没有必要。大多数时候，<code>.d.ts</code> 文件已经正常工作了——类型相互扩展的方式已经被验证过一次了，而重要的声明都会被检查一遍。</p><p>TypeScript 提供使用 <code>skipDefaultLibCheck</code> 标志跳过其附带的 <code>.d.ts</code> 文件（例如 lib.d.ts）的类型检查的选项。</p><p>同时，你也可以激活 <code>skipLibCheck</code> 标志在编译阶段跳过所有 <code>.d.ts</code> 文件的检查。</p><p>这两个选项都经常会导致 <code>.d.ts</code> 文件的冲突，所以我们仅建议你在需要 <em>更快</em> 的构建速度时使用。</p><h2 id="使用更快的变化检查"><a class="markdownIt-Anchor" href="#使用更快的变化检查"></a> 使用更快的变化检查</h2><p>狗属于动物类吗？换句话说，<code>List&lt;Dog&gt;</code> 属于 <code>List&lt;Animals&gt;</code> 吗？最简单的比较方法是依次比较这两种类型的成员。不幸的是，这通常会有很大的性能问题。然而，如果我们对 <code>List&lt;T&gt;</code> 知道的足够多的话，就可以在削减一部分检查的情况下，判断二者的类型是否相符（例如不用比较 <code>List&lt;T&gt;</code> 的每一个成员）（特别的，我们需要知道类型参数 <code>T</code> 的 <a href="https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)" target="_blank" rel="noopener">variance</a>）。如果启用 <code>strictFunctionTypes</code> 标志，编译器就可以充分的利用此潜在的加速功能（否则，它就会使用较慢但更加宽松的结构检查）。因此，我们建议使用 <code>--strictFunctionTypes</code> 构建（默认情况下在 <code>--strict</code> 下启用）。</p><h1 id="配置其他构建工具"><a class="markdownIt-Anchor" href="#配置其他构建工具"></a> 配置其他构建工具</h1>]]></content>
      
      
      <categories>
          
          <category> 翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
            <tag> performance </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue3 源码阅读笔记（六）—— nextTick 与调度器</title>
      <link href="/2021/01/22/vue3source6/"/>
      <url>/2021/01/22/vue3source6/</url>
      
        <content type="html"><![CDATA[<h1 id="简述"><a class="markdownIt-Anchor" href="#简述"></a> 简述</h1><p>尽管我们可以从逻辑上简单的将 <code>Vue</code> 的实现拆分为：响应式系统和渲染器。因为现代前端框架所关注的问题就是如何同步 <code>state</code> 与 <code>UI</code>。</p><p>但在实际工程中，<code>UI</code> 的渲染并不是一次性的。根据数据的变化，它是会随之不断变化的。从理论上来说，我们可以对数据的变化应收尽收。也就是说，只要 <code>state</code> 发生了变化，我们就去更新 <code>UI</code>。这种<s>罗永浩式</s>不管不顾的做法尽管也不是不能用，但却会大大降低渲染更新的速度。所以我们就需要一种机制，来控制渲染。</p><p>任何逻辑只要足够通用、足够复杂，就有价值抽象出来单独研究。</p><p>另外的，调度器与调度策略是一个很复杂的问题。在操作系统设计中，你可能看到过很多精妙的设计与研究。这里我们并不打算过于深入这个主题，而是恰到好处的阐述，来完成我们的工程目标。</p><a id="more"></a><h1 id="event-loop"><a class="markdownIt-Anchor" href="#event-loop"></a> Event Loop</h1><p>关于这个主题，在<a href="https://www.bebopser.com/2021/01/13/browserEventLoop/">浏览器与 Event Loop </a>这篇文章中已经详细阐述过了，我们这里稍微阐述一下如何借由这个概念实现调度器的核心。</p><p>关于浏览器的设计，你可以参考这幅图：</p><p><img src="https://bebopfzj.oss-cn-hangzhou.aliyuncs.com/uPic/2021-01-13-PYoP5C.png" alt="JavaScript 运行时" /></p><p>简单来说，<code>JavaScript</code> 是一种单线程语言。浏览器为了实现异步任务，设计了 <code>Event Loop</code> 这个机制。在执行主执行栈的任务时，异步任务会被放入 <code>Task Queue</code> 中。当然，异步任务根据具体情况，会分别加入 <code>Macro Task Queue</code> 与 <code>Micro Task Queue</code> 中。待主执行栈的任务清空后，就会依次执行 <code>Task Queue</code> 中的任务。</p><p>由此，调度器的实现就呼之欲出了。<br />我们只要实现一种机制，将需要异步执行的任务塞入 <code>Task Queue</code> 中就可以了。简单来说，就是借助 <code>Promise</code> 或 <code>setTimeout</code> 等。尽管他们二者一个属于 <code>Micro Task</code>，一个属于 <code>Macro Task</code>。但在这个主题下，他们从逻辑上讲是一致的。</p><h1 id="nexttick"><a class="markdownIt-Anchor" href="#nexttick"></a> nextTick</h1><p>在这里我们引述一下<a href="https://v3.vuejs.org/api/global-api.html#nexttick" target="_blank" rel="noopener">官方文档</a></p><blockquote><p>Defer the callback to be executed after the next DOM update cycle. Use it immediately after you’ve changed some data to wait for the DOM update.</p></blockquote><p>借由前面的分析，你应该很容易想到 <code>nextTick</code> 函数的实现方式。源码如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">nextTick</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">this</span>: ComponentPublicInstance | <span class="built_in">void</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  fn?: () =&gt; <span class="built_in">void</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Promise</span>&lt;<span class="title">void</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> p = currentFlushPromise || resolvedPromise</span><br><span class="line">  <span class="keyword">return</span> fn ? p.then(<span class="keyword">this</span> ? fn.bind(<span class="keyword">this</span>) : fn) : p</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这其中涉及到了一些 <code>Vue</code> 调度器本身的设计，我们将在稍候分析。为了让你更容易理解，我们可以把代码改成这样：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.resolve()</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">nextTick</span>(<span class="params">fn?: () =&gt; <span class="built_in">void</span></span>): <span class="title">Promise</span>&lt;<span class="title">void</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fn ? p.then(fn): p</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说白了，就是借助 <code>Promise.resolve().then()</code> 将 <code>() =&gt; void</code> 这个任务推入 <code>Task Queue</code> 来执行。<br /><code>UI</code> 的渲染将会在主执行栈执行，待渲染完毕，就会运行 <code>Task Queue</code> 中的任务，我们也就可以拿到更新后的 <code>DOM</code> 了。</p><h1 id="调度器的设计"><a class="markdownIt-Anchor" href="#调度器的设计"></a> 调度器的设计</h1><p>上一部分的 <code>nextTick</code> 是 <code>Vue</code> 暴露出来的 <code>api</code>，所以重点说了一下。不过光知道这个还不足以理解 <code>Vue</code> 中渲染调度器的整体设计。下面我们就结合源码讨论一下这部分的设计。</p><h2 id="数据结构"><a class="markdownIt-Anchor" href="#数据结构"></a> 数据结构</h2><p>搞清楚系统操作的数据结构是理解系统的第一步，所以我们先来讨论一下调度器操作的数据结构。</p><p>首先是被调度的任务。<code>Vue</code> 将任务做了简单的封装：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> SchedulerJob &#123;</span><br><span class="line">    (): <span class="built_in">void</span></span><br><span class="line">    id?: <span class="built_in">number</span></span><br><span class="line">    allowRecurse?: <span class="built_in">boolean</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>(): void</code> 是 <code>TypeScript</code> 的一个简写语法，指代的是一个函数类型。<code>id</code> 的作用是使得任务保持唯一性。<code>allowRecurse</code> 作用是指示任务是否可以递归的调用自身。</p><p>接下来是需要调度的任务队列，是一个数组：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> queue: SchedulerJob[] = []</span><br></pre></td></tr></table></figure><p>另外的，对于异步任务的回调函数，调度器也做了处理。首先看一下回调函数的数据结构：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> SchedulerCb = <span class="built_in">Function</span> &amp; &#123; id?: <span class="built_in">number</span> &#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> SchedulerCbs = SchedulerCb | SchedulerCb[]</span><br></pre></td></tr></table></figure><p>接着是两类四种回调函数的数据结构：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 异步任务队列中任务执行前的回调函数队列</span></span><br><span class="line"><span class="keyword">const</span> pendingPreFlushCbs: SchedulerCb[] = []</span><br><span class="line"><span class="keyword">let</span> activePreFlushCbs: SchedulerCb[] | <span class="literal">null</span> = <span class="literal">null</span></span><br><span class="line"><span class="keyword">let</span> preFlushIndex = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步任务队列中任务执行完成后的回调函数队列</span></span><br><span class="line"><span class="keyword">const</span> pendingPostFlushCbs: SchedulerCb[] = []</span><br><span class="line"><span class="keyword">let</span> activePostFlushCbs: SchedulerCb[] | <span class="literal">null</span> = <span class="literal">null</span></span><br><span class="line"><span class="keyword">let</span> postFlushIndex = <span class="number">0</span></span><br></pre></td></tr></table></figure><p>综上所述，整个调度器的核心就是 <code>queue</code> 这种数据结构。我们通过维护一个队列，从而实现对渲染的控制。同时在入队出队的时候，我们都可以精确的控制代码的行为，从而实现一些逻辑。比如任务的去重。<br />例如，考虑如下的例子：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; reactive, watch &#125; <span class="keyword">from</span> <span class="string">'vue'</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> state = reactive(&#123; count: <span class="number">0</span> &#125;) </span><br><span class="line">watch(<span class="function"><span class="params">()</span> =&gt;</span> state.count, <span class="function">(<span class="params">count, prevCount</span>) =&gt;</span> &#123; </span><br><span class="line">  <span class="built_in">console</span>.log(count) </span><br><span class="line">&#125;) </span><br><span class="line"></span><br><span class="line">state.count++ </span><br><span class="line">state.count++ </span><br><span class="line">state.count++</span><br></pre></td></tr></table></figure><p>如果你自己折腾过 <code>Vue</code> 的 <code>watch</code>，那么你会知道，这段代码仅仅会输出一次内容，也就是最终计算的结果：3。</p><h2 id="任务入队"><a class="markdownIt-Anchor" href="#任务入队"></a> 任务入队</h2><h3 id="queuejob-入队异步任务"><a class="markdownIt-Anchor" href="#queuejob-入队异步任务"></a> queueJob 入队异步任务</h3><p>整个系统的核心就是这个函数，它会将异步任务添加进队列中。下面看一下简化后的源码：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">queueJob</span>(<span class="params">job: SchedulerJob</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!queue.includes(job)) &#123;</span><br><span class="line">        queue.push(job)</span><br><span class="line">        queueFlush()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在确保无重复后，将任务推入队列。</p><p>当然了，上面简化的代码只能说明本质。如果想要了解调度器的设计，还是需要看完整源码，提供了一些额外的信息。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((!queue.length || !queue.includes(</span><br><span class="line">    job, </span><br><span class="line">    isFlushing &amp;&amp; job.allowRecurse ? flushIndex + <span class="number">1</span> : flushIndex))</span><br><span class="line">    &amp;&amp; job !== currentPreFlushParentJob) &#123;</span><br><span class="line">        queue.push(job)</span><br><span class="line">        queueFlush()</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>简单来说，在默认情况下，搜索的起始位置为当前任务。也就是说，不允许递归调用。<br />当 <code>job.allowRecurse</code> 的值为 <code>true</code> 时，将搜索起始位置加一，无法搜索到自身，也就是允许递归调用了。</p><h3 id="queuepreflushcb-queuepostflushcb-处理回调"><a class="markdownIt-Anchor" href="#queuepreflushcb-queuepostflushcb-处理回调"></a> queuePreFlushCb / queuePostFlushCb 处理回调</h3><p>那么，回调任务怎么处理呢？这里我们有两组函数来分别处理异步任务调用前和回调和异步任务调用完成后的回调。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">queuePreFlushCb</span>(<span class="params">cb: SchedulerCb</span>) </span>&#123;</span><br><span class="line">    queueCb(cb, activePreFlushCbs, pendingPreFlushCbs, preFlushIndex)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">queuePostFlushCb</span>(<span class="params">cb: SchedulerCbs</span>) </span>&#123;</span><br><span class="line">    queueCb(cb, activePostFlushCbs, pendingPostFlushCbs, postFlushIndex)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这两个函数实际上是对 <code>queueCb</code> 的封装。它们之间的区别仅有传递进去的参数的不同。下面我们来看一下 <code>queueCb</code> 这个函数：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">queueCb</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    cb: SchedulerCbs,</span></span></span><br><span class="line"><span class="function"><span class="params">    activeQueue: SchedulerCb[] | <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    pendingQueue: SchedulerCb[],</span></span></span><br><span class="line"><span class="function"><span class="params">    index: <span class="built_in">number</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isArray(cb)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">            !activeQueue ||</span><br><span class="line">            !activeQueue.includes(</span><br><span class="line">                cb,</span><br><span class="line">                (cb <span class="keyword">as</span> SchedulerJob).allowRecurse ? index + <span class="number">1</span> : index</span><br><span class="line">            )</span><br><span class="line">        ) &#123;</span><br><span class="line">            pendingQueue.push(cb)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pendingQueue.push(...cb)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    queueFlush()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>入队的逻辑和异步任务的处理基本上是一致的。一方面做了去重，另一方面依照配置处理了递归的逻辑。<br />另外的，如果回调是一个数组，它会是组件的生命周期钩子函数。这组函数仅可被异步任务调用，且已经完成去重了。所以这里直接将数组拉平为一维，推入 <code>pendingQueue</code> 中。这部分是 <code>Vue</code> 自身的设计。<br />你也可以参考一下源码中的原有注释：</p><blockquote><p>if cb is an array, it is a component lifecycle hook which can only be triggered by a job, which is already deduped in the main queue, so we can skip deplicate check here to improve pref</p></blockquote><h2 id="任务处理"><a class="markdownIt-Anchor" href="#任务处理"></a> 任务处理</h2><h3 id="queueflush-推入微任务队列"><a class="markdownIt-Anchor" href="#queueflush-推入微任务队列"></a> queueFlush 推入微任务队列</h3><p>入队完成后，我们纠结着需要开始处理异步任务了。我们先来看两个全局变量，它们控制着刷新逻辑：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> isFlushing = <span class="literal">false</span></span><br><span class="line"><span class="keyword">let</span> isFlushPending = <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>在这里，如果没有正在等待或正在执行的任务，我们就会将 <code>flushJobs</code> 塞入引擎的微任务队列：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> resolvedPromise: <span class="built_in">Promise</span>&lt;<span class="built_in">any</span>&gt; = <span class="built_in">Promise</span>.resolve()</span><br><span class="line"><span class="keyword">let</span> currentFlushPromise: <span class="built_in">Promise</span>&lt;<span class="built_in">void</span>&gt; | <span class="literal">null</span> = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">queueFlush</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isFlushing &amp;&amp; !isFlushPending) &#123;</span><br><span class="line">        isFlushPending = <span class="literal">true</span></span><br><span class="line">        currentFlushPromise = resolvedPromise.then(flushJobs)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这样的设计，确保了你可以在一个 <code>tick</code> 内可以多次添加任务。同时引擎在执行完主调用栈的函数后，一定会调用一次微任务队列中的 <code>flushJobs</code>。</p><h3 id="flushjobs-处理异步任务"><a class="markdownIt-Anchor" href="#flushjobs-处理异步任务"></a> flushJobs 处理异步任务</h3><p>当引擎处理完主函数栈的函数时，就会去处理 <code>Task Queue</code> 中的内容。我们之前通过这一句代码，将 <code>flushJobs</code> 推入了 <code>Task Queue</code>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> resolvedPromise: <span class="built_in">Promise</span>&lt;<span class="built_in">any</span>&gt; = <span class="built_in">Promise</span>.resolve()</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">queueFlush</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    resolvedPromise.then(flushJobs)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，在适当的时机，就会调用 <code>flushJobs</code>。</p><p>因为这个函数内容比较多，所以我们采用删减源码的方式，一步步的分析其实现逻辑。<br />首先看一下回调的处理时机：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> CountMap = Map&lt;SchedulerJob | SchedulerCb, <span class="built_in">number</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flushJobs</span>(<span class="params">seen?: CountMap</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    flushPreFlushCbs(seen)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理异步任务</span></span><br><span class="line"></span><br><span class="line">    flushPostFlushCbs(seen)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事实上就是通过这两个函数，分别执行回调函数队列的。不过这部分逻辑我们留到下一个章节再说。</p><p>另外的，在实际处理异步任务队列前，我们还需要对任务队列做一次排序。看一下源码：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> queue: SchedulerJob[] = []</span><br><span class="line"><span class="keyword">const</span> getId = <span class="function">(<span class="params">job: SchedulerJob | SchedulerCb</span>) =&gt;</span></span><br><span class="line">    job.id == <span class="literal">null</span> ? <span class="literal">Infinity</span> : job.id</span><br><span class="line"></span><br><span class="line">queue.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> getId(a) - getId(b))</span><br></pre></td></tr></table></figure><p>这里会将 <code>queue</code> 中的内容按照其 <code>id</code> 值升序排列。这么做的原因，源码中的注释已经说得很清楚了：</p><blockquote><p>Sort queue before flush.<br />This ensures that:</p><ol><li>Components are updated from parent to child. (because parent is always created before the child so its render effect will have smaller priority number)</li><li>If a component is unmounted during a parent component’s update, its update can be skipped.</li></ol></blockquote><p>总结一下，主要是确保了两点：</p><ul><li>由父组件至子组件的更新</li><li>如果在父组件更新的时候子组件被卸载了，那么就可以跳过子组件的更新了</li></ul><p>说完了细节部分，接下来我们来看一下完整版的代码。其中一些类型在前面的代码中已经写过了，此处不再赘述。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flushJobs</span>(<span class="params">seen?: CountMap</span>) </span>&#123;</span><br><span class="line">    isFlushPending = <span class="literal">false</span></span><br><span class="line">    isFlushing = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">        seen = seen || <span class="keyword">new</span> Map()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    flushPreFlushCbs(seen)</span><br><span class="line">    queue.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> getId(a) - getId(b))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (flushIndex = <span class="number">0</span>; flushIndex &lt; queue.length; flushIndex++) &#123;</span><br><span class="line">            <span class="keyword">const</span> job = queue[flushIndex]</span><br><span class="line">            <span class="keyword">if</span> (job) &#123;</span><br><span class="line">                <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">                    checkRecursiveUpdates(seen!, job)</span><br><span class="line">                &#125;</span><br><span class="line">                callWithErrorHandling(job, <span class="literal">null</span>, ErrorCodes.SCHEDULER)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        flushIndex = <span class="number">0</span></span><br><span class="line">        queue.length = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        flushPostFlushCbs(seen)</span><br><span class="line"></span><br><span class="line">        isFlushing = <span class="literal">false</span></span><br><span class="line">        currentFlushPromise = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (queue.length || pendingPostFlushCbs.length) &#123;</span><br><span class="line">            flushJobs(seen)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码看起来比较长，但逻辑其实很简单，浓缩一下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (flushIndex = <span class="number">0</span>; flushIndex &lt; queue.length; flushIndex++) &#123;</span><br><span class="line">    callWithErrorHandling(job, <span class="literal">null</span>, ErrorCodes.SCHEDULER)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遍历队列，并执行这些任务。</p><p>另外的，你应该会注意到这句代码：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (queue.length || pendingPostFlushCbs.length) &#123;</span><br><span class="line">    flushJobs(seen)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有些异步任务在执行的时候也会添加新的异步任务进去，那么我们就将它们也执行完。</p><h3 id="处理回调任务"><a class="markdownIt-Anchor" href="#处理回调任务"></a> 处理回调任务</h3><p>关于回调任务，根据上面的解释，存在两种处理逻辑。分别是用于处理异步任务前时的回调，和异步任务处理完成后的回调。下面我们分别来讨论一下。</p><h4 id="flushpreflushcbs"><a class="markdownIt-Anchor" href="#flushpreflushcbs"></a> flushPreFlushCbs</h4><p>概括的来说，处理回调队列的思路和处理异步任务队列的思路是一致的。遍历队列，依次执行函数。同时递归的处理回调本身的递归。<br />因为代码虽然长，但逻辑不复杂，所以直接来看一下源码：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pendingPreFlushCbs: SchedulerCb[] = []</span><br><span class="line"><span class="keyword">let</span> activePreFlushCbs: SchedulerCb[] | <span class="literal">null</span> = <span class="literal">null</span></span><br><span class="line"><span class="keyword">let</span> currentPreFlushParentJob: SchedulerJob | <span class="literal">null</span> = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">flushPreFlushCbs</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    seen?: CountMap,</span></span></span><br><span class="line"><span class="function"><span class="params">    parentJob: SchedulerJob | <span class="literal">null</span> = <span class="literal">null</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pendingPreFlushCbs.length) &#123;</span><br><span class="line">        currentPreFlushParentJob = parentJob</span><br><span class="line">        activePreFlushCbs = [...new Set(pendingPreFlushCbs)]</span><br><span class="line">        pendingPreFlushCbs.length = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (</span><br><span class="line">            preFlushIndex = <span class="number">0</span>;</span><br><span class="line">            preFlushIndex &lt; activePreFlushCbs.length;</span><br><span class="line">            preFlushIndex++</span><br><span class="line">        ) &#123;</span><br><span class="line">            activePreFlushCbs[preFlushIndex]()</span><br><span class="line">        &#125;</span><br><span class="line">        activePreFlushCbs = <span class="literal">null</span></span><br><span class="line">        preFlushIndex = <span class="number">0</span></span><br><span class="line">        currentPreFlushParentJob = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">        flushPreFlushCbs(seen, parentJob)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逻辑很清楚，就是遍历 <code>activePreFlushCbs</code> 队列，依次执行函数。<br />注意最后递归调用了 <code>flushPreFlushCbs</code> 函数，用来处理递归。在递归的过程中，可能会改变队列，所以我们在正式处理前，拷贝了一份队列的副本：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">activePreFlushCbs = [...new Set(pendingPreFlushCbs)]</span><br></pre></td></tr></table></figure><h4 id="flushpostflushcbs"><a class="markdownIt-Anchor" href="#flushpostflushcbs"></a> flushPostFlushCbs</h4><p>其实整体上的处理逻辑和前者是一致的。其中修复了 <a href="https://github.com/vuejs/vue-next/issues/1947" target="_blank" rel="noopener">#1947</a> 这个 <code>issue</code> 的问题。如果你感兴趣，可以去读一下原 <code>issue</code>。这里为了展示核心逻辑与前者比较，就省略了这部分逻辑。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">flushPostFlushCbs</span>(<span class="params">seen?: CountMap</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pendingPostFlushCbs.length) &#123;</span><br><span class="line">        <span class="keyword">const</span> deduped = [...new Set(pendingPostFlushCbs)]</span><br><span class="line">        pendingPostFlushCbs.length = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        activePostFlushCbs = deduped</span><br><span class="line"></span><br><span class="line">        activePostFlushCBs.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> getId(a) - getId(b))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (</span><br><span class="line">            postFlushIndex = <span class="number">0</span>;</span><br><span class="line">            postFlushIndex &lt; activePostFlushCbs.length;</span><br><span class="line">            postFlushIndex++</span><br><span class="line">        ) &#123;</span><br><span class="line">            activePostFlushCbs[postFlushIndex]()</span><br><span class="line">        &#125;</span><br><span class="line">        activePostFlushCbs = <span class="literal">null</span></span><br><span class="line">        postFlushIndex = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的，这里在处理前也拷贝了队列的副本。就是为了处理新添加的回调。</p><p>另外的，在 <code>flushJob</code> 函数调用 <code>flushPostFlushCbs</code> 函数后，还将 <code>isFlushing</code> 重置为了 <code>false</code>。这是为了处理新添加的异步任务。如果有的话，<code>flushJob</code> 会继续递归，直到处理完所有的异步任务。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flushPostFlushCbs(seen)</span><br><span class="line">isFlushing = <span class="literal">false</span></span><br></pre></td></tr></table></figure><h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1><p>至此，就是 <code>Vue3</code> 中调度器的所有内容了。总的来说，整体思想涉及了两个部分：</p><ul><li>借助引擎的 <code>Micro Task Queue</code> 处理调度器存储的任务</li><li>处理异步任务与回调，对于新添加的异步任务也递归的处理完成。这与引擎处理 <code>Task Queue</code> 的逻辑是一致的</li></ul>]]></content>
      
      
      <categories>
          
          <category> 源码阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> event loop </tag>
            
            <tag> promise </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器与 Event Loop</title>
      <link href="/2021/01/13/browserEventLoop/"/>
      <url>/2021/01/13/browserEventLoop/</url>
      
        <content type="html"><![CDATA[<h1 id="引子"><a class="markdownIt-Anchor" href="#引子"></a> 引子</h1><p>如果你使用 <code>JavaScript</code> 或 <code>TypeScript</code> 开发，那你就不能不去了解运行它们的环境。我们可以笼统的将运行环境区分为浏览器和 <code>Node.js</code>。在这篇文章，我们的讨论范围仅限于浏览器中。</p><p>一个在展开讨论前的必要信息是：<code>JavaScript</code> 是一个单线程语言。这意味着在任何时候，都只能有一个主线程来处理任务。事实上这个设计不能怪 Brendan Eich，<code>JavaScript</code> 语言的设计者。他当年捣鼓这个东西的时候，也没有想到互联网能发展成今天这个样子。</p><p>如果我们考虑单线程这件事，我们会意识到，这个设计会带来灾难性的后果。比如用户在网站上发起了一个网络请求，这个网络请求所需要的时间可能长达几秒，在这期间，整个网站的渲染线程是被挂起的，从用户的角度来看，网站就像卡住了。这种浏览体验可能是所有用户都不愿意见到的。</p><p>说到这，你可能会想：不对啊，我平常上网怎么没遇到过这种情况？的确没有，这就要归功于 <code>Event Loop</code> 了。<br />简单来说，<code>Event Loop</code> 这个设计，使得浏览器可以将 <code>JavaScript</code> 代码中 <strong>同步</strong> 和 <strong>异步</strong> 任务区分开。这种设计是有重大意义的。这使得浏览器可以在处理诸如网络请求这种高延时工作的时候，依然可以为用户提供流畅的渲染体验。</p><a id="more"></a><h1 id="消息队列"><a class="markdownIt-Anchor" href="#消息队列"></a> 消息队列</h1><p>在谈论 <code>Event Loop</code> 的具体内容之前，我想先谈论一下 <code>Message Queue</code> 这个主题。为什么要谈论这个看起来毫不相关的主题？这是因为 <code>Event Loop</code> 的设计思想和 <code>Message Queue</code> 是一致的。</p><p>在生活中，我们会遇到很多事情。这些事情并不是都需要立刻处理的，而是具有优先级关系的。而在计算机的处理中，这种思想也指导我们必须将各种任务区分开，按照不同的优先级处理。</p><p>具体到浏览器中，一些诸如渲染等工作，必须是要立刻处理的。按照术语来说，就是所谓的 <strong>同步</strong> 任务。当用户点击按钮后，他当然想立即看到反馈。在大多数时候，我们会呈现一个按钮被按下的动画，告诉用户，你的确是按下了这个按钮。而另外的一些工作，比如网络请求，就不一定要立即呈现结果了。网络速度经常是一个很玄学的事情，我们可以保证服务器的反应速度，但却无法控制用户端的网速。所以如果在发出网络请求后，整个浏览器都卡在那里等待请求的返回结果，用户显然不买账。所以我们可以将其区分为 <strong>异步</strong> 任务，进行特殊处理。</p><p><code>消息队列</code> 实际上就是这种思想的具体实现。直白点说，<code>消息队列</code> 实际上就是一个 <code>TODO 清单</code>。我们将一些耗时短、立即处理的任务，放在主线程处理。而将一些耗时长、需要等待结果的任务放在这份 <code>TODO 清单</code> 中，等到有结果时再处理。</p><p>那么，我们如何去处理那些被等待的任务？答案就是——<code>回调函数</code>。当异步任务等待完成时，浏览器可以去调用这些回调函数，从而完成对异步任务的整体处理。</p><h1 id="javascript-引擎的设计"><a class="markdownIt-Anchor" href="#javascript-引擎的设计"></a> JavaScript 引擎的设计</h1><p>我们使用如下这张图来展示整个 <code>JavaScript</code> 引擎的设计，这幅图参考了 <a href="https://www.youtube.com/watch?v=8aGhZQkoFbQ" target="_blank" rel="noopener">JSConf 2014</a> 上的演讲。你可以去看一下这个视频，它对 <code>Event Loop</code> 做了非常清晰的解释，除了没有提到 <code>micro task</code> 这个主题。</p><p><img src="https://bebopfzj.oss-cn-hangzhou.aliyuncs.com/uPic/2021-01-13-PYoP5C.png" alt="JavaScript 运行时" /></p><p>引擎会将变量存储在 <code>heap</code> 中。而当代码执行时，引擎会根据方法的调用，生成与其对应的 <code>context</code>。这个上下文中存储着一些方法执行所需要的信息，比如参数变量、上层作用域、this 对象等。同时，方法会被压入执行栈，即图中的 <code>stack</code> 中。方法自执行栈顶部开始执行。若方法调用了新的方法，那么就将那个新方法压入执行栈。若方法执行完毕，那么就将其弹出执行栈。</p><blockquote><p>在实际代码中，引擎会根据变量的不同类型，将其存储于 <code>stack</code> 或 <code>heap</code> 的数据结构中。但这部分不是我们讨论的主题。</p></blockquote><p>那么，我们如何处理异步任务呢？很简单，我们会调用 <code>Webapis</code>，这些需要等待的任务将由浏览器进行管理。一旦任务完成，就将这些任务的回调函数推入 <code>Task Queue</code>。依据异步任务的不同，我们选择性的将其推入 <code>Task</code> 或是 <code>Micro Task</code> 队列。</p><p>具体来说，你可以这样区分它们：</p><ul><li>Task: setInterval()、setTimeout()</li><li>Micro Task: new Promise()、new MutaionObserver()</li></ul><p>当然了，这两个队列肯定不是为了好玩才取两个名字的，它们之间有执行逻辑的区别。<br />具体来说，当执行完某个宏任务且执行栈为空时，引擎会优先从 <code>Micro Task</code> 中取出一个任务执行，并直到执行完 <code>Micro Task</code> 队列中的所有任务。如果在执行某个微任务时，又加入了新的微任务，那么引擎也会尽职尽责的将队列里的所有 <code>Micro Task</code> 执行完。<br />如果完成了上面的工作，或是 <code>Micro Task</code> 中不存在任何待处理任务的话，引擎会去 <code>Task</code> 队列中取出一个任务，压入执行栈开始执行。</p><p>这个问题在 <a href="https://developer.mozilla.org/en-US/docs/Web/API/HTML_DOM_API/Microtask_guide/In_depth" target="_blank" rel="noopener">MDN Web Docs</a> 中也被阐述过：</p><p>The difference between the task queue and the microtask queue is simple but very important:</p><ul><li>When executing tasks from the task queue, the runtime executes each task that is in the queue at the moment a new iteration of the event loop begins. Tasks added to the queue after the iteration begins will not run until the next iteration.</li><li>Each time a task exits, and the execution context stack is empty, each microtask in the microtask queue is executed, one after another. The difference is that execution of microtasks continues until the queue is empty—even if new ones are scheduled in the interim. In other words, microtasks can enqueue new microtasks and those new microtasks will execute before the next task begins to run, and before the end of the current event loop iteration.</li></ul><h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1><p>总的来说，<code>Event Loop</code> 的实质就是一个消息队列管理。基于这个设计，<code>JavaScript</code> 这种单线程语言得到了无阻塞的能力。<br />其次，基于不同的异步任务，我们区分了 <code>Task</code> 与 <code>Micro Task</code> 两种回调队列。它们的调用策略也是不同的。</p><blockquote><p>也许在其他地方，<code>Task</code> 会被称为 <code>Macro Task</code>。</p></blockquote><h1 id="补充资料"><a class="markdownIt-Anchor" href="#补充资料"></a> 补充资料</h1><p>也许你可以读一下这些资料，以便加深理解。</p><ol><li><a href="https://www.youtube.com/watch?v=8aGhZQkoFbQ" target="_blank" rel="noopener">What is the event loop anyway? | Phillip Roberts | JSConf EU</a></li><li><a href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/" target="_blank" rel="noopener">Tasks, microtasks, queues and schedules</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/API/HTML_DOM_API/Microtask_guide/In_depth" target="_blank" rel="noopener">In depth: Microtasks and the JavaScript runtime environment</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 核心概念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> browser </tag>
            
            <tag> task </tag>
            
            <tag> micro task </tag>
            
            <tag> event loop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树的遍历</title>
      <link href="/2021/01/02/%E4%BA%8C%E5%8F%89%E6%A0%911/"/>
      <url>/2021/01/02/%E4%BA%8C%E5%8F%89%E6%A0%911/</url>
      
        <content type="html"><![CDATA[<h1 id="简述"><a class="markdownIt-Anchor" href="#简述"></a> 简述</h1><p>二叉树的遍历是解 leetcode 树类型题目的基础。搞清楚每一种遍历的细节和复杂度是解题的关键。<br />leetcode 上有很多相关的题目，但题解却经常只关注唯一的一道题。比如后序遍历就是利用稍微修改后的前序遍历倒置解出的，思路很巧妙，但是这种方法不具有普适性，无法解答其他与后序遍历相关的题目。<br />所以在这里完全总结一下二叉树遍历的问题，以便不仅仅可以写出题目，更重要的是在实际应用，比如模板解析中应用这些思路。<br />尽管对于二叉树来说，分为前中后序三种深度优先遍历和广度优先遍历四种。但实际上三种深度优先遍历不过是改变了访问子树根节点的时机，所以事实上可以认为是同一种遍历方式。</p><h1 id="beforeeach"><a class="markdownIt-Anchor" href="#beforeeach"></a> BeforeEach</h1><p>我们约定树节点的数据类型如下，后不再赘述：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, val=<span class="number">0</span>, left=None, right=None)</span>:</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br></pre></td></tr></table></figure><h1 id="前序遍历"><a class="markdownIt-Anchor" href="#前序遍历"></a> 前序遍历</h1><p>前序遍历是深度优先遍历，顺序是根节点 -&gt; 左子树 -&gt; 右子树。<br />所以你可以看到，这种方式是先处理子树根节点，再缓存左子树，最后处理右子树。</p><h2 id="递归"><a class="markdownIt-Anchor" href="#递归"></a> 递归</h2><p>对于树遍历的处理，天然的可以使用递归来处理。因为处理根和子树的逻辑是一样的，区别仅仅是我们需要根据不同的情况，来改变遍历（缓存）顺序。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span><span class="params">(root: TreeNode)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">visit</span><span class="params">(node)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node: <span class="keyword">return</span></span><br><span class="line">        res.append(node.val)</span><br><span class="line">        visit(node.left)</span><br><span class="line">        visit(node.right)</span><br><span class="line"></span><br><span class="line">    res = []</span><br><span class="line">    preorder(root)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>二叉树中的每一个节点都被访问了，所以时间复杂度为 O(n)<br />递归过程中有栈的空间开销，对于二叉树，平均空间复杂度为 O(logn)，最差情况下树呈现链状，空间复杂度为 O(n)</p><h1 id="迭代"><a class="markdownIt-Anchor" href="#迭代"></a> 迭代</h1><p>递归实质上是代码自身通过函数调用栈隐式的维护了待处理节点的栈。所以我们也可以自己维护这个栈。你可以直接使用 <code>list</code> 来模拟栈，不过 <code>collections</code> 模块有个 <code>deque</code> 实现了头尾添加删除相同的速度，所以你也可以使用这个模块。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span><span class="params">(root: TreeNode)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    stack = [root]</span><br><span class="line">    res = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> stack:</span><br><span class="line">        cur = stack.pop()</span><br><span class="line">        res.append(cur.val)</span><br><span class="line">        <span class="keyword">if</span> res.right:</span><br><span class="line">            stack.append(res.right)</span><br><span class="line">        <span class="keyword">if</span> res.left:</span><br><span class="line">            stack.append(res.left)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>你应该注意到了，我们在向栈内添加子树的时候，是先添加右子树，后添加左子树。这主要是因为模拟的栈和递归隐式处理的调用栈是不同的。<br />递归时，我们不仅可以处理当前节点，还能缓存未处理节点的所有信息，这个信息不仅仅包含其本身的数据，还有对其要做的操作。换句话说，递归时我们并不知道接下来的处理路线。<br />而迭代时，我们是实际上是要借用栈这个数据结构来模拟出一个树的节点遍历顺序。而处理的顺序是从栈顶弹出，所以我们这里先压入左子树，再压入右子树。换句话说，迭代时我们知道将要处理的节点清单。</p><p>更进一步的，为什么我们不能使用队列？<br />因为树的遍历有一个特点，就是在深度优先遍历中，我们不能遇到什么节点就处理好什么节点。换句话说，我们会缓存一些待处理的节点，而这些待处理节点的处理时机则是先遇到的后处理，即先进后出，符合栈的逻辑。</p><p>时间复杂度与空间复杂度的分析同递归。原因是我们在这里也是模拟的递归调用栈。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
            <tag> 递归 </tag>
            
            <tag> 迭代 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>好耶！是 BST</title>
      <link href="/2020/12/29/BST1/"/>
      <url>/2020/12/29/BST1/</url>
      
        <content type="html"><![CDATA[<h1 id="关于-bst"><a class="markdownIt-Anchor" href="#关于-bst"></a> 关于 BST</h1><p>BST 算是 leetcode 关于树的考察的一个重点了。不过这并不意味着它是一个可以广泛运用的数据结构。主要原因就在于其查找、插入、删除操作的时间复杂度均与树高度成正比，换句话说，就是 <code>O(logn)</code> 。这意味着在很多情况下，时间消耗都比较大。所以我们会转而使用平衡树。比如红黑树，B+，B-等等（不过这些还没学会，就不说了</p><p>回到 BST，它有一个重要的特性，就是：</p><ul><li>左低右高：若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值</li><li>左右子树也均为 BST</li></ul><p>这也就意味着，它中序遍历的结果是一个递增数列。</p><p>另外还有两个关于 BST 的概念。这两个概念是依附于 BST 本身的性质而提出的，并不是独立的概念。</p><ul><li>前驱节点(predecessor)：比当前节点小的最大节点</li><li>后继节点(successor)：比当前节点大的最小节点</li></ul><a id="more"></a><h1 id="bst-的前驱节点与后继节点"><a class="markdownIt-Anchor" href="#bst-的前驱节点与后继节点"></a> BST 的前驱节点与后继节点</h1><p>下面有两个不严谨的算法，用来求 BST 中某个节点的 <code>predecessor</code> 和 <code>successor</code>。</p><ul><li>predecessor 比当前节点小的最大节点</li><li>successor 比当前节点大的最小节点</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">predecessor</span><span class="params">(node)</span>:</span></span><br><span class="line">    node = node.left</span><br><span class="line">    <span class="keyword">while</span> node.right:</span><br><span class="line">        node = node.right</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">successor</span><span class="params">(node)</span>:</span></span><br><span class="line">    node = node.right</span><br><span class="line">    <span class="keyword">while</span> node.left:</span><br><span class="line">        node = node.left</span><br><span class="line">    <span class="keyword">return</span> node</span><br></pre></td></tr></table></figure><p>注意到我们直接取了 <code>node.left</code> 和 <code>node.right</code> 。但该节点的左右子树具体存在与否是不一定的，所以在调用函数前，需要判断左右子树的存在性。</p><h1 id="beforeeach"><a class="markdownIt-Anchor" href="#beforeeach"></a> BeforeEach</h1><p>预先对 BST 的数据类型做一下约定，后不赘述：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, val=<span class="number">0</span>, left=None, right=None)</span>:</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br></pre></td></tr></table></figure><h1 id="构建108-将有序数组转换为二叉搜索树"><a class="markdownIt-Anchor" href="#构建108-将有序数组转换为二叉搜索树"></a> 构建：108 将有序数组转换为二叉搜索树</h1><p>二叉搜索树的中序遍历是升序数组，这个特性无需赘述了。另外二叉树的中序遍历确实没啥好说的。<br />不过将一个升序数组转换为平衡二叉搜索树还是很有用的，可以大幅度提高查找、插入、删除的速度。所以就来说一下这道 leetcode 题目。</p><h2 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h2><p>将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。<br />本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。</p><h2 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h2><p>一个数组是中序遍历的结果，意味着如果我们找到了树的根节点，那么就可以根据这个根节点将数组一分为二。左半部分是左子树，右半部分是右子树。<br />对于一个数列，找一个数字当根节点是没啥限制的。但这道题要求是平衡二叉树。换句话说，我们必须从数列中间选数字，才能保证平衡。<br />而数列个数可能为奇数或偶数。当为奇数时，存在中位数。当为偶数时，不存在中位数，不过我们可以在中间俩数中随便选一个。<br />解法不一定是最好的。</p><h2 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sortedArrayToBST</span><span class="params">(nums: List[int])</span> -&gt; TreeNode:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> nums: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    idx = len(nums) // <span class="number">2</span></span><br><span class="line">    mid = nums[idx]</span><br><span class="line"></span><br><span class="line">    node = TreeNode(mid)</span><br><span class="line">    node.left = sortedArrayToBST(nums[:idx])</span><br><span class="line">    node.right = sortedArrayToBST(nums[idx+<span class="number">1</span>:])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> node</span><br></pre></td></tr></table></figure><p>注意到 <code>idx = len(nums) // 2</code> 这句代码，是整数除。你也可以选择右边的数字，都一样的。</p><h1 id="搜索700-二叉搜索树中的搜索"><a class="markdownIt-Anchor" href="#搜索700-二叉搜索树中的搜索"></a> 搜索：700 二叉搜索树中的搜索</h1><p>名字里就带着搜索，怎么能少了搜索呢？<br />事实上因为 BST 的<s>高低肩</s>左低右高的特性，我们在遍历树查找时，并不需要访问到所有的节点，而是根据当前节点的大小关系，找到一条直通目标数的路径即可。<br />更进一步的说，所花时间与树的高度成正比，即 O(logn)</p><h2 id="题目-2"><a class="markdownIt-Anchor" href="#题目-2"></a> 题目</h2><p>给定二叉搜索树（BST）的根节点和一个值。 你需要在 BST 中找到节点值等于给定值的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 NULL。</p><h2 id="分析-2"><a class="markdownIt-Anchor" href="#分析-2"></a> 分析</h2><p>既然是树，那么我们会先从根节点访问。根节点如果存在，且不是目标数的话，它和目标数就会有大小关系。<br />而 BST 左低右高，所以一个确定下一个访问的节点是左子树还是右子树。<br />如果访问到叶子节点，或者是不存在的节点了。还没有找到数，那就说明数根本就不存在，纯粹是在累傻小子。</p><h2 id="代码-2"><a class="markdownIt-Anchor" href="#代码-2"></a> 代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">searchBST</span><span class="params">(root: TreeNode, val: int)</span> -&gt; TreeNode:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root <span class="keyword">or</span> root.val == val:</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    <span class="keyword">return</span> searchBST(root.left, val) <span class="keyword">if</span> root.val &gt; val <span class="keyword">else</span> searchBST(root.right, val)</span><br></pre></td></tr></table></figure><p>逻辑非常简单，根据 <code>root.val</code> 与 <code>val</code> 的大小关系，选择前进的方向。<br />当节点不存在，或者找到节点了，那就返回这个子树。<br />注意访问到不存在的节点不一定是叶子节点。因为左低右高，如果你发现 <code>val</code> 比 <code>root.val</code> 小，但是当前 <code>root</code> 却没有左子树，也就是没有比它更小的节点了， 那么也就是找不到了。</p><h1 id="插入701-二叉搜索树中的插入操作"><a class="markdownIt-Anchor" href="#插入701-二叉搜索树中的插入操作"></a> 插入：701 二叉搜索树中的插入操作</h1><h2 id="题目-3"><a class="markdownIt-Anchor" href="#题目-3"></a> 题目</h2><p>给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 保证 ，新值和原始二叉搜索树中的任意节点值都不同。<br />注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 任意有效的结果 。</p><h2 id="分析-3"><a class="markdownIt-Anchor" href="#分析-3"></a> 分析</h2><p>注意到插入值与原 BST 中任意节点值都不一样。所以我们一定可以知道当前节点和要插入的值的大小关系。<br />也就是说，我们通过比较 <code>root.val</code> 和 <code>val</code> 的值，就可以知道应该往左子树走还是右子树走。</p><h2 id="代码-3"><a class="markdownIt-Anchor" href="#代码-3"></a> 代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insertIntoBST</span><span class="params">(root: TreeNode, val: int)</span> -&gt; TreeNode:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> TreeNode(val)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> root.val &lt; val:</span><br><span class="line">        root.right = insertIntoBST(root.right, val)</span><br><span class="line">    <span class="keyword">if</span> root.val &gt; val:</span><br><span class="line">        root.left = insertIntoBST(root.left, val)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p>当然了，你可以用迭代来写，但其实一样。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insertIntoBST</span><span class="params">(root: TreeNode, val: int)</span> -&gt; TreeNode:</span></span><br><span class="line">    node = TreeNode(val)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> node</span><br><span class="line"></span><br><span class="line">    cur = root</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">if</span> cur.val &lt; val:</span><br><span class="line">            <span class="keyword">if</span> cur.right:</span><br><span class="line">                cur = cur.right</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur.right = node</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> cur.val &gt; val:</span><br><span class="line">            <span class="keyword">if</span> cur.left:</span><br><span class="line">                cur = cur.left</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur.left = node</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p>迭代就是找了个指针来遍历 BST，其实跟遍历链表是一样的，只不过对于每个节点都有两种可能性。</p><h1 id="删除删除二叉搜索树中的节点"><a class="markdownIt-Anchor" href="#删除删除二叉搜索树中的节点"></a> 删除：删除二叉搜索树中的节点</h1><h2 id="题目-4"><a class="markdownIt-Anchor" href="#题目-4"></a> 题目</h2><p>给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。<br />一般来说，删除节点可分为两个步骤：<br />首先找到需要删除的节点；<br />如果找到了，删除它。<br />说明： 要求算法时间复杂度为 O(h)，h 为树的高度。</p><h2 id="分析-4"><a class="markdownIt-Anchor" href="#分析-4"></a> 分析</h2><p>如何找到要删除的节点？我们在之前讨论 BST 的搜索时就已经完整阐述过了。<br />删除节点很容易，只要将其变成 <code>None</code> 就行。但问题是，我们需要在删除节点后，还要保证新树依旧是 BST。<br />从另一个角度来看，BST 的中序遍历是递增数列，也就是说，我们要在递增数列中删除一个值，然后还得保证新数列是递增数列。<br />那么，我们如何删除一个数组中的数字？按照以下两步：</p><ol><li><p>我们有一个原始数组：<br />[1, 2, 3, 4, 5]</p></li><li><p>要删除 3，那么就用 4 覆盖 3：<br />[1, 2, 4, 4, 5]</p></li><li><p>删除冗余的 4<br />[1, 2, 4, 5]</p></li></ol><p>在有序数列中，找到比某一个数大或小的数很容易，但如何在 BST 中找？<br />答案就是利用 BST 左低右高的性质，寻找其前驱节点与后继节点。</p><h2 id="代码-4"><a class="markdownIt-Anchor" href="#代码-4"></a> 代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deleteNode</span><span class="params">(root: TreeNode, key: int)</span> -&gt; TreeNode:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">predecessor</span><span class="params">(node)</span>:</span></span><br><span class="line">        node = node.left</span><br><span class="line">        <span class="keyword">while</span> node.right:</span><br><span class="line">            node = node.right</span><br><span class="line">        <span class="keyword">return</span> node.val</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">successor</span><span class="params">(node)</span>:</span></span><br><span class="line">        node = node.right</span><br><span class="line">        <span class="keyword">while</span> node.left:</span><br><span class="line">            node = node.left</span><br><span class="line">        <span class="keyword">return</span> node.val</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">if</span> root.val &gt; key:</span><br><span class="line">        root.left = deleteNode(root.left, key)</span><br><span class="line">    <span class="keyword">elif</span> root.val &lt; key:</span><br><span class="line">        root.right = deleteNode(root.right, key)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">            root = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">elif</span> root.left:</span><br><span class="line">            root.val = predecessor(root)</span><br><span class="line">            root.left = deleteNode(root.left, root.val)</span><br><span class="line">        <span class="keyword">elif</span> root.right:</span><br><span class="line">            root.val = successor(root)</span><br><span class="line">            root.right = deleteNode(root.right, root.val)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p>主逻辑很简单，分为两层。</p><ul><li>第一层：找到要删除的节点</li><li>第二层：删除节点<ul><li>第一节：若是叶子节点，直接删除</li><li>第二节：若不是叶子节点，有左子树，用前驱节点覆盖，然后递归删除前驱节点</li><li>第三节：若不是叶子节点，有右子树，用后继节点覆盖，然后递归删除后继节点</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BST </tag>
            
            <tag> 中序遍历 </tag>
            
            <tag> 前驱节点 </tag>
            
            <tag> 后继节点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue3 源码阅读笔记（五）—— diff 算法解析</title>
      <link href="/2020/12/20/vue3source5/"/>
      <url>/2020/12/20/vue3source5/</url>
      
        <content type="html"><![CDATA[<h1 id="sketch"><a class="markdownIt-Anchor" href="#sketch"></a> Sketch</h1><p>If you have watched the <a href="https://www.youtube.com/watch?v=Vp5ANvd88x0&amp;t=48s&amp;ab_channel=VuejsAmsterdam" target="_blank" rel="noopener">Vue3 Live Release video</a>, you will know the Vue core team rewrote the diff algorithm.<br />The new diff algorithm refers to the <a href="https://github.com/localvoid/ivi" target="_blank" rel="noopener">ivi</a> and <a href="https://github.com/infernojs/inferno" target="_blank" rel="noopener">inferno</a>, whitch make virtual nodes diff quicker. You can visit <a href="https://krausest.github.io/js-framework-benchmark/current.html" target="_blank" rel="noopener">this test result</a> to check the accurate data.</p><p>As a whole, the algorithm can divide into three parts:</p><ul><li>patch the repetitive prefix &amp; suffix nodes</li><li>sync the old &amp; new virtual nodes lengths</li><li>diff subsequence of the same length</li></ul><p>Next, we will explain the algorithm with the source code of Vue3.</p><a id="more"></a><h1 id="prefix-suffix"><a class="markdownIt-Anchor" href="#prefix-suffix"></a> prefix &amp; suffix</h1><p>At first, we need to patch the repetitive prefix &amp; suffix virtual nodes. It is not strictly part of the algorithm, but it can avoid running the diff algorithm during some situations. This strategy can improve the program’s performance.</p><p>So, what is the <code>repetitive prefix &amp; suffix</code>? Suppose we have the following two texts:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">I want golden wind</span><br><span class="line">I want silver wind</span><br></pre></td></tr></table></figure><p>Look at these two texts, and we will find that each of these texts has the same piece of text at the head &amp; end. These texts are what we call <code>repetitive prefix &amp; suffix</code>. After we patched the repetitive part, we can only just diff the middle part which we call it <code>unknown subsequence</code>.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">golden</span><br><span class="line">silver</span><br></pre></td></tr></table></figure><p>In this example, the diff algorithm can just replace the words to complete the diff process. But it is not always such simple.</p><p>We can show this process through a figure.</p><p><img src="https://bebopfzj.oss-cn-hangzhou.aliyuncs.com/uPic/2020-12-20-7HeScz.png" alt="prefix &amp; suffix" /></p><ul><li>start: the last index of repetitive prefix nodes</li><li>prevEnd: the first index of previous virtual nodes’s repetitive suffix</li><li>nextEnd: the first index of next virtual nodes’s repetitive suffix</li></ul><p>The question is: Why just one index at left, but two indexes at right? <strong>Because the previous virtual nodes’ length is not always the same as the next virtual nodes</strong>.</p><p>Talk is cheap, show me the code. The following code is from Vue3, but I change some place to make it readable.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> start = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> prevEnd = prevChildren.length - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> nextEnd = nextChildren.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1. sync from start</span></span><br><span class="line"><span class="comment"> * (a b) c</span></span><br><span class="line"><span class="comment"> * (a b) d e</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">while</span> (start &lt;= prevEnd &amp;&amp; start &lt;= nextEnd) &#123;</span><br><span class="line">  <span class="keyword">const</span> prevVNode = prevChildren[start];</span><br><span class="line">  <span class="keyword">const</span> nextVNode = nextChildren[start];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isSameVNodeType(prevVNode, nextVNode)) &#123;</span><br><span class="line">    patch(prevVNode, nextVNode, container);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  start++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>As the code shows, we traverse both the old and new virtual nodes. In this process, we compare the old and new virtual node. If they are the same type, we invoke the <code>patch</code> function to handle them.<br />In Vue3, the <code>isSameVNodeType</code> function is:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">isSameVNodeType</span>(<span class="params">n1: VNode, n2: VNode</span>): <span class="title">boolean</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> n1.type === n2.type &amp;&amp; n1.key === n2.key</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Next, we need to handle repetitive suffix virtual nodes:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 2. sync from end</span></span><br><span class="line"><span class="comment"> * a (b c)</span></span><br><span class="line"><span class="comment"> * d e (b c)</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">while</span> (start &lt;= prevEnd &amp;&amp; start &lt;= nextEnd) &#123;</span><br><span class="line">  <span class="keyword">const</span> prevVNode = prevChildren[prevEnd];</span><br><span class="line">  <span class="keyword">const</span> nextVNode = nextChildren[nextEnd];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isSameVNodeType(prevVNode, nextVNode)) &#123;</span><br><span class="line">    patch(prevVNode, nextVNode, container);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  prevEnd--;</span><br><span class="line">  nextEnd--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The logic is similar to the previous code, but we start from the end of virtual nodes this time.</p><p>After the above process, we will get a pair of virtual nodes whose lengths are not necessarily equal. This means that we may need to add or remove virtual nodes.</p><h1 id="first-type-common-sequence-mount-unmount"><a class="markdownIt-Anchor" href="#first-type-common-sequence-mount-unmount"></a> First type: common sequence + mount / unmount</h1><p>Before we explain code, we need to research the shape of virtual nodes. The shape is formed by the head and tail lines of the old and new virtual node groups.</p><p>For example, suppose we have two sets of virtual nodes:</p><p><img src="https://bebopfzj.oss-cn-hangzhou.aliyuncs.com/uPic/2020-12-20-jvb3na.png" alt="real virtual nodes" /></p><p>The shape of these will like this:<br /><img src="https://bebopfzj.oss-cn-hangzhou.aliyuncs.com/uPic/2020-12-20-4jo5Ay.png" alt="virtual nodes shape" /></p><p>So, if we have a pair of virtual nodes which shape is like this. This means we need to mount nodes.<br /><img src="https://bebopfzj.oss-cn-hangzhou.aliyuncs.com/uPic/2020-12-20-9sGsQC.png" alt="mount nodes" /></p><p>Also, you need to pay attention to the current index which need to be within the prevEnd and nextEnd scope.<br />The following code is to mount new virtual nodes.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (start &gt; prevEnd) &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 3. common sequence + mount</span></span><br><span class="line"><span class="comment">   * (a b)</span></span><br><span class="line"><span class="comment">   * (a b) c</span></span><br><span class="line"><span class="comment">   * start = 2, prevEnd = 1, prevEnd = 2</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * (a b)</span></span><br><span class="line"><span class="comment">   * c (a b)</span></span><br><span class="line"><span class="comment">   * start = 0, prevEnd = -1, nextEnd = 0</span></span><br><span class="line"><span class="comment">   **/</span></span><br><span class="line">  <span class="keyword">if</span> (start &lt;= nextEnd) &#123;</span><br><span class="line">    <span class="comment">// fetch the real DOM node</span></span><br><span class="line">    <span class="keyword">const</span> ref = nextChildren?.[nextEnd + <span class="number">1</span>]?.elm;</span><br><span class="line">    <span class="keyword">while</span>(start &lt;= nextEnd) &#123;</span><br><span class="line">      mount(nextChildren[start], container, ref || <span class="literal">undefined</span>);</span><br><span class="line">      start++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Same logic, for this shape, you need to unmount nodes.<br /><img src="https://bebopfzj.oss-cn-hangzhou.aliyuncs.com/uPic/2020-12-20-9yKqOm.png" alt="unmount nodes" /></p><p>The code is like this:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 4. common sequence + unmount</span></span><br><span class="line"><span class="comment"> * (a b) c</span></span><br><span class="line"><span class="comment"> * (a b)</span></span><br><span class="line"><span class="comment"> * start = 2, prevEnd = 2, prevEnd = 1</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * c (a b)</span></span><br><span class="line"><span class="comment"> * (a b)</span></span><br><span class="line"><span class="comment"> * start = 0, prevEnd = 0, nextEnd = -1</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (start &gt; nextEnd) &#123;</span><br><span class="line">  <span class="keyword">while</span> (start &lt;= prevEnd) &#123;</span><br><span class="line">    unmount(prevChildren[start], container);</span><br><span class="line">    start++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="second-type-unknown-subsequence"><a class="markdownIt-Anchor" href="#second-type-unknown-subsequence"></a> Second type: unknown subsequence</h1><p>After the previous treatment, we will get an unknown subsequence. But before we start coding, we need to analyze the unknown subsequence.</p><p>Specifically, we need to deal with the following possible situations.</p><ul><li>unmount the node which does not exist in the new subsequence</li><li>mount new node</li><li>reorder the remaining node</li></ul><p>So, the <em>first question</em> is: How can I know the situation of the node?<br />We can iterate over the old node group and determine whether the node still exists in the new node group.<br />But if you have thought over this logic, you will find the most performance-consuming part is the determine process. If we use the traditional way, like iterate over new node group for every node from old node group and determine it, the complexity is going to be O(n^2). We certainly don’t accept that.<br />However, if we can determine the node quickly, there will be no problems with this scheme.<br />The solution is: Add unique key for each node, and determine node through hash table.<br />Why does this work? Because the hash table lookup is O(1), and determine the node’s key also be O(1). This improvement can greatly increase the speed of finding the same node.</p><p>The user passes in the node’s key, and we will store it in the <code>h</code> function, which generates a virtual node.</p><p>We can use a <code>Map</code> to store the key-index pair. The index is the index of the node in the old node group.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// the length of new or old virtual node group is not always the same</span></span><br><span class="line"><span class="keyword">const</span> prevStart = start;</span><br><span class="line"><span class="keyword">const</span> nextStart = start;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> keyToIndexMap: Map&lt;<span class="built_in">string</span> | <span class="built_in">number</span>, <span class="built_in">number</span>&gt; = <span class="keyword">new</span> Map();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = nextStart; i &lt;= nextEnd; i++) &#123;</span><br><span class="line">  keyToIndexMap.set(nextChildren[i].key, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Now, we need to loop through old node group left to be patched and try to patch matching nodes &amp; remove nodes that are no longer present.</p><p>But why should we loop through the old node group? This because all node move operations operate on the old node group, so this operation can minimize the number of moves.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> needPatch = nextEnd - nextStart + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> patched = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> moved = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">let</span> maxNewindexSoFar = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// works as Map&lt;newIndex, oldIndex&gt;</span></span><br><span class="line"><span class="comment">// 1. determin if the node need to unmount</span></span><br><span class="line"><span class="comment">// 2. determin longest stable subsequence for node movement</span></span><br><span class="line"><span class="keyword">const</span> newIndexToOldIndexMap = <span class="keyword">new</span> <span class="built_in">Array</span>(needPatch).fill(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = prevStart; i &lt;= prevEnd; i++) &#123;</span><br><span class="line">  <span class="keyword">const</span> prevVNode = prevChildren[i];</span><br><span class="line">  <span class="keyword">if</span> (patched &gt;= needPatch) &#123;</span><br><span class="line">    unmount(prevVNode, container);</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> newIndex;</span><br><span class="line">  <span class="keyword">if</span> (!!prevVNode.key) &#123;</span><br><span class="line">    newIndex = keyToIndexMap.get(prevVNode.key);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// handle key-less node</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = prevStart; j &lt;= prevEnd; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (newIndexToOldIndexMap[j - prevStart] &amp;&amp; isSameVNodeType(prevVNode, nextChildren[j])) &#123;</span><br><span class="line">        newIndex = j;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (newIndex) &#123;</span><br><span class="line">    newIndexToOldIndexMap[newIndex - nextStart] = i + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (newIndex &gt;= maxNewIndexSoFar) &#123;</span><br><span class="line">      maxNewIndexSoFar = newIndex;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      moved = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    patch(prevVNode, nextChildren[newIndex], container);</span><br><span class="line">    patched++;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    unmount(prevVNode, container);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The <em>second</em> question is: How do we deal with nodes which is in a different order?<br />Well, our goal is to minimize DOM movement. So, we need to find a way to extract information about the virtual node’s relative position.<br />Plus, if you read the code above, you’ll notice the <code>moved</code> variable. The variable’s type is <code>boolean</code>, which means if the node has moved. Specifically, if the newIndexToOldIndexMap’s value is increasing, that means the node has not moved, the other way around, it moves.<br />So, we need to find out how many nodes in the node group are not moving. The solution is: <strong>Longest Increasing Subsequence</strong>.</p><blockquote><p>In computer science, the <strong>Longest Increasing Subsequence</strong> problem is to find a subsequence of a given sequence in which the subsequence’s element are in sorted order, lowest to highest, and in which the subsequence is as long as possible.</p></blockquote><p>Why is it work? Because <strong>Longest Increasing Subsequence</strong>’s mathematical sense is: whether the node remains locally ordered. The problem is complicated, so I’ll treat it as a black box for now.</p><p>The code will be:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 3. common sequence + mount</span></span><br><span class="line"><span class="comment"> * (a b)</span></span><br><span class="line"><span class="comment"> * (a b) c</span></span><br><span class="line"><span class="comment"> * start = 2, prevEnd = 1, prevEnd = 2</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * (a b)</span></span><br><span class="line"><span class="comment"> * c (a b)</span></span><br><span class="line"><span class="comment"> * start = 0, prevEnd = -1, nextEnd = 0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// lis function will generate longest increasing subsequence</span></span><br><span class="line"><span class="keyword">const</span> seq = moved ? lis(newIndexToOldIndexMap) : [];</span><br><span class="line"><span class="keyword">let</span> remaining = seq.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = needPatch - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">  <span class="keyword">const</span> nextVNode = nextChildren[nextStart + i];</span><br><span class="line">  <span class="comment">// If the value is 0, that means this is a new node</span></span><br><span class="line">  <span class="keyword">if</span> (newIndexToOldIndexMap[i] === <span class="number">0</span>) &#123;</span><br><span class="line">    mount(nextVNode, container, nextChildren?.[nextStart + i + <span class="number">1</span>]?.elm || <span class="literal">undefined</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (moved) &#123;</span><br><span class="line">    <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> || i != seq[remaining]) &#123;</span><br><span class="line">      container.insertBefore(nextVNode.elm <span class="keyword">as</span> Node, nextChildren?.[i + nextStart + <span class="number">1</span>]?.elm || <span class="literal">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      remaining--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="conclusion"><a class="markdownIt-Anchor" href="#conclusion"></a> Conclusion</h1><p>In this article, we talk about diff algorithm in Vue3. Here is the point:</p><ul><li>Before the algorithm execute, we can patch the repetitive prefix &amp; suffix nodes first.</li><li>If we get <code>common sequence + other node</code>, we need to mount or unmount node.</li><li>If we get <code>unknown sequence</code>, we need to find its <code>Longest Increasing Subsequence</code>. Move the node that need to move, mount the node that need to mount.</li></ul><h1 id="reference"><a class="markdownIt-Anchor" href="#reference"></a> Reference</h1><ol><li>vue-next: <a href="https://github.com/vuejs/vue-next" target="_blank" rel="noopener">https://github.com/vuejs/vue-next</a></li><li>渲染器: <a href="http://hcysun.me/vue-design/zh/renderer-diff.html#inferno-%E6%89%80%E9%87%87%E7%94%A8%E7%9A%84%E6%A0%B8%E5%BF%83-diff-%E7%AE%97%E6%B3%95%E5%8F%8A%E5%8E%9F%E7%90%86" target="_blank" rel="noopener">http://hcysun.me/vue-design/zh/renderer-diff.html#inferno-所采用的核心-diff-算法及原理</a></li><li>Longest increasing subsequence wikipedia: <a href="https://en.wikipedia.org/wiki/Longest_increasing_subsequence" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Longest_increasing_subsequence</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 源码阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> diff </tag>
            
            <tag> 最长递增子序列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue3 源码阅读笔记（四）—— 模板编译器的设计，从 AST 类型说起</title>
      <link href="/2020/11/12/vue3source4/"/>
      <url>/2020/11/12/vue3source4/</url>
      
        <content type="html"><![CDATA[<blockquote><p>注意这里讨论的模板编译器源码是 Vue3 的。另外的，我并不会粘贴完整的代码，而只是基于当前讨论的主题来选取一些关键的代码句子。你可以比对着真正的源码来阅读。毕竟源码才是最好的课本。</p></blockquote><h1 id="简述"><a class="markdownIt-Anchor" href="#简述"></a> 简述</h1><p>Vue 的模板编译器算是除响应式系统之外的，另一个核心系统了。得益于模板编译器的支持，我们可以在写代码时使用诸如 <code>v-if</code>，<code>v-slot</code> 等方便的 api。<br />尽管名称中带有“编译器”三个字，但它相较于一些现代语言编译器来说，还是十分简单的。但总的来说，还是一样的，分为下面几个步骤：</p><ul><li>parse</li><li>transform</li><li>code generate</li></ul><p>如果你提前阅读过 Vue3 的模板编译器语法，你会发现代码量很大。但再复杂的系统，也往往都是从几个简单的核心概念一步步构建起来的。只要找到了这几个核心概念，理清楚它们解决了什么问题，又是如何相互协作的，再去一条条的考虑具体边界情况，就能很容易的搞清楚整个系统了。</p><p>建议你使用官方的 <a href="https://vue-next-template-explorer.netlify.app" target="_blank" rel="noopener">模板调试工具</a> 来查看一下不同模板实际产出的 AST。如果你不了解 AST，那么你可以查看 <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree" target="_blank" rel="noopener">维基百科的解释</a>。<br />不过你需要注意的是，调试工具输出的 AST 是 transform 之后的产物，在这个过程中会对原先通过 parser 产出的树做一些优化处理，这主要是为最后一步 code generate 做准备。<br />如果你觉得这样看比较难受，那么你可以下载 <code>vue-next</code> 的源码，直接调试或自己编写测试用例。</p><a id="more"></a><h1 id="ast-设计"><a class="markdownIt-Anchor" href="#ast-设计"></a> AST 设计</h1><blockquote><p>在阅读源码时，将重点放在 AST 的原因是可以快速理解编译器的设计思路。而如果你想要自己设计一个编译器，那么你的重点应当放在编译器中后端。AST 应当是慢慢积累出的产物。</p></blockquote><p>AST 算是编译器处理源码的中间产物。它与平台无关，完整的表现了源码的信息。<br />如果你从 AST 的角度来考虑代码，那么你会发现，代码并非一条条命令的堆积，而是一个复杂的拓扑结构。</p><p>以 Vue 的模板语法为例，我们可以写出如下代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这代表了一个 <code>div</code> 标签。而这个标签并不是仅包含自身的，它是可以嵌套的：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然而，除了嵌套，标签也可以平行的排列：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>尽管这种模板语法和高级语言有很大的区别，但我们依然可以借助 AST 来完整的表述整个代码。<br />例如对于第一种嵌套，我们可以使用以下 AST 来表示：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">root: &#123;</span><br><span class="line">  children: [</span><br><span class="line">    &#123;</span><br><span class="line">      tag: <span class="string">"div"</span>,</span><br><span class="line">      children: [</span><br><span class="line">        &#123;</span><br><span class="line">          tag: <span class="string">"div"</span>,</span><br><span class="line">          children: [],</span><br><span class="line">        &#125;,</span><br><span class="line">      ],</span><br><span class="line">    &#125;,</span><br><span class="line">  ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而对于第二种平行排列的标签，我们可以这样写：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root: &#123;</span><br><span class="line">  children: [</span><br><span class="line">    &#123; tag: <span class="string">"div"</span>, children: [] &#125;,</span><br><span class="line">    &#123; tag: <span class="string">"div"</span>, children: [] &#125;,</span><br><span class="line">  ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以看到，这棵树忠实的反应了模板的所有信息：标签名、标签间的位置信息（即是嵌套还是平行）。</p><p>如果一个标签还含有其他信息，例如类名：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"title"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这就意味着，我们需要设计出如下所示的节点类型：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> ElementNode &#123;</span><br><span class="line">  tag: <span class="built_in">string</span>;</span><br><span class="line">  property: <span class="built_in">any</span>[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到，<code>property</code> 字段是一个数组，这样我们就可以存储多个标签属性了。另外的，标签属性相互之间都是平行的，所以这里也不存在递归。</p><p>经过上面的解释，你应该已经注意到了，如果你想要理解 Vue3 模板编译器，那么了解 AST 的设计就是非常有必要的了。<br />幸运的是，<code>Vue3</code> 是使用 <code>TypeScript</code> 编写的。良好的类型系统可以帮助我们完整的理解 AST 的整体设计。</p><h1 id="类型"><a class="markdownIt-Anchor" href="#类型"></a> 类型</h1><blockquote><p>本节所属源码在 <code>packages/compiler-core/src/ast.ts</code>。Vue 本身是在发展的，所以具体代码可能会有变化，但整体思想是不变的。</p></blockquote><h2 id="几个基础类型"><a class="markdownIt-Anchor" href="#几个基础类型"></a> 几个基础类型</h2><p>整个 AST 类型系统是由一些基本类型搭建起来的，就像是乐高积木。如果你先了解了基础的几个类型，那么由此构建而来的具体类型将会变得很容易理解。</p><h3 id="nodetypes"><a class="markdownIt-Anchor" href="#nodetypes"></a> NodeTypes</h3><p>顾名思义，这个是 AST 的节点类型。通过这个 <code>interface</code>，你可以很快弄清楚 AST 中到底有哪些节点。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">enum</span> NodeTypes &#123;&#125;</span><br><span class="line"><span class="comment">// base types</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// containers types</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// code generate types</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ssr code generate types</span></span><br></pre></td></tr></table></figure><p><code>NodeTypes</code> 分为四个部分。上面两个部分是在拆解源码，初步生成 AST 时的一些类型。在这里你可以看到一些熟悉的东西，例如 <code>IF</code> 、<code>FOR</code>，就是 Vue 中的 <code>v-if</code>，<code>v-for</code>。<code>DIRECTIVE</code> 就是指令。</p><p>而下面两个部分则是所谓的 <code>code generate</code> 部分所需的节点类型。我们在第一步 <code>parse</code> 阶段产出的 AST 虽然能完整的反应源码的信息，但如果直接用这东西来生成渲染代码，属实会有点难用。所以需要一个 <code>transform</code> 阶段来生成一些节点帮助生成代码。这也就是所谓的 <code>code generate node</code>。</p><p>在这里，你需要注意 <code>TEXT</code> 这个类型。它并不仅仅指代例如这样的文本节点：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>还指代诸如属性值这样的东西：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"title"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样的设计是为了复用一些逻辑。不过这并不是编译器本身的核心思想，所以如果你不理解，那么等到阅读对应函数时就会理解了。</p><h3 id="elementtypes"><a class="markdownIt-Anchor" href="#elementtypes"></a> ElementTypes</h3><p>元素类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">enum</span> ElementTypes &#123;</span><br><span class="line">  ELEMENT,</span><br><span class="line">  COMPONENT,</span><br><span class="line">  SLOT,</span><br><span class="line">  TEMPLATE,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类型想必就不用说了吧，都是些老朋友。</p><h3 id="node-sourcelocation-position"><a class="markdownIt-Anchor" href="#node-sourcelocation-position"></a> Node、SourceLocation、Position</h3><p>这几个都是编译器代码本身使用的类型。你不必现在就看懂它们。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Node &#123;</span><br><span class="line">  <span class="keyword">type</span>: NodeTypes</span><br><span class="line">  loc: SourceLocation</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> SourceLocation &#123;</span><br><span class="line">  start: Position</span><br><span class="line">  end: Position</span><br><span class="line">  source: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Position &#123;</span><br><span class="line">  line: <span class="built_in">number</span></span><br><span class="line">  column: <span class="built_in">number</span></span><br><span class="line">  offset: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="几个复合类型"><a class="markdownIt-Anchor" href="#几个复合类型"></a> 几个复合类型</h2><p>节点是可以被分类的。通过使用 <code>TypeScript</code> 的 <code>Union Types</code> 语法，我们可以很轻松的完成这件事。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ParentNode = RootNode | ElementNode | IfBranchNode | ForNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ExpressionNode = SimpleExpressionNode | CompoundExpressionNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TemplateChildNode =</span><br><span class="line">  | ElementNode</span><br><span class="line">  | InterpolationNode</span><br><span class="line">  | CompoundExpressionNode</span><br><span class="line">  | TextNode</span><br><span class="line">  | CommentNode</span><br><span class="line">  | IfNode</span><br><span class="line">  | IfBranchNode</span><br><span class="line">  | ForNode</span><br><span class="line">  | TextCallNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TemplateTextChildNode =</span><br><span class="line">  | TextNode</span><br><span class="line">  | InterpolationNode</span><br><span class="line">  | CompoundExpressionNode;</span><br></pre></td></tr></table></figure><p>这里是几个复合的节点类型。用于 <code>parser</code> 中。</p><p>另外的，在 <code>transform</code> 阶段，我们会使用到一些类型，大概阅读一下，你就可以知道实际生成的代码有哪些模式了：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> JSChildNode =</span><br><span class="line">  | VNodeCall</span><br><span class="line">  | CallExpression</span><br><span class="line">  | ObjectExpression</span><br><span class="line">  | ArrayExpression</span><br><span class="line">  | ExpressionNode</span><br><span class="line">  | FunctionExpression</span><br><span class="line">  | ConditionalExpression</span><br><span class="line">  | CacheExpression</span><br><span class="line">  | AssignmentExpression</span><br><span class="line">  | SequenceExpression;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> SSRCodegenNode =</span><br><span class="line">  | BlockStatement</span><br><span class="line">  | TemplateLiteral</span><br><span class="line">  | IfStatement</span><br><span class="line">  | AssignmentExpression</span><br><span class="line">  | ReturnStatement</span><br><span class="line">  | SequenceExpression;</span><br></pre></td></tr></table></figure><p>这些类型实际上暗含着实际生成的渲染代码的“模式”。我们就是通过这种类型与生成代码模式的映射关系来产出代码的。</p><h1 id="结语"><a class="markdownIt-Anchor" href="#结语"></a> 结语</h1><p>搞清楚 AST 中都有哪些节点是读懂编译器代码的第一步。尽管在大多数时候这并不值得写成一篇文章，不过如果是第一次做这件事，详细理解一下也是必要的。</p>]]></content>
      
      
      <categories>
          
          <category> 源码阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
            <tag> 递归下降 </tag>
            
            <tag> 类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用膜隔离应用程序的子组件</title>
      <link href="/2020/10/26/membranes1/"/>
      <url>/2020/10/26/membranes1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文翻译自 <a href="https://tvcutsem.github.io/membranes" target="_blank" rel="noopener">Isolating application sub-components with membranes</a></p></blockquote><p>膜是一种防御式的编程模式，被运用在一个应用程序的子组件之间。这种模式适用于内存安全的编程语言。</p><p>这种模式被提出已经很久了，但却并不广为人知。这篇文章的目的就是讲清楚膜编程背后的思想。因为我关于 膜 的很多经验都是建立于 <code>Web</code> 平台的，所以我会主要从 <code>Javascript</code> 和 <code>Web</code> 平台的用例来解释。值得注意的是，膜 模式并不是仅仅针对于 Web 编程提出的概念，它是一个可以广泛应用的模式。</p><p><strong>历史</strong>: 膜的概念来源于对 <a href="https://en.wikipedia.org/wiki/Capability-based_security" target="_blank" rel="noopener">Capability-secure Systems</a> 的研究。最早可追溯至功能安全操作系统，例如 <a href="http://cap-lore.com/CapTheory/KK/" target="_blank" rel="noopener">KeyKOS</a>。 以及功能安全语言，例如 <a href="http://www.erights.org/history/joule/index.html" target="_blank" rel="noopener">Joule</a> 和 <a href="http://www.erights.org/index.html" target="_blank" rel="noopener">E</a>。本文对膜的介绍主要基于 <code>Mark S</code> 中的描述。Miller 的 <a href="http://erights.org/talks/thesis/index.html" target="_blank" rel="noopener">博士论文</a>。膜后来被独立地发明，并被广泛应用于函数式编程社区去实现高阶函数的契约。</p><a id="more"></a><h1 id="隔离应用和应用的子组件"><a class="markdownIt-Anchor" href="#隔离应用和应用的子组件"></a> 隔离应用和应用的子组件</h1><p>操作系统通常都实现了很多保护机制来协调应用程序间的交互。例如进程引入了不同的地址空间来隔离应用程序。</p><p>膜是一种安全编程模式，它可以实现相同的隔离，不过这种隔离指的是单独的应用程序中，而不是不同的应用程序。膜的名字会让人联想起细胞膜。它可以保护精细的内部环境不会被混乱的外部环境所破坏，并且允许按照一定的规则来和环境交互。</p><p>膜允许协调器在每一次与特定子组件交互的时候都执行一些逻辑，这些子组件可能包含一些无法完全信任的第三方代码。主机页面想要保护自身，避免被一些嵌入式脚本影响。浏览器也许想要将自身和第三方的浏览器扩展隔离开。Web 框架可能希望跟踪和观察网页 app 数据的变化，从而刷新 UI。</p><p>膜是围绕一个或多个对象的可控边界，通常使用代理或包装器对象来实现。在一个典型的膜实现中，隔离通常从单个根对象开始。例如，在网页编程中，通常将 <code>window</code> 对象包裹在膜代理中。然后，被代理了的 <code>window</code> 可以传递给嵌入式的第三方脚本：</p><p><img src="https://bebopfzj.oss-cn-hangzhou.aliyuncs.com/uPic/2020-10-26-KEBIjD.png" alt="使用膜代理 window 对象" /></p><p>在上图中，半圆代表一个代理对象，它提供了一些可供其他子组件访问源对象的接口。</p><h1 id="膜的特性"><a class="markdownIt-Anchor" href="#膜的特性"></a> 膜的特性</h1><p>让我们简要的回顾一下膜模式的核心特性。</p><h2 id="膜是透明的且大多数提供了保护行为"><a class="markdownIt-Anchor" href="#膜是透明的且大多数提供了保护行为"></a> 膜是透明的且大多数提供了保护行为</h2><p>膜代理经常被设计成透明的。这就是说，对客户代码来说，访问被膜代理的对象和访问源对象是没有区别的。这很重要，因为客户代码期望在访问一个被代理后的对象时，依然可以正常工作。在上述例子中，第三方脚本拿到的是经过代理的 <code>window</code> 对象，但第三方脚本并不会意识到这是一个经过代理了的对象，它仍旧像使用原本的对象一样使用它。</p><p>注意到我写的是“膜代理看起来是相同的”：当第三方代码和被包装的对象交互时，膜的创建者通常期望执行一些逻辑。这些逻辑通常实现了某些对被包装对象的“失真”处理。在我们网页的例子中，主机页面通常会将一些对于真实 <code>window</code> 对象的操作替换为敏感度较低的虚拟操作。例如获取历史记录的操作可能会返回一些虚假的历史记录数据。更复杂的例子是膜将一个宿主机页面的 <code>&lt;div&gt;</code> DOM 元素包装到一个虚拟的 <code>window</code> 对象中去。这样第三方的脚本将只能在这个 <code>&lt;div&gt;</code> 中渲染内容，而不会影响到页面的其他部分。</p><h2 id="膜的插入是可传递的"><a class="markdownIt-Anchor" href="#膜的插入是可传递的"></a> 膜的插入是可传递的</h2><p>使用代理作为其他对象的包装器是面向对象语言中非常常见的 <a href="https://en.wikipedia.org/wiki/Proxy_pattern" target="_blank" rel="noopener">设计模式</a>。所以膜和传统的代理设计模式的区别是什么呢？膜的代理会传递至被代理对象的子属性中。通常传递下去的膜代理会执行与原本相同的代理逻辑。例如，如果 <code>window</code> 对象是被代理的，那么 <code>window.document</code> 会返回一个代理了的 <code>document</code> 对象。</p><p><img src="https://bebopfzj.oss-cn-hangzhou.aliyuncs.com/uPic/2020-10-26-tzpkio.png" alt="膜沿着 window 对象传递" /></p><p>很多时候，我们不仅希望将第三方代码与主机隔离开，同样也希望将主机与第三方代码隔离开。膜可以通过包装那些传递给膜对象方法的参数来实现这一点：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.document.onClick = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(event.target);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这里，传递给 <code>onlick</code> 的函数对象将被包裹在另一个膜代理中：<br /><img src="https://bebopfzj.oss-cn-hangzhou.aliyuncs.com/uPic/2020-10-26-F17IiH.png" alt="代理函数对象" /></p><p>这种包装确保了如果主机稍候使用事件 <code>e</code> 来回调函数，膜可以确保实际传递的是 <code>e</code> 的代理。因此，回调的 <code>event</code> 参数将会是一个包装好的 <a href="https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent" target="_blank" rel="noopener">MouseEvent</a> 对象。例如，他可以确保 <code>event.target</code> 会返回一个被包装的 DOM 节点，而不是一个真实的节点（可以从中访问到 <code>document</code>）。</p><p><img src="https://bebopfzj.oss-cn-hangzhou.aliyuncs.com/uPic/2020-10-26-PgTbCx.png" alt="代理参数" /></p><p>膜这种传递性的代理是非常强大且有用的，这意味着对于一组对象的安全边界是灵活且动态的。不用预先列出所有的对象并一次性的包裹。这种传递性的包裹还允许膜处理复杂（高阶）面向对象和接口，其中对象或函数通常作为值参数传递给其他对象和函数，同时还支持无法预先知道的动态数据流。</p><h2 id="膜保持了一致性"><a class="markdownIt-Anchor" href="#膜保持了一致性"></a> 膜保持了一致性</h2><p>许多编程语言都有可变的数据类型，例如具有可变字段的对象或记录。可变值具有同一性。例如，在大多数面向对象语言中，对象可能相等，可以通过标识相等操作符（如 java 中的 == 或 JavaScript 中的 ===）判断这种相等。</p><p>在这种语言中，我们通常需要膜保持膜两侧值的一致性。继续我们的网页平台例子，如果 <code>window</code> 是一个膜代理的对象，<code>location</code> 也是膜代理的对象。那么我们期望类似于 <code>window.location === document.location</code> 这样的恒等式在膜的另一侧也成立。</p><p><img src="https://bebopfzj.oss-cn-hangzhou.aliyuncs.com/uPic/2020-10-26-yMG2gP.png" alt="保持等式成立" /></p><p>我们同样期望那些穿过膜很多次的值在膜的另一侧也能保持其特性。如果要理解为什么这很重要，考虑通过膜在 <code>document</code> 上注册事件处理程序并随后取消的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> handler = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(event);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">"click"</span>, handler, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">document</span>.removeEventListener(<span class="string">"click"</span>, handler, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p><img src="https://bebopfzj.oss-cn-hangzhou.aliyuncs.com/uPic/2020-10-26-FfLLme.png" alt="通过膜注册和取消事件处理程序" /></p><p>为了让 <code>removeEventListener</code> 找到并取消使用 <code>addEventListener</code> 注册的函数，传递给两边函数的参数应该是相等的，否则将永远也无法找到原始的处理函数。</p><p>最后，我们也会需要一个从膜的一侧传递到另一侧，然后再返回回来的包装值，用以取代它的原始值。为什么这么做？考虑一个简单的函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设一个函数通过膜产出，其函数名是 <code>id</code>。然后，在膜的另一侧，对于拥有任何值的 <code>v</code>，我们都希望能保持 <code>id(v) === v</code>。我们需要在将 <code>v</code> 传递给 <code>id</code> 函数之前包装它，然后在将这个值返回给客户端之前解包它。</p><p>保存标识通常需要膜实现一个缓存来确保其为每个有状态值仅分配一个规范的包装器。为了确保这种缓存不会导致内存泄漏，我们通常会使用一些特殊的数据结构，例如 Java 中的 <code>WeakHashMap</code> 或是 JavaScript 中的 <code>WeakMap</code>。这些映射仅保持对键的弱引用，所以它不会阻止垃圾收集的正常运行。</p><h1 id="优势以及局限"><a class="markdownIt-Anchor" href="#优势以及局限"></a> 优势以及局限</h1><p>为了真正有效的隔离应用程序的子组件，膜必须拦截它试图隔离的子组件对象间所有可能的交互作用。需要注意的是，这需要整个应用程序中不存在对于子组件全局可见的变量。在类似于 <code>JavaScript</code> 这样的语言中，这通常需要确保全局变量是不可变的，或者你可以用一个虚拟化的变量来替换（你可以参考 <a href="https://github.com/Agoric/ses-shim" target="_blank" rel="noopener">Secure ECMAScript</a> 的实现）。而在像 <code>Java</code> 这样的语言中，通常意味着你需要避免使用静态字段或是危险的 api（你可以参阅 <a href="https://code.google.com/archive/p/joe-e/" target="_blank" rel="noopener">Joe-E</a>，这是一个强制用户使用这些属性的 Java 子集）。</p><p>使用膜来隔离应用程序的不同部分的另一个优点是，在膜两侧的对象仍然享有相同的地址空间，因此你仍然可以使用标准的编程抽象（例如方法的调用或字段访问）来进行通信。它们还可以共享指向共享状态的指针（通常是不可变的）。这与进程抽象的思路完全不同，因为后者引入了单独的地址空间。者通常强制使用进程间通信机制（IPC），并且还需要开发者重新设计应用中子组件的接口。例如，在浏览器中，另一种隔离 web 应用中不同部分的方法是使用 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers" target="_blank" rel="noopener">Web Workers</a> ，它只能通过异步的消息传递来交互。</p><p>因为膜运行在单个应用程序的进程和地址空间之上，所以它并<strong>不能</strong>防止 DOS 攻击，也不能阻止隔离组件的崩溃。</p><h1 id="现实中膜模式的应用"><a class="markdownIt-Anchor" href="#现实中膜模式的应用"></a> 现实中膜模式的应用</h1><p>让我们看几个在真实应用上使用膜模式的例子。</p><h2 id="firefox-的脚本分区"><a class="markdownIt-Anchor" href="#firefox-的脚本分区"></a> Firefox 的脚本分区</h2><p>也许对于膜模式最广泛的应用就是在 Firefox 浏览器中了。Firefox 的 <a href="https://developer.mozilla.org/en-US/docs/Mozilla/Gecko/Script_security" target="_blank" rel="noopener">脚本安全架构</a> 遵循膜模式，它实现了对核心 JavaScript 代码和不同站点源之间的隔离。这种模式事实上 <a href="https://bholley.net/blog/2016/the-right-fix.html" target="_blank" rel="noopener">减少了许多严重的安全 bug</a>。</p><p>在 Firefox 中，膜模式被称为 <a href="https://dxr.mozilla.org/mozilla-central/source/js/src/proxy/CrossCompartmentWrapper.cpp" target="_blank" rel="noopener">cross compartment wrappers</a>。</p><h2 id="caja-中的脚本沙盒"><a class="markdownIt-Anchor" href="#caja-中的脚本沙盒"></a> Caja 中的脚本沙盒</h2><p>我正在运行的一个主机页面保护自己，以免受嵌入式脚本影响的例子，就是 <a href="https://developers.google.com/caja/" target="_blank" rel="noopener">谷歌 Caja</a> 的一个应用。Caja 允许在网页内安全的嵌入第三方活动，并被广泛的应用于谷歌自家的产品，例如 <a href="https://sites.google.com/" target="_blank" rel="noopener">Google Sites</a>、<a href="https://developers.google.com/apps-script/overview" target="_blank" rel="noopener">Google Apps Scripts</a>、<a href="https://earthengine.google.com/" target="_blank" rel="noopener">Google Earth Engine</a>。</p><h2 id="使用-es-membrane-自定义-dom-视图"><a class="markdownIt-Anchor" href="#使用-es-membrane-自定义-dom-视图"></a> 使用 es-membrane 自定义 DOM 视图</h2><p>作为 <a href="https://sourceforge.net/projects/templates.verbosio.p/" target="_blank" rel="noopener">Verbosio XML editor</a> 工作的副产品，Alexander J. Vincent 为 JavaScript 实现了一个可复用的 <a href="https://github.com/ajvincent/es-membrane" target="_blank" rel="noopener">膜库</a>。他最初的用例是协调不同的 Firefox 插件，使得每个插件都基于相同的 DOM 来自定义视图。例如，每个附加组件都可以在共享的 DOM 上定义自己的 <a href="https://developer.mozilla.org/en-US/docs/Glossary/Expando" target="_blank" rel="noopener">expando</a> 属性。</p><p><a href="https://github.com/ajvincent/es-membrane" target="_blank" rel="noopener">es-membrane</a> 也是第一个将典型的双侧膜推广为 N 侧膜的库。在 N 侧膜中，一个协调器可以直接在多个子组件之间进行调节，而不需要创建多个膜。</p><h2 id="使用可观察膜检测数据的变化"><a class="markdownIt-Anchor" href="#使用可观察膜检测数据的变化"></a> 使用可观察膜检测数据的变化</h2><p>尽管膜模式最初是为了实现隔离子组件的防御性编程而提出的，但膜模式也可以用于除了强制执行某些安全属性之外的其他目的。例如，Caridy Patino 和 Salesforce 的团队已经成功的使用膜模式来检测对象图上的变化。你可以查阅他们的 <a href="https://github.com/salesforce/observable-membrane" target="_blank" rel="noopener">实现</a>。</p><p>开发者希望观察对象图上变化的一个原因就是，在 web 应用框架中实现数据绑定：框架观测对象图，在发生变化时刷新 UI。你可以参考 <a href="https://github.com/salesforce/observable-membrane/tree/master/examples/reactivo-element" target="_blank" rel="noopener">这个例子</a>，它实现了反应式的 web 组件。</p><h1 id="一些经验"><a class="markdownIt-Anchor" href="#一些经验"></a> 一些经验</h1><p>我们之前强调过，保持膜的透明是很重要的。不过实际开发的经验却告诉我们，我们不应当去改变在膜两侧交换的实际值，而应该在数据上实现一种过滤器，或是在故障流上实现故障停止。</p><p>例子：</p><ul><li>白名单：仅向子组件公开数据或是行为的子集</li><li>扩展：将一个子组件添加的新属性视为其他组件不可见的虚拟属性</li><li>撤销：在膜上实现一个终止开关，可以立刻将所有膜代理转化为安全的悬浮指针（在访问撤销后使用任何膜代理都会触发异常）。这是 Miller 的论文中关于膜的最初灵感，你可以参考这种可撤销膜的 <a href="https://github.com/tvcutsem/harmony-reflect/blob/master/examples/membrane.js" target="_blank" rel="noopener">实现</a></li><li>契约：断言方法参数和返回值的前置条件和后置条件。因为膜可以跟踪数据流，当断言失败时，膜知道到底是哪个子组件出错了。你可以参考这个 <a href="https://beautifulracket.com/explainer/data-structures.html" target="_blank" rel="noopener">例子</a></li><li>记录日志：非侵入式的记录子组件的所有交互行为，这可以帮助你调试或者 <a href="http://erights.org/elib/capability/horton/index.html" target="_blank" rel="noopener">审核</a></li></ul><h1 id="包装双关语"><a class="markdownIt-Anchor" href="#包装双关语"></a> 包装（双关语）</h1><p>膜模式是一种防御性的编程模式，它用于隔离单个应用中的子组件。这通常是通过在需要隔离的对象图周围创建一个可动态变化（通过将每个对象传递到一个保护代理对象中）的代理来实现的。</p><p>正确的实现膜模式并不容易。例如，在 JavaScript 中，由于语言的复杂性，对象之间会有许多交互方式（看看 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy" target="_blank" rel="noopener">Proxy</a> 可以代理的 api 数量就知道了）。然而幸运的是，你可以直接使用社区实现好的库，例如 <a href="https://github.com/ajvincent/es-membrane" target="_blank" rel="noopener">es-membrane</a> 和 <a href="https://github.com/salesforce/observable-membrane" target="_blank" rel="noopener">observable-membrane</a>，来减少你的工作量。这些库将膜的核心逻辑抽象出来，允许你自定义一些钩子函数来实现业务逻辑。</p><p>如果你对 JavaScript 中运用膜模式比较感兴趣的话，你可以参考一些他的其他文章：</p><ul><li><a href="https://tvcutsem.github.io/js-membranes" target="_blank" rel="noopener">An introduction to membranes in javascript</a></li><li><a href="https://tvcutsem.github.io/proxies_tutorial" target="_blank" rel="noopener">An introduction to ecmascript proxies</a></li><li><a href="https://tvcutsem.github.io/frozen-proxies" target="_blank" rel="noopener">Ecmascript proxies and frozen objects</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> membranes </tag>
            
            <tag> proxy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>好耶！是 Webpack（二）———— 代码分割</title>
      <link href="/2020/10/18/webpack2/"/>
      <url>/2020/10/18/webpack2/</url>
      
        <content type="html"><![CDATA[<h1 id="为什么要进行代码分割"><a class="markdownIt-Anchor" href="#为什么要进行代码分割"></a> 为什么要进行代码分割</h1><p>事实上，尽管 <code>Webpack</code> 的功能是打包，但将所有文件都打包到一个文件下并不是一个好的选择。过大的打包文件会让加载变慢，导致用户感受到的 <code>白屏时间</code> 更长。<br />但如果直接加载开发环境的代码，过于零碎的模块同样会使加载变慢。这主要是因为目前主流的 <code>HTTP 1.1</code> 对同一个域名下的并行请求有所限制。另外，过多请求的请求头也会占用流量和带宽。</p><p>总而言之，代码的颗粒度并没有一个确切的值。你需要根据业务本身来作出决定。</p><a id="more"></a><h1 id="多入口与多出口"><a class="markdownIt-Anchor" href="#多入口与多出口"></a> 多入口与多出口</h1><p>关于代码分割，一个好的实践是</p>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> code-split </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>好耶！是 Webpack（一）———— 基础概念</title>
      <link href="/2020/10/18/webpack1/"/>
      <url>/2020/10/18/webpack1/</url>
      
        <content type="html"><![CDATA[<h1 id="简述"><a class="markdownIt-Anchor" href="#简述"></a> 简述</h1><p><code>Webpack</code> 是什么？官网是这样介绍的：</p><blockquote><p>本质上，webpack 是一个现代 JavaScript 应用程序的静态模块打包工具。当 webpack 处理应用程序时，它会在内部构建一个 依赖图(dependency graph)，此依赖图会映射项目所需的每个模块，并生成一个或多个 bundle。</p></blockquote><p>只要你从事前端开发，就不可能绕过 <code>Webpack</code> 这个工具。这篇文章基于 <code>Webpack4</code>，总结其核心概念及常规用法。</p><h1 id="核心概念"><a class="markdownIt-Anchor" href="#核心概念"></a> 核心概念</h1><p><code>Webpack</code> 的核心概念分为四个：<code>entry</code>、<code>output</code>、<code>loader</code> 和 <code>plugin</code>。<br />理解这些概念是更好的使用 <code>Webpack</code> 的保证。</p><a id="more"></a><h2 id="入口-entry"><a class="markdownIt-Anchor" href="#入口-entry"></a> 入口 entry</h2><p>关于入口，官方是这样定义的：</p><blockquote><p>入口起点(entry point)指示 webpack 应该使用哪个模块，来作为构建其内部 依赖图(dependency graph) 的开始。</p></blockquote><p>换句话说，<code>Webpack</code> 会从入口开始遍历整棵依赖树。你可以理解为对二叉树的遍历。</p><h3 id="单入口"><a class="markdownIt-Anchor" href="#单入口"></a> 单入口</h3><p>一个简单的单文件入口示例是这样的，适用于一些简单场景中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; resolve &#125; = <span class="built_in">require</span>(<span class="string">"path"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: resolve(__dirname, <span class="string">"src/index.js"</span>),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="多入口"><a class="markdownIt-Anchor" href="#多入口"></a> 多入口</h3><p>在复杂应用中，将文件打包为一个 <code>bundle</code> 会导致页面加载缓慢，所以我们需要做 <code>Code Splitting</code>。<br />简单来说就是多入口、多出口、公共部分。<br />这种优化的前提就是多文件入口打包。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; resolve &#125; = <span class="built_in">require</span>(<span class="string">"path"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    entry1: resolve(__dirname, <span class="string">"src/index.js"</span>),</span><br><span class="line">    entry2: resolve(__dirname, <span class="string">"src/index2.js"</span>),</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="出口-output"><a class="markdownIt-Anchor" href="#出口-output"></a> 出口 output</h2><p>关于出口，官方是这样定义的：</p><blockquote><p>output 属性告诉 webpack 在哪里输出它所创建的 bundle，以及如何命名这些文件。</p></blockquote><p>输出的文件名可以写死，也可以根据入口文件动态配置。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; resolve &#125; = <span class="built_in">require</span>(<span class="string">"path"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: resolve(__dirname, <span class="string">"dist"</span>),</span><br><span class="line">    <span class="comment">// filename: "bundle.js"</span></span><br><span class="line">    filename: <span class="string">"[name]_[hash].js"</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>关于文件哈希值，有以下几种配置：</p><ul><li>hash</li><li>chunkhash 同一个 chunk 同一个 hash</li><li>contenthash 一个文件一个 hash</li></ul><h2 id="loader"><a class="markdownIt-Anchor" href="#loader"></a> loader</h2><p>关于 <code>loader</code>，官方是这样定义的：</p><blockquote><p>webpack 只能理解 JavaScript 和 JSON 文件。loader 让 webpack 能够去处理其他类型的文件，并将它们转换为有效 模块，以供应用程序使用，以及被添加到依赖图中。</p></blockquote><p>简单来说，你需要 <code>loader</code> 来转换诸如 <code>css</code> 文件等东西。</p><h3 id="几个-loader-的常用配置"><a class="markdownIt-Anchor" href="#几个-loader-的常用配置"></a> 几个 loader 的常用配置</h3><ul><li>test loader 匹配规则</li><li>exclude 不需要匹配的文件</li><li>include 只匹配哪些文件</li><li>loader 使用单个 loader</li><li>use 使用多个 loader，是数组</li><li>options loader 的参数，参考对应 loader 的文档</li></ul><p><strong>注意</strong> 如果你使用多个 loader，它们是按照数组逆序的顺序运行的</p><h3 id="loader-配置示例"><a class="markdownIt-Anchor" href="#loader-配置示例"></a> loader 配置示例</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 处理 html 文件的 loader</span></span><br><span class="line">        test: <span class="regexp">/\.html$/</span>,</span><br><span class="line">        exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">        include: <span class="regexp">/src/</span>,</span><br><span class="line">        loader: <span class="string">"html-loader"</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 处理 css 文件的 loader</span></span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          <span class="comment">// 逆序执行</span></span><br><span class="line">          <span class="string">"style-loader"</span>,</span><br><span class="line">          <span class="string">"css-loader"</span>,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 处理 js 文件的 loader</span></span><br><span class="line">        test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          <span class="comment">// 多线程打包</span></span><br><span class="line">          <span class="string">"thread-loader"</span>,</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">"babel-loader"</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              presets: [<span class="string">"@babel/preset-env"</span>],</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="plugin"><a class="markdownIt-Anchor" href="#plugin"></a> plugin</h2><p>关于 <code>plugin</code>，官方是这样定义的：</p><blockquote><p>插件可以用于执行范围更广的任务。包括：打包优化，资源管理，注入环境变量。<br />换句话说，插件主要是为了增强 <code>webpack</code> 在自动化构建方面的能力。</p></blockquote><p>例子中使用 <code>HtmlWebpackPlugin</code> 自动创建打包后的 <code>html</code> 文件。使用 <code>CleanWebpackPlugin</code> 插件，在每次打包前，自动清理上一次打包的文件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">"html-webpack-plugin"</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; CleanWebpackPlugin &#125; = <span class="built_in">require</span>(<span class="string">"clean-webpack-plugin"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      title: <span class="string">"Hello Webpack"</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> CleanWebpackPlugin(),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>不过插件的配置没有什么规律可循，一切都得查阅对应插件的文档来配置。</p><h1 id="常用-loader"><a class="markdownIt-Anchor" href="#常用-loader"></a> 常用 loader</h1><p>下面总结一些常用的 loader，具体用法可以查阅对应的文档。</p><h2 id="css-相关"><a class="markdownIt-Anchor" href="#css-相关"></a> css 相关</h2><ul><li>style-loader</li><li>css-loader</li><li>postcss-loader</li><li>sass-loader</li><li>less-loader</li></ul><h2 id="js-相关"><a class="markdownIt-Anchor" href="#js-相关"></a> js 相关</h2><ul><li>babel-loader</li><li>@babel/core</li><li>@babel/preset-env</li><li>@babel/polyfill</li></ul><h2 id="文件相关"><a class="markdownIt-Anchor" href="#文件相关"></a> 文件相关</h2><ul><li>url-loader</li><li>file-loader</li><li>html-loader</li></ul><h2 id="vue-相关"><a class="markdownIt-Anchor" href="#vue-相关"></a> vue 相关</h2><ul><li>vue-loader</li><li>vue-style-loader</li></ul>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> entry </tag>
            
            <tag> output </tag>
            
            <tag> loader </tag>
            
            <tag> plugin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue3 源码阅读笔记（三）—— 响应式？不过是数据劫持罢了</title>
      <link href="/2020/10/16/vue3source3/"/>
      <url>/2020/10/16/vue3source3/</url>
      
        <content type="html"><![CDATA[<h1 id="简述"><a class="markdownIt-Anchor" href="#简述"></a> 简述</h1><p>事实上，响应式并不是 <code>Vue3</code> 的新概念，它是一个核心概念。在实际代码中，响应式系统经常与组件化相提并论。更进一步的说，组件化赋予了开发者模块化代码的能力，而响应式系统则让开发者可以通过数据控制组件的呈现方式。</p><p>不过这东西从本质上来讲，其实就是劫持数据的变化，在数据变化后自动的执行一些副作用函数。</p><p>如果你大致的了解过这个东西，你大概会知道，<code>Vue2</code> 和 <code>Vue3</code> 的响应式系统实现有些略微不同。<br />从表象上来说，<code>Vue2</code> 的响应式系统是黑盒。<code>Vue2</code> 承包了一切工作，你只需要将数据定义在诸如 <code>data</code>、<code>props</code>、<code>computed</code> 等选项中就行。而 <code>Vue3</code> 则是把这个决定权交给了开发者。由开发者来决定究竟哪些数据应该是响应式的。<br />从实现上来说，<code>Vue2</code> 使用 <code>Object.defineproperty</code> 来实现数据劫持，而 <code>Vue3</code> 则使用了 <code>proxy</code> 。</p><p>从逻辑上讲，其实二者是相同的，都是为了实现核心的数据劫持。<br />不过 <code>Vue</code> 毕竟是一个投入到实际生产中使用的框架，仅仅完成理论上的实现当然是不行的。从 <code>Object.defineproperty</code> 到 <code>proxy</code> 的切换实际上也表现出了一些技术上的选择。</p><p>简单来说，因为 <code>Vue2</code> 对响应式数据黑盒化的设计，在框架初始化的时候，会递归遍历所有数据，然后使用 <code>Object.defineproperty</code> 来做劫持。这是一个解决方案，但并不够好。因为首先会付出很多性能消耗，其次，并不是每一条数据都需要变成响应式的。递归消耗的性能支出是否合算，全看开发者的具体实现方式。另外，<code>Object.defineproperty</code> 也不能监听到对象属性的新增与删除。<br />所以 <code>Vue3</code> 使用了 <code>proxy</code> 和显式的 <code>reactice API</code>。这样不仅可以让开发者自行决定哪些数据需要变成响应式的，还能减少劫持时的数据消耗。</p><p>除此之外，在具体实现中，<code>Vue3</code> 也做了一些调整来优化性能。更具体的东西，来直接看源码吧。</p><a id="more"></a><h1 id="入口-api"><a class="markdownIt-Anchor" href="#入口-api"></a> 入口 API</h1><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reactive.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">reactive</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">object</span>&gt;(<span class="params">target: T</span>): <span class="title">UnwrapNestedRefs</span>&lt;<span class="title">T</span>&gt;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">reactive</span>(<span class="params">target: object</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// if trying to observe a readonly proxy, return the readonly version.</span></span><br><span class="line">  <span class="keyword">if</span> (target &amp;&amp; (target <span class="keyword">as</span> Target)[ReactiveFlags.IS_READONLY]) &#123;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> creativeReactiveObject(</span><br><span class="line">    target,</span><br><span class="line">    <span class="literal">false</span>,</span><br><span class="line">    mutableHandlers,</span><br><span class="line">    mutableCollectionHandlers</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单来说，这个入口函数主要是处理一下只读的 <code>proxy</code>，直接返回。如果不是只读的，那么就进入 <code>creativeReactiveObject</code> 函数的创建逻辑。<br />这样做的好处就是封装，一个函数只专注于一件事情。让创建响应式对象的函数去关心传入的对象是不是只读的，属实有点职责不清。</p><h1 id="creativereactiveobject"><a class="markdownIt-Anchor" href="#creativereactiveobject"></a> creativeReactiveObject</h1><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> reactiveMap = <span class="keyword">new</span> WeakMap&lt;Target, <span class="built_in">any</span>&gt;();</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> readonlyMap = <span class="keyword">new</span> WeakMap&lt;Target, <span class="built_in">any</span>&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createReactiveObject</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  target: Target,</span></span></span><br><span class="line"><span class="function"><span class="params">  isReadonly: <span class="built_in">boolean</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  baseHandlers: ProxyHandler&lt;<span class="built_in">any</span>&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  collectionHandlers: ProxyHandler&lt;<span class="built_in">any</span>&gt;</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> proxyMap = isReadonly ? readonlyMap : reactiveMap;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> proxy = <span class="keyword">new</span> Proxy(</span><br><span class="line">    target,</span><br><span class="line">    targetType === TargetType.COLLECTION ? collectionHandlers : baseHandlers</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  proxyMap.set(target, proxy);</span><br><span class="line">  <span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单来说，这个创建过程只有两步：</p><ol><li>使用 Proxy 做好劫持</li><li>创建 WeakMap 映射</li></ol><h1 id="mutablehandlers"><a class="markdownIt-Anchor" href="#mutablehandlers"></a> mutableHandlers</h1><p>根据数据是否是 <code>collection</code> 类型的，划分出了两种劫持实现。因为我们关注的是响应式系统的原理，所以就选择 <code>mutableHandlers</code> 来研究。如果你有兴趣的话，可以自己读一下 <code>mutableCollectionHandlers</code> 的代码。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> mutableHandlers: ProxyHandler&lt;object&gt; = &#123;</span><br><span class="line">  <span class="keyword">get</span>,</span><br><span class="line">  <span class="keyword">set</span>,</span><br><span class="line">  deleteProperty,</span><br><span class="line">  has,</span><br><span class="line">  ownKeys,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>代码一目了然，就是劫持了这些操作。<br />接下来，就是在 <code>get</code> 中进行依赖收集，然后在 <code>set</code> 中派发通知了。我们分别说说这俩。</p><h1 id="get-到-track-的依赖收集"><a class="markdownIt-Anchor" href="#get-到-track-的依赖收集"></a> get 到 track 的依赖收集</h1><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">get</span> = createGetter();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createGetter</span>(<span class="params">isReadonly = <span class="literal">false</span>, shallow = <span class="literal">false</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params">target: Target, key: <span class="built_in">string</span> | symbol, receiver: object</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> res = Reflect.get(target, key, receiver);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isReadonly) &#123;</span><br><span class="line">      track(target, TrackOpTypes.GET, key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>既然是 <code>getter</code> 函数，那么求值就是必要的。这里使用了 <code>Reflect</code> 来求值。<br />接着，如果不是只读的，那么就调用 <code>track</code> 函数来收集依赖。下面是 <code>track</code> 函数的实现</p><h1 id="track"><a class="markdownIt-Anchor" href="#track"></a> track</h1><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> targetMap = <span class="keyword">new</span> WeakMap&lt;<span class="built_in">any</span>, KeyToDepMap&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">track</span>(<span class="params">target: object, <span class="keyword">type</span>: TrackOpTypes, key: unknown</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> depsMap = targetMap.get(target);</span><br><span class="line">  <span class="keyword">if</span> (!depsMap) &#123;</span><br><span class="line">    targetMap.set(target, (depsMap = <span class="keyword">new</span> Map()));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> dep = depsMap.get(key);</span><br><span class="line">  <span class="keyword">if</span> (!dep) &#123;</span><br><span class="line">    depsMap.set(key, (dep = <span class="keyword">new</span> Set()));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!dep.has(activeEffect)) &#123;</span><br><span class="line">    dep.add(activeEffect);</span><br><span class="line">    activeEffect.deps.push(dep);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个嵌套的映射结构。代码很清晰，不过如果用图展示映射关系的话，会更清晰：<br /><img src="https://bebopfzj.oss-cn-hangzhou.aliyuncs.com/uPic/2020-10-16-FjfTcQ.png" alt="依赖图" /></p><p>根据代码，我们放入 <code>depsMap</code> 中的是一些 <code>activeEffect</code>。这就是所谓的副作用函数。换句话说，就是数据变化时，需要自动执行的那些函数。</p><p>你现在应该已经清楚了，依赖收集到底是什么？依赖收集其实就是搞了一堆映射关系，记录一下哪些数据有哪些副作用函数。不过你可能对依赖这东西到底是啥还有点迷惑。那么我们就来看看怎么设定一个依赖函数。</p><h1 id="effect"><a class="markdownIt-Anchor" href="#effect"></a> effect</h1><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// effect.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> effectStack: ReactiveEffect[] = [];</span><br><span class="line"><span class="keyword">let</span> activeEffect: ReactiveEffect | <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">effect</span>&lt;<span class="title">T</span> = <span class="title">any</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  fn: () =&gt; T,</span></span></span><br><span class="line"><span class="function"><span class="params">  options: ReactiveEffectOptions = EMPTY_OBJ</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">ReactiveEffect</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">const</span> effect = createReactiveEffect(fn, options);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> effect;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createReactiveEffect</span>&lt;<span class="title">T</span> = <span class="title">any</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  fn: () =&gt; T,</span></span></span><br><span class="line"><span class="function"><span class="params">  options: ReactiveEffectOptions</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">ReactiveEffect</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> effect = <span class="function"><span class="keyword">function</span> <span class="title">reactiveEffect</span>(<span class="params"></span>): <span class="title">unknown</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 注意，以下是简化过的核心逻辑代码</span></span><br><span class="line">    activeEffect = effect;</span><br><span class="line">    <span class="keyword">return</span> fn();</span><br><span class="line">  &#125; <span class="keyword">as</span> ReactiveEffect;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> effect;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了说明最本质的东西，我改写了一下 <code>createReactiveEffect</code> 函数。其实这个函数就做了两件事，将 <code>effect</code> 指向全局的 <code>activeEffect</code>，然后执行绑定的 <code>fn</code> 函数。<br />另外的，你应该已经注意到了，这个 <code>effect</code> 实际上是个函数，是个待执行的函数。那么它将在什么时候执行呢？答案就是 <code>set</code> 派发通知的时候。</p><h1 id="真正的-createreactiveeffect"><a class="markdownIt-Anchor" href="#真正的-createreactiveeffect"></a> 真正的 createReactiveEffect</h1><p>不过我们先不看派发通知。刚才为了说明逻辑，大幅简化了 <code>createReactiveEffect</code> 函数的逻辑，不过如果你在看源码，你会发现这里的实现比较复杂。<br />简单来说，就是使用了 <code>栈</code> 来执行依赖函数，这样做的原因是为了处理嵌套 <code>effect</code>。我们直接来看完整版的代码：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> effectStack: ReactiveEffect[] = [];</span><br><span class="line"><span class="keyword">let</span> activeEffect: ReactiveEffect | <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createReactiveEffect</span>&lt;<span class="title">T</span> = <span class="title">any</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  fn: () =&gt; T,</span></span></span><br><span class="line"><span class="function"><span class="params">  options: ReactiveEffectOptions</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">ReactiveEffect</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> effect = <span class="function"><span class="keyword">function</span> <span class="title">reactiveEffect</span>(<span class="params"></span>): <span class="title">unknown</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!effect.active) &#123;</span><br><span class="line">      <span class="keyword">return</span> options.scheduler ? <span class="literal">undefined</span> : fn();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!effectStack.includes(effect)) &#123;</span><br><span class="line">      cleanup(effect);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        enableTracking();</span><br><span class="line">        effectStack.push(effect);</span><br><span class="line">        activeEffect = effect;</span><br><span class="line">        <span class="keyword">return</span> fn();</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        effectStack.pop();</span><br><span class="line">        resetTracking();</span><br><span class="line">        activeEffect = effectStack[effectStack.length - <span class="number">1</span>];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">as</span> ReactiveEffect;</span><br><span class="line"></span><br><span class="line">  effect.id = uid++;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> effect;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="处理嵌套-effect"><a class="markdownIt-Anchor" href="#处理嵌套-effect"></a> 处理嵌套 effect</h2><p>你应该注意到了这两句代码：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">effectStack.push(effect);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">effectStack.pop();</span><br></pre></td></tr></table></figure><p>这是个典型的入栈出栈操作。<br />这个设计是为了解决嵌套的 <code>effect</code> 而实现的。我们按照嵌套方式，将函数压入栈，然后从栈顶的函数开始执行，将 <code>activeEffect</code> 指向这个函数。然后执行完一个弹出一个，再执行外层的 <code>effect</code> 函数。<br />也许你会觉得这个设计很熟悉，对了，这个其实就是函数的执行栈在处理闭包时候的操作。</p><h2 id="cleanup"><a class="markdownIt-Anchor" href="#cleanup"></a> cleanup</h2><p>另外的，你应该注意到了在实际处理依赖函数前，我们调用了 <code>cleanup</code> 函数。下面是它的实现：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cleanup</span>(<span class="params">effect: ReactiveEffect</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; deps &#125; = effect;</span><br><span class="line">  <span class="keyword">if</span> (deps.length) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; deps.length; i++) &#123;</span><br><span class="line">      deps[i].delete(effect);</span><br><span class="line">    &#125;</span><br><span class="line">    deps.length = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码很清楚，就是在清除 <code>deps</code> 的映射。下面解释一下这样做的理由。<br />设 <code>data</code> 集合，是页面代码所有数据的集合。<code>renderedData</code> 集合，是渲染在了页面上的数据的集合。<code>postRenderedData</code> 是页面变化后渲染在页面上的数据的集合。<br />那么，有以下几个结论：</p><ol><li><code>renderedData</code> 是 <code>data</code> 的子集。</li><li><code>postRenderedData</code> 是 <code>data</code> 的子集。</li><li><code>postRenderedData</code> 与 <code>renderedData</code> 不一定相等。</li></ol><p>这几个结论不难理解。页面在变化的过程中，并不是所有的数据都会呈现在页面上。但是在第一次呈现的时候，会触发 <code>get</code> 函数，进而进行依赖收集。可是在页面变化后，可能有一部分已经被收集依赖的数据并不会呈现在页面上。<br />如果我们不做任何处理，那么一旦那些未被渲染的数据改变，也会触发整体页面的重新渲染。这种逻辑显然是错误的，页面怎么能因为一个没有被展现在页面上的数据而重新渲染呢？</p><p>所以，这就是 <code>cleanup</code> 函数的理由。清除这些依赖。防止预期之外的重新渲染。</p><h1 id="set-到-trigger-的派发通知"><a class="markdownIt-Anchor" href="#set-到-trigger-的派发通知"></a> set 到 trigger 的派发通知</h1><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">set</span> = createSetter();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createSetter</span>(<span class="params">shallow = flase</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">set</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    target: object,</span></span></span><br><span class="line"><span class="function"><span class="params">    key: <span class="built_in">string</span> | symbol,</span></span></span><br><span class="line"><span class="function"><span class="params">    value: unknown,</span></span></span><br><span class="line"><span class="function"><span class="params">    receiver: object</span></span></span><br><span class="line"><span class="function"><span class="params">  </span>): <span class="title">boolean</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> hadKey =</span><br><span class="line">      isArray(target) &amp;&amp; isIntegerKey(key)</span><br><span class="line">        ? <span class="built_in">Number</span>(key) &lt; target.length</span><br><span class="line">        : hasOwn(target, key);</span><br><span class="line">    <span class="keyword">const</span> result = Reflect.set(target, key, value, receiver);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// don't trigger if target is something up in the prototype chain of original</span></span><br><span class="line">    <span class="keyword">if</span> (target === toRaw(receiver)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!hadKey) &#123;</span><br><span class="line">        trigger(target, TriggerOpTypes.ADD, key, value);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (hasChanged(value, oldValue)) &#123;</span><br><span class="line">        trigger(target, TriggerOpTypes.SET, key, value, oldValue);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单来说，分为两步：</p><ol><li>使用 <code>Reflect.set</code> 设定了值</li><li>调用 <code>trigger</code> 来派发通知</li></ol><p>在具体调用 <code>trigger</code> 时判断了一下原型。如果 <code>target</code> 的原型是一个 <code>proxy</code>，那么使用 <code>Reflect.set</code> 设置属性的时候会再次触发 <code>setter</code>。所以这里需要优化。<br />不过这部分对于核心流程的理解来说无足轻重。</p><h1 id="trigger"><a class="markdownIt-Anchor" href="#trigger"></a> trigger</h1><p>下面是 <code>trigger</code> 函数的实现：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">trigger</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  target: object,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">type</span>: TriggerOpTypes,</span></span></span><br><span class="line"><span class="function"><span class="params">  key?: unknown,</span></span></span><br><span class="line"><span class="function"><span class="params">  newValue?: unknown,</span></span></span><br><span class="line"><span class="function"><span class="params">  oldValue?: unknown,</span></span></span><br><span class="line"><span class="function"><span class="params">  oldTarget?: Map&lt;unknown, unknown&gt; | Set&lt;unknown&gt;</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> depsMap = targetMap.get(target);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> effects = <span class="keyword">new</span> Set&lt;RectiveEffect&gt;();</span><br><span class="line">  <span class="keyword">const</span> add = <span class="function">(<span class="params">effectsToAdd: Set&lt;ReactiveEffect&gt; | <span class="literal">undefined</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// SET | ADD | DELETE | Map.SET</span></span><br><span class="line">  <span class="comment">// 在 depsMap 添加对应 effect</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> run = <span class="function">(<span class="params">effect: ReactiveEffect</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (effect.options.scheduler) &#123;</span><br><span class="line">      <span class="comment">// 调度执行</span></span><br><span class="line">      effect.options.scheduler(effect);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 直接执行</span></span><br><span class="line">      effect();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  effects.forEach(run);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数的实际源码很长，不过做的事情很简单，就两件事：</p><ol><li>将 depsMap 中的 effect 函数，根据所做事情的 key，添加到 effects 集合里</li><li>遍历 effects 集合，执行副作用函数</li></ol><h1 id="渲染副作用函数"><a class="markdownIt-Anchor" href="#渲染副作用函数"></a> 渲染副作用函数</h1><p>过在上一章结尾，我们提到了一句渲染流程和响应式系统结合的部分，就是这句代码：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">instance.update = effect(</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">componentEffect</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!instance.isMounted) &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  __DEV__ ? createDevEffectOptions(instance) : prodEffectOptions</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>注意到了吗，这里其实就是注册了副作用函数，然后将这东西绑定在了 <code>instance.update</code> 上。这就是为什么在你更改一个响应式数据后，页面会自动刷新了。</p><h1 id="补充"><a class="markdownIt-Anchor" href="#补充"></a> 补充</h1><p>如果你也去看一下 <code>watch</code>、<code>computed</code> 功能的实现，你会发现其实它们也是通过 <code>effect</code> 来注册副作用函数的。例如实现 <code>computed</code> 的这段源码：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// apiWatch.ts</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doWatch</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    source: WatchSource | WatchSource[] | WatchEffect,</span></span></span><br><span class="line"><span class="function"><span class="params">    cb: WatchCallback || <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    &#123; immediate, deep, flush, onTrack, onTrigger &#125;: WatchOptions = EMPTY_OBJ,</span></span></span><br><span class="line"><span class="function"><span class="params">    instance = currentInstance</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">WatchStopHandle</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> runner = effect(getter, &#123;</span><br><span class="line">        lazy: <span class="literal">true</span>,</span><br><span class="line">        onTrack,</span><br><span class="line">        onTrigger,</span><br><span class="line">        scheduler</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        stop(runner)</span><br><span class="line">        <span class="keyword">if</span> (instance) &#123;</span><br><span class="line">            remove(instance.effects!, runner)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过这些实际 <code>api</code> 的实现留到以后再说。</p><h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1><p>到这里，响应式系统的核心逻辑就已经介绍完了。大致总结一下：</p><ol><li>响应式系统使用 <code>proxy</code> 来实现数据劫持</li><li>数据劫持中 <code>getter</code> 调用 <code>track</code> 函数收集依赖</li><li>数据劫持中 <code>setter</code> 调用 <code>trigger</code> 函数派发通知</li></ol><p>另外的，响应式系统还提供了一些其他的常用 api，例如 <code>readonly</code>、<code>ref</code> 等，你可以自己去查看源码。</p><p>最后，你还可以参考 <a href="https://vue3js.cn/docs/zh/guide/reactivity.html#%E4%BB%80%E4%B9%88%E6%98%AF%E5%93%8D%E5%BA%94%E6%80%A7" target="_blank" rel="noopener">官方的响应式原理教程</a>，这是学习的最好资料。</p>]]></content>
      
      
      <categories>
          
          <category> 源码阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> proxy </tag>
            
            <tag> reactive </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue3 源码阅读笔记（二）—— 响应式系统之前，是创建与渲染</title>
      <link href="/2020/10/14/vue3source2/"/>
      <url>/2020/10/14/vue3source2/</url>
      
        <content type="html"><![CDATA[<h1 id="一些说明"><a class="markdownIt-Anchor" href="#一些说明"></a> 一些说明</h1><ol><li>这篇文章并不是专注于介绍响应式 API 的文章，所以如果你想搞清楚新的 API 该怎么用，那么你应当关注官方的 <a href="https://v3.vuejs.org/guide/migration/introduction.html#overview" target="_blank" rel="noopener">Migration Guide</a></li><li>为了更明确的说明一些问题，我可能会删减许多代码。但这些代码并非是不必要的，只是对于我们要阐述的主题来说，它们是毫无必要的</li></ol><h1 id="从-createapp-开始"><a class="markdownIt-Anchor" href="#从-createapp-开始"></a> 从 CreateApp 开始</h1><p>在这一节，我们会介绍 <code>Vue.js</code> 的入口函数 <code>createApp</code>，以及这之后的一整套渲染过程。阅读这一部分的内容有助于你理解响应式系统在整个 <code>Vue.js</code> 中扮演了怎样的角色。</p><p>当你使用 <code>Vue3</code> 写一个组件时，你可能会这样做：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = createApp(&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;).mount(<span class="string">"#app"</span>);</span><br></pre></td></tr></table></figure><a id="more"></a><p>你应该发现了，这是个链式调用。换句话说，<code>createApp</code> 函数产出了一个东西，这个东西是带有 <code>mount</code> 方法的。其次，<code>createApp</code> 函数的参数就是你写主要逻辑的地方。<br />明确了函数的输入与输出，我们接下来看一下具体的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> createApp = <span class="function">(<span class="params">(...args</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> app = ensureRenderer().createApp(...args)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    app.mount = (containerOrSelector: Element | string): <span class="function"><span class="params">any</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app</span><br><span class="line">&#125;) <span class="keyword">as</span> CreateAppFunction&lt;Element&gt;</span><br></pre></td></tr></table></figure><p>这个函数的逻辑非常清晰。创建一个 <code>app</code> 对象，然后重写 <code>app</code> 的 <code>mount</code> 方法。</p><h1 id="创建渲染器"><a class="markdownIt-Anchor" href="#创建渲染器"></a> 创建渲染器</h1><p>其中这一句：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app = ensureRenderer().createApp(...args);</span><br></pre></td></tr></table></figure><p><code>ensureRenderer</code> 函数创建了一个渲染器对象。我们来看看它是怎么做的。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.ts</span></span><br><span class="line"><span class="keyword">let</span> rederer: Renderer&lt;Element&gt; | HydrationRenderer;</span><br><span class="line"><span class="keyword">const</span> rendererOptions = extend(&#123; patchProp, forcePatchProp &#125;, nodeOps);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ensureRenderer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    renderer || (renderer = createRenderer&lt;Node, Element&gt;(rendererOptions))</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// renderer.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createRenderer</span>&lt;</span></span><br><span class="line"><span class="function">  <span class="title">HostNode</span> = <span class="title">RendererNode</span>,</span></span><br><span class="line"><span class="function">  <span class="title">HostElement</span> = <span class="title">RendererElement</span></span></span><br><span class="line"><span class="function">&gt;(<span class="params">options: RendererOptions&lt;HostNode, HostElement&gt;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> baseCreateRenderer&lt;HostNode, HostElement&gt;(options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你会发现 <code>ensureRenderer</code> 函数并没有直接产出一个渲染器，而是通过 <code>Currying</code> 延迟创建了。这样做的原因是，如果用户只依赖响应式模块，那么 <code>tree shaking</code> 就能移除渲染器相关的代码。<br />接下来 <code>baseCreateRenderer</code> 就是具体实现渲染器的函数了。在实际的源码中你可能会看到许多重载，不过我们不关注那些，直接关注渲染器的具体实现：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">baseCreateRenderer</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  options: RendererOptions,</span></span></span><br><span class="line"><span class="function"><span class="params">  createHydrationFns?: <span class="keyword">typeof</span> createHydrationFunction</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> &#123;</span><br><span class="line">    insert: hostInsert,</span><br><span class="line">    remove: hostRemove,</span><br><span class="line">    patchProp: hostPatchProp,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    insertStaticContent: hostInsertStaticContent,</span><br><span class="line">  &#125; = options;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> patch: PatchFn = (</span><br><span class="line">    n1,</span><br><span class="line">    n2,</span><br><span class="line">    container,</span><br><span class="line">    anchor,</span><br><span class="line">    parentComponent,</span><br><span class="line">    parentSuspense,</span><br><span class="line">    isSVG,</span><br><span class="line">    optimized</span><br><span class="line">  ) =&gt; &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> processText: ProcessTextOrCommentFn = <span class="function">(<span class="params">n1, n2, container, anchor</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> render: RootRenderFunction = <span class="function">(<span class="params">vnode, container</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    render,</span><br><span class="line">    hydrate,</span><br><span class="line">    createApp: createAppAPI(render, hydrate),</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数很长，主要是使用闭包的方式实现渲染器的相关函数。另外返回的内容可以看出，有 <code>createApp</code> 函数。这就是我们用来创建 <code>app</code> 的方法。</p><h1 id="重写-mount-方法"><a class="markdownIt-Anchor" href="#重写-mount-方法"></a> 重写 mount 方法</h1><p>接下来是这两句：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; mount &#125; = app;</span><br><span class="line">app.mount = (containerOrSelector: Element | <span class="built_in">string</span>): <span class="function"><span class="params">any</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> proxy = mount(container);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> proxy;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>就是在外面调用的 <code>mount</code> 函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = createApp(&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;).mount(<span class="string">"#app"</span>);</span><br></pre></td></tr></table></figure><h1 id="挂载"><a class="markdownIt-Anchor" href="#挂载"></a> 挂载</h1><p>接下来，逻辑会走入改写好的 <code>mount</code> 函数，我们来看一下实际的改写实现：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; mount &#125; = app;</span><br><span class="line">app.mount = (containerOrSelector: Element | <span class="built_in">string</span>): <span class="function"><span class="params">any</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> proxy = mount(container);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> proxy;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个 <code>mount</code> 函数被包裹在了 <code>createAppAPI</code> 函数中，不过我们暂时不关心如何导出这些 <code>api</code>，而是直接看 <code>mount</code> 函数的内容：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">mount(rootContainer: HostElement, isHydrate?: <span class="built_in">boolean</span>): <span class="built_in">any</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isMounted) &#123;</span><br><span class="line">        <span class="keyword">const</span> vnode = createVNode(</span><br><span class="line">            rootComponent <span class="keyword">as</span> ConcreteComponent,</span><br><span class="line">            rootProps</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isHydrate &amp;&amp; hydrate) &#123;</span><br><span class="line">            hydrate(vnode <span class="keyword">as</span> VNode&lt;Node, Element&gt;, rootContainer <span class="keyword">as</span> <span class="built_in">any</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            render(vnode, rootContainer)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">        warn(</span><br><span class="line">            <span class="comment">// 警告信息</span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整体逻辑很清晰，创建 <code>vnode</code> ，然后渲染它。你可能会注意到 <code>hydrate</code> 这个函数。它是用来 <code>SSR 渲染</code> 的。你暂时不必关心它。<br /><code>render</code> 函数就是在 <code>baseCreateRenderer</code> 这个超长函数中实现的。刚才我们略过了其具体实现，下面来看一下：</p><h1 id="渲染"><a class="markdownIt-Anchor" href="#渲染"></a> 渲染</h1><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> render: RootRenderFunction = <span class="function">(<span class="params">vnode, container</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (vnode == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (container._vnode) &#123;</span><br><span class="line">      unmount(container._vnode, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    patch(container._vnode || <span class="literal">null</span>, vnode, container);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  container._vnode = vnode;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>主要逻辑就一个 <code>if...else</code>。简单来说，<code>vnode</code> 若不存在，执行 <code>unmount</code> 函数卸载，若存在，则执行 <code>patch</code> 函数。<br /><code>unmount</code> 没啥好说的，我们直接看 <code>patch</code> 函数。</p><h1 id="patch"><a class="markdownIt-Anchor" href="#patch"></a> patch</h1><p>不过在看具体代码之前，我们应该搞清楚这个函数具体是干啥的。简单来说，它是用来确认旧 <code>node</code> 应当怎样与新 <code>node</code> 相互替换的。为了帮助你理解，我整理了一下 <code>patch</code> 函数可能会遇到的几种情况。</p><h2 id="当旧子节点是单个子节点时"><a class="markdownIt-Anchor" href="#当旧子节点是单个子节点时"></a> 当旧子节点是单个子节点时</h2><p><img src="https://bebopfzj.oss-cn-hangzhou.aliyuncs.com/uPic/2020-10-15-xJFavj.png" alt="当旧节点是单个子节点" /></p><h2 id="当旧子节点是空"><a class="markdownIt-Anchor" href="#当旧子节点是空"></a> 当旧子节点是空</h2><p><img src="https://bebopfzj.oss-cn-hangzhou.aliyuncs.com/uPic/2020-10-15-sNIKiY.png" alt="当旧子节点是空" /></p><h2 id="当旧子节点是子节点数组"><a class="markdownIt-Anchor" href="#当旧子节点是子节点数组"></a> 当旧子节点是子节点数组</h2><p><img src="https://bebopfzj.oss-cn-hangzhou.aliyuncs.com/uPic/2020-10-15-AkMojh.png" alt="当旧子节点是子节点数组" /></p><p>明白了 <code>patch</code> 函数的基本流程后，我们就可以很容易的读懂 <code>patch</code> 函数的实现了。</p><h1 id="processcomponent"><a class="markdownIt-Anchor" href="#processcomponent"></a> processComponent</h1><p>不过我们这里直接略过 <code>patch</code> 函数的具体源码，因为比较长，你可以根据上面的逻辑图来阅读源码。我们直接跳到 <code>processComponent</code> 函数。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (shapeFlag &amp; ShapeFlags.COMPONENT) &#123;</span><br><span class="line">    processComponent(</span><br><span class="line">        n1, n2, container, anchor,</span><br><span class="line">        parentComponent, parentSuspense,</span><br><span class="line">        isSVG, optimized</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> processComponent = (</span><br><span class="line">    n1: VNode | <span class="literal">null</span>,</span><br><span class="line">    n2: VNode,</span><br><span class="line">    container: RendererElement,</span><br><span class="line">    anchor: RendererNode | <span class="literal">null</span>,</span><br><span class="line">    parentComponent: ComponentInternalInstance | <span class="literal">null</span>,</span><br><span class="line">    parentSuspense: SuspenseBoundary | <span class="literal">null</span>,</span><br><span class="line">    isSVG: <span class="built_in">boolean</span>,</span><br><span class="line">    optimized: <span class="built_in">boolean</span></span><br><span class="line">) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (n1 == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n2.shapeFlag &amp; ShapeFlag.COMPONENT_KEPT_ALIVE) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mountComponent(</span><br><span class="line">                n2,</span><br><span class="line">                container,</span><br><span class="line">                anchor,</span><br><span class="line">                parentComponent,</span><br><span class="line">                parentSuspense,</span><br><span class="line">                isSVG,</span><br><span class="line">                optimized</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        updateComponent(n1, n2, optimized)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那个省略的部分是 <code>keep-alive</code> 组件的处理，暂时不需要管。我们这里需要关注的是 <code>mountComponent</code> 函数。因为我们需要关注组件更新时调用的函数，具体是从哪来的。你会在 <code>updateComponent</code> 函数的实现中看到它。</p><h1 id="mountcomponent"><a class="markdownIt-Anchor" href="#mountcomponent"></a> mountComponent</h1><p>这个函数是用来挂载组件的，我们重点关注它的实现：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mountComponent: MountComponentFn = (</span><br><span class="line">  initialVNode,</span><br><span class="line">  container,</span><br><span class="line">  anchor,</span><br><span class="line">  parentComponent,</span><br><span class="line">  parentSuspense,</span><br><span class="line">  isSVG,</span><br><span class="line">  optimized</span><br><span class="line">) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 创建实例</span></span><br><span class="line">  <span class="keyword">const</span> instance: ComponentInternalInstance = (initialVNode.component = createComponentInstance(</span><br><span class="line">    initialVNode,</span><br><span class="line">    parentComponent,</span><br><span class="line">    parentSuspense</span><br><span class="line">  ));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 配置组件实例</span></span><br><span class="line">  <span class="comment">// props、slots 等在这里注入</span></span><br><span class="line">  setupComponent(instance);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 运行带副作用的渲染函数</span></span><br><span class="line">  setupRenderEffect(</span><br><span class="line">    instance,</span><br><span class="line">    initialVNode,</span><br><span class="line">    container,</span><br><span class="line">    anchor,</span><br><span class="line">    parentSuspense,</span><br><span class="line">    isSVG,</span><br><span class="line">    optimized</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意到我们这里创建了组件实例，并进行了一些配置。其中最重要的就是 <code>setupRenderEffect</code> 函数。它是带副作用的渲染函数。我们来看看它的实现：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> setupRenderEffect: SetupRenderEffectFn = (</span><br><span class="line">  instance,</span><br><span class="line">  initialVNode,</span><br><span class="line">  container,</span><br><span class="line">  anchor,</span><br><span class="line">  parentSuspense,</span><br><span class="line">  isSVG,</span><br><span class="line">  optimized</span><br><span class="line">) =&gt; &#123;</span><br><span class="line">  <span class="comment">// create reactive effect for rendering</span></span><br><span class="line">  instance.update = effect(</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">componentEffect</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;,</span><br><span class="line">    __DEV__ ? createDevEffectOptions(instance) : prodEffectOptions</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意到 <code>instance.update</code> 的赋值。调用响应式系统的 <code>effect</code> 函数，创建了渲染的副作用函数。<br />这里也就是响应式系统的一个“入口”。</p><h1 id="最后"><a class="markdownIt-Anchor" href="#最后"></a> 最后</h1><p>我们在这里梳理了 <code>Vue.js</code> 的大致流程，尽管这些流程都是渲染相关的，但讲清楚它们是必要的，因为这是响应式系统的目的。换句话说，响应式系统实际上就是为渲染服务的。</p><p>另外的，我们没有深入谈论 <code>componentEffect</code> 函数，因为它应当被放在渲染相关的专题里讨论。</p><p>总而言之，说了这么多，最重要的就这一行代码：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">instance.update = effect(</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">componentEffect</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;,</span><br><span class="line">  __DEV__ ? createDevEffectOptions(instance) : prodEffectOptions</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>也许你还不明白为什么重要，等下一篇文章我们讨论完整个儿响应式系统后，你再回过头来看，就会恍然大悟了。（因为我就是这样</p>]]></content>
      
      
      <categories>
          
          <category> 源码阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> event loop </tag>
            
            <tag> Currying </tag>
            
            <tag> track </tag>
            
            <tag> trigger </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue3 源码阅读笔记（一）—— 搭建环境</title>
      <link href="/2020/10/04/vue3source1/"/>
      <url>/2020/10/04/vue3source1/</url>
      
        <content type="html"><![CDATA[<p>工欲善其事必先利其器，在阅读源码前，首先要做的一步就是搭建调试源码的环境。</p><ol><li>从 <code>Github</code> 下载源码：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git@github.com:vuejs&#x2F;vue-next.git</span><br></pre></td></tr></table></figure><ol start="2"><li>使用 <code>Webstrom</code> 打开项目，安装依赖</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn install</span><br></pre></td></tr></table></figure><ol start="3"><li>配置项目运行</li></ol><p>你可以参考我的配置，但请注意将一些个性化设置配置成你自己的。<br />注意 <code>Arguments</code> 一栏的参数 <code>-s</code>。这个参数会生成 <code>source map</code> 来帮助你调试源码。</p><p><img src="https://bebopfzj.oss-cn-hangzhou.aliyuncs.com/uPic/2020-10-04-whgKh1.png" alt="Vue3 源码运行配置" /></p><a id="more"></a><ol start="4"><li>创建调试代码<br />在项目根目录下创建一个 <code>demo</code> 文件夹，并创建 <code>index.html</code> 文件。<br />下面是一份调试代码参考，你可以按照你的兴趣修改成你想要调试的特性。</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 注意这里的路径需要改写成你自己的 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 如果你的目录结构和我的一样，那么可以忽略 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"../packages/vue/dist/vue.global.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">const</span> &#123; createApp, reactive &#125; = Vue;</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">      <span class="keyword">const</span> vm = createApp(&#123;</span></span><br><span class="line">        template: `</span><br><span class="line"><span class="handlebars"><span class="xml">            <span class="tag">&lt;<span class="name">h1</span>&gt;</span></span><span class="template-variable">&#123;&#123; data.title &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span></span><br><span class="line">    `,</span><br><span class="line"></span><br><span class="line">        setup() &#123;</span><br><span class="line"><span class="actionscript">          <span class="keyword">const</span> data = reactive(&#123;</span></span><br><span class="line"><span class="actionscript">            title: <span class="string">"Hello World"</span>,</span></span><br><span class="line">          &#125;);</span><br><span class="line"></span><br><span class="line"><span class="javascript">          setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="actionscript">            data.title = <span class="string">"New Title"</span>;</span></span><br><span class="line">          &#125;, 3000);</span><br><span class="line"></span><br><span class="line"><span class="actionscript">          <span class="keyword">return</span> &#123; data &#125;;</span></span><br><span class="line">        &#125;,</span><br><span class="line"><span class="actionscript">      &#125;).mount(<span class="string">"#app"</span>);</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="5"><li>使用浏览器打开 <code>index.html</code> 文件，打开开发者控制台，打好断点，刷新页面，开始你的 <code>Vue3</code> 源码之旅吧！<br /><img src="https://bebopfzj.oss-cn-hangzhou.aliyuncs.com/uPic/2020-10-04-OV2Owr.png" alt="浏览器源码调试界面" /></li></ol>]]></content>
      
      
      <categories>
          
          <category> 源码阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 调试 </tag>
            
            <tag> sourcemap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tree Shaking</title>
      <link href="/2020/09/29/treeShaking/"/>
      <url>/2020/09/29/treeShaking/</url>
      
        <content type="html"><![CDATA[<h1 id="关于-treeshaking"><a class="markdownIt-Anchor" href="#关于-treeshaking"></a> 关于 Treeshaking</h1><p><code>tree shaking</code> 指的是移除 <code>JavaScript</code> 上下文中的的未引用代码（dead-code）。这个术语和概念最先是 ES2015 打包工具 <code>rollup</code> 发展的。</p><p>事实上，消除无用代码并不是一个新的概念。这种技术被广泛运用于传统的编程语言编译器中，编译器会判断代码是否影响功能，并移除那些无用的代码，这个技术被称为 <code>DCE (dead code elimination)</code>。</p><p>从先后来讲，<code>tree shaking</code> 是 <code>DCE</code> 的一种新的实现。不过和传统的 DCE 不一样的是，<code>tree shaking</code> 更关注于消除没有用到的代码，而 DCE 则关注那些不可能执行的代码，由编译器将 dead code 从 AST 上删除。<br />另一方面，在大多数情况下，<code>JavaScript</code> 都是通过网络加载的。众所周知，网络速度可是一个变化多端的东西。所以如果能缩短代码的加载时间，那么这对网络应用性能和用户体验的提升都是极大的。</p><a id="more"></a><h1 id="javascript-的模块化"><a class="markdownIt-Anchor" href="#javascript-的模块化"></a> JavaScript 的模块化</h1><p>因为 <code>tree shaking</code> 依赖于 ES2015 模块系统中的 <a href="https://exploringjs.com/es6/ch_modules.html#static-module-structure" target="_blank" rel="noopener">静态结构特性</a> ，所以先介绍一下 <code>JavaScript</code> 那芜杂的模块系统还是十分有必要的。</p><h2 id="nodejs-模块"><a class="markdownIt-Anchor" href="#nodejs-模块"></a> <code>Node.js</code> 模块</h2><p><code>Node.js</code> 里面的模块系统遵循的是 <code>CommonJS</code> 规范。它是同步的加载模块规范，换句话说，只有等加载完之后，才能执行后面的操作。</p><p><code>Node.js</code> 内部提供一个 <code>Module</code> 构建函数，所有的模块都是 <code>Module</code> 的实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Module</span>(<span class="params">id, parent</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.id = id;</span><br><span class="line">    <span class="keyword">this</span>.exports = &#123;&#125;;</span><br><span class="line">    <span class="keyword">this</span>.parent = parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个模块内部，都有一个 <code>module</code> 对象，代表当前模块，有以下属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">module.id           &#x2F;&#x2F; 模块标识符，通常是带有绝对路径的模块文件名</span><br><span class="line">module.filename     &#x2F;&#x2F; 模块文件名，带有绝对路径</span><br><span class="line">module.loaded       &#x2F;&#x2F; 布尔值，表示模块是否已经完成加载</span><br><span class="line">module.parent       &#x2F;&#x2F; 对象，表示调用该模块的模块</span><br><span class="line">module.children     &#x2F;&#x2F; 数组，表示该模块要用到的其他模块</span><br><span class="line">module.exports      &#x2F;&#x2F; 表示模块对外输出的值</span><br></pre></td></tr></table></figure><p>另外的，模块内部还有一个 <code>exports</code> 对象，它与 <code>module.exports</code> 指向同一块内存区域。</p><p><img src="https://bebopfzj.oss-cn-hangzhou.aliyuncs.com/uPic/2020-09-29-YbSBee.png" alt="CommonJS" /></p><p>不过，为了避免出错，还是建议使用 <code>module.exports</code> 导出，<code>require</code> 导入。如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// utils.js</span></span><br><span class="line"><span class="built_in">module</span>.exports.hello = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Hello, "</span> + name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">const</span> hello = <span class="built_in">require</span>(<span class="string">"./utils.js"</span>);</span><br></pre></td></tr></table></figure><p>如果你一定想要用 <code>exports</code>，那么你应当这样用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">exports.hello = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Hello, "</span> + name);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>不要直接对 <code>exports</code> 赋值，否则就是改变了其指向的内存地址。</p><h2 id="es6-的导入导出"><a class="markdownIt-Anchor" href="#es6-的导入导出"></a> ES6 的导入导出</h2><p>因为 <code>ES6</code> 的语法比较灵活，所以我们将其分情况介绍。</p><ul><li>使用 <code>export</code> 导出多个变量，并使用 <code>import {xxx} from &quot;yyy&quot;</code> 的语法来导入</li><li>使用 <code>export default</code> 导出一个变量，并使用 <code>import xxx from &quot;yyy&quot;</code> 的语法来导入</li></ul><p>如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// utils.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> name = <span class="string">"ShroXd"</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> hello = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Hello, "</span> + name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; name, hello &#125; <span class="keyword">from</span> <span class="string">"utils"</span>;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// utils</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Hello, "</span> + name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> hello;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> hello <span class="keyword">from</span> <span class="string">"utils"</span>;</span><br></pre></td></tr></table></figure><h1 id="静态结构特性"><a class="markdownIt-Anchor" href="#静态结构特性"></a> 静态结构特性</h1><p><code>ES6</code> 引入模块系统的一个原因就是启用静态结构。这意味着你可以在编译时就可以确定模块的导入和导出，而不必执行一遍代码。<br />另外的，你也只能在顶层进行导入和导出，且相关语句中没有动态成分。这也使得 <code>tree shaking</code> 成为可能。</p><p>更详细的内容，你可以参考 <a href="https://exploringjs.com/es6/ch_modules.html#static-module-structure" target="_blank" rel="noopener">文档</a>。</p><h1 id="webpack-4-的配置"><a class="markdownIt-Anchor" href="#webpack-4-的配置"></a> Webpack 4 的配置</h1><p>众所周知的是，有些代码会在导入时执行特殊行为。比如 <code>Vue</code> 中挂载全局实例等。这些代码在系统中扮演一定的功能，但却不会暴露 export。对于这种代码，我们称之为有副作用的代码。</p><p>为了告诉 <code>Webpack</code> 的 compiler 那些文件有副作用，我们可以通过配置 package.json 的 <code>sideEffects</code> 属性来实现。</p><p>简单来说，如果你的代码不包含任何副作用，那么我们可以简单地将其标注为 <code>false</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"your-project"</span>,</span><br><span class="line">    <span class="string">"sideEffects"</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果代码存在副作用，那么你需要提供一个数组，来标注那些有副作用的文件。需要注意的是，任何导入的文件都会受到 tree shaking 的影响。也就是说，如果你在项目中使用了 <code>css-loader</code>，那么就需要将其添加进 side effect 列表中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"your-project"</span>,</span><br><span class="line">    <span class="string">"sideEffects"</span>: [</span><br><span class="line">        <span class="string">"./src/some-side-effectful-file.js"</span>,</span><br><span class="line">        <span class="string">"*.css"</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从 webpack4 开始，如果将 <code>mode</code> 配置切换为 <code>production</code> 的话，就能直接切换到压缩输出。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">"path"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">"./src/index.js"</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">"bundle.js"</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">"dist"</span>),</span><br><span class="line">  &#125;,</span><br><span class="line">  mode: <span class="string">"production"</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>更详细的内容可以参考 webpack <a href="https://www.webpackjs.com/guides/tree-shaking/" target="_blank" rel="noopener">文档</a>，本文仅作为笔记</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 核心概念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> module </tag>
            
            <tag> 优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nodejs（二）—— Stream</title>
      <link href="/2020/09/29/NodejsStream/"/>
      <url>/2020/09/29/NodejsStream/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文是 <a href="https://www.freecodecamp.org/news/node-js-streams-everything-you-need-to-know-c9141306be93/" target="_blank" rel="noopener">Node.js Streams: Everything you need to know</a> 一文的笔记</p></blockquote><blockquote><p>流是 Nodejs 中最棒的，同时也是最被人误解的想法。<br />—— Dominic Tarr</p></blockquote><p>如果想要学习 <code>Nodejs</code>，那么 <em>流</em> 这个概念就是无法绕过的重点。在 <code>Nodejs</code> 中，很多内建模块都实现了流接口。例如常见的 <code>request</code>、<code>zlib</code> 等。<br />那么，<em>流</em> 到底是什么呢？<br />简单来说，流是一组数据的集合。但在使用它时，程序并不会一次性的将其载入内存中使用，而是逐端使用数据。显然，这种数据类型有助于处理大体积数据，或是从外部来源逐段发来的数据。对于后者，一个常见的例子就是处理 <code>WebStocket</code> 接口的时候。</p><a id="more"></a><h1 id="流的分类"><a class="markdownIt-Anchor" href="#流的分类"></a> 流的分类</h1><p>总的来说，在 <code>Nodejs</code> 中，流被分为四种基本类型：</p><ul><li>可读流。这是对一个可读取数据的源的抽象。例如 <code>fs.createReadStream</code> 方法</li><li>可写流。这是对一个可写入数据的源的抽象。例如 <code>fs.createWriteStream</code> 方法</li><li>双向流。这种既可以读，也可以写。例如 TCP stocket</li><li>变换流。首先，这是一种双向流。其次，它可以基于写入的数据生成可供读取的数据。例如 <code>zlib.createGzip</code> 方法</li></ul><h1 id="流的使用"><a class="markdownIt-Anchor" href="#流的使用"></a> 流的使用</h1><p>一般的，建议直接使用 <code>pipe</code> 来操作流，因为这是最简单的方式。不过如果你想以一种更加自定义的方式使用流，那么就得考虑使用事件了。<br />不过你应当避免混合使用这两者。</p><h2 id="pipe"><a class="markdownIt-Anchor" href="#pipe"></a> pipe</h2><p>这是 <code>Nodejs</code> 内建的使用流的方法。它可以自动帮你处理一些边界情况。例如错误、文件结尾、两个读/写速度不一致的流等。<br />简单来说，这个方法是这样使用的：</p><p>readableSource.pipe(writableDestination)</p><p><code>pipe</code>，也就是管道的上游必须是一个可读流，而下游则必须是一个可写流。不过，如果在中间的流是<code>双向流</code>或<code>变换流</code>，我们也可以连接多个流：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">readableSource</span><br><span class="line">  .pipe(transformStream1)</span><br><span class="line">  .pipe(transformStream2)</span><br><span class="line">  .pipe(finalWrtitableDestination);</span><br></pre></td></tr></table></figure><h2 id="流事件"><a class="markdownIt-Anchor" href="#流事件"></a> 流事件</h2><p>下面是一段简化的，使用事件来模拟 <code>pipe</code> 方法读取、写入数据的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">readable.on(<span class="string">"data"</span>, chunk =&gt; &#123;</span><br><span class="line">writable.write(chunk);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">readable.on(<span class="string">"end"</span>, () =&gt; &#123;</span><br><span class="line">writable.end()</span><br><span class="line">)&#125;;</span><br></pre></td></tr></table></figure><p>下面是一些使用可读流和可写流时用到的事件与方法：<br /><img src="https://bebopfzj.oss-cn-hangzhou.aliyuncs.com/uPic/2020-09-28-F5slkK.png" alt="流事件与方法" /></p><p>对于可读流来说，最重要的两个事件是：</p><ul><li><code>data</code> 事件，任何时候当可读流发送数据给它的消费者时，就会触发此事件</li><li><code>end</code> 事件，当可读流没有更多的数据要发送给消费者时，会触发此事件</li></ul><p>对于可写流来说，最重要的两个事件是：</p><ul><li><code>drain</code> 事件，这表示可写流可以接收更多数据</li><li><code>finish</code> 事件，这表示所有数据都被写入了</li></ul><h2 id="可读流的暂停与流动模式"><a class="markdownIt-Anchor" href="#可读流的暂停与流动模式"></a> 可读流的暂停与流动模式</h2><p>可读流有两种主要模式：<code>暂停模式</code>、<code>流动模式</code>。且流只能处于其中其一的一种模式。<br />所有可读流都默认为 <code>暂停模式</code>。不过你可以按需切换模式，且有时候这种切换回自动发生。</p><p>如果可读流处于暂停模式，那么我们可以使用 <code>read()</code> 方法来按需读取数据。<br />如果可读流处于流动模式，数据就会源源不断的流动，我们需要通过事件监听来处理数据。如果不这么做，那么数据就会丢失。</p><p>你可以使用 <code>resume()</code> 和 <code>pause()</code> 方法来切换流的模式。</p><p><img src="https://bebopfzj.oss-cn-hangzhou.aliyuncs.com/uPic/2020-09-28-EDzNtj.jpg" alt="可读流的两种模式" /></p><p>不过 <code>Nodejs</code> 为了兼容旧接口，对可读流的回调函数做了一些处理。也就是说，如果你在一个可读流上增加一个 <code>data</code> 事件回调，就可以将处于暂停模式的流切换到流动模式。同样的，如果你移除了这个回调，那么流就会被切换为暂停模式。</p><p>另外的，如果你使用 <code>pipe</code> 方法，它会自动帮你处理好这些事情。</p><h1 id="流的实现"><a class="markdownIt-Anchor" href="#流的实现"></a> 流的实现</h1><p>在讨论了流的使用之后，我们就应当转向流的实现了。通常的，我们会借助 <code>stream</code> 和 <code>require</code> 模块。</p><h2 id="实现一个可写流"><a class="markdownIt-Anchor" href="#实现一个可写流"></a> 实现一个可写流</h2><p>我们可以直接继承 <code>Writable</code> 类来实现可写流，不过更简单的办法是向 <code>Writable</code> 构造函数传入配置项来创建一个对象。在配置项中你 <strong>必须</strong> 实现 <code>write</code> 函数，这作为暴露一个写入数据的接口。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; Writable &#125; = <span class="built_in">require</span>(<span class="string">"stream"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// chunk - 通常是是一个 Buffer，除非进行了特殊配置</span></span><br><span class="line"><span class="comment">// encoding - 如果 chunk 不被配置为 buffer，那么你需要在这里配置编码</span></span><br><span class="line"><span class="comment">// callback - 完成数据处理后要执行的回调函数</span></span><br><span class="line"><span class="keyword">const</span> outStream = <span class="keyword">new</span> Writable(&#123;</span><br><span class="line">  write(chunk, encoding, callback) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"write: "</span> + chunk.toString());</span><br><span class="line">    callback();</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">process.stdin.pipe(outStream);</span><br></pre></td></tr></table></figure><h2 id="实现一个可读流"><a class="markdownIt-Anchor" href="#实现一个可读流"></a> 实现一个可读流</h2><p>和可写流一样，我们需要借助 <code>Readable</code> 类来实现。向构造函数传入配置项是一个很简单的构造方式。在这里，你需要实现 <code>read</code> 方法。这样可以在下游使用者要求时才 <strong>按需</strong> 推送信息。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; Readable &#125; = <span class="built_in">require</span>(<span class="string">"stream"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> inStream = <span class="keyword">new</span> Readable(&#123;</span><br><span class="line">  read(size) &#123;</span><br><span class="line">    <span class="keyword">this</span>.push(<span class="built_in">String</span>.fromCharCode(<span class="keyword">this</span>.currentCharCode++));</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.currentCharCode &gt; <span class="number">90</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.push(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">inStream.currentCharCode = <span class="number">65</span>;</span><br><span class="line">inStream.pipe(process.stdout);</span><br></pre></td></tr></table></figure><h2 id="实现双向流"><a class="markdownIt-Anchor" href="#实现双向流"></a> 实现双向流</h2><p>对于双向流，我们需要在同一个对象上同时实现可读流和可写流的接口。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; Duplex &#125; = <span class="built_in">require</span>(<span class="string">"stream"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> inoutStream = <span class="keyword">new</span> Duplex(&#123;</span><br><span class="line">  write(chunk, encoding, callback) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"write: "</span> + chunk.toString());</span><br><span class="line">    callback();</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  read(size) &#123;</span><br><span class="line">    <span class="keyword">this</span>.push(<span class="built_in">String</span>.fromCharCode(<span class="keyword">this</span>.currentCharCode++));</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.currentCharCode &gt; <span class="number">90</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.push(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">inoutStream.currentCharCode = <span class="number">65</span>;</span><br><span class="line">process.stdin.pipe(inoutStream).pipe(process.stdout);</span><br></pre></td></tr></table></figure><p>你需要注意，对于双向流，其读取和写入部分是完全独立的。它们只不过是同时实现在一个对象上罢了。</p><h2 id="实现变换流"><a class="markdownIt-Anchor" href="#实现变换流"></a> 实现变换流</h2><p>变换流需要我们实现 <code>transform</code> 方法，它结合了 <code>read</code> 和 <code>write</code> 方法的功能。其函数签名与 <code>write</code> 方法一致，所以我们也可以通过它 <code>push</code> 数据。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; Transform &#125; = <span class="built_in">require</span>(<span class="string">"stream"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> upperCaseTr = <span class="keyword">new</span> Transform(&#123;</span><br><span class="line">  transform(chunk, encoding, callback) &#123;</span><br><span class="line">    <span class="keyword">this</span>.push(chunk.toString().toUpperCase());</span><br><span class="line">    callback();</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">process.stdin.pipe(upperCaseTr).pipe(process.stdout);</span><br></pre></td></tr></table></figure><p>代码很清晰，<code>upperCaseTr</code> 作为一个中间介质，将输入流的字符转化为大写，并传递给下游输出流。</p><h1 id="流对象模式"><a class="markdownIt-Anchor" href="#流对象模式"></a> 流对象模式</h1><p>默认情况下，流接收的参数类型为 <code>Buffer</code> 或 <code>String</code>。我们可以通过设置 <code>objectMode</code> 参数使流可以接收任何 <code>JavaScript</code> 对象。</p><p>下面的例子用于把一个逗号分割的字符串转变成一个 <code>JavaScript</code> 对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; Transfrom &#125; = <span class="built_in">require</span>(<span class="string">"stream"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> commaSplitter = <span class="keyword">new</span> Transform(&#123;</span><br><span class="line">  readableObjectMode: <span class="literal">true</span>,</span><br><span class="line">  transform(chunk, encoding, callback) &#123;</span><br><span class="line">    <span class="keyword">this</span>.push(chunk.toString().trim().split(<span class="string">","</span>));</span><br><span class="line">    callback();</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arrayToObject = <span class="keyword">new</span> Transform(&#123;</span><br><span class="line">  readableObjectMode: <span class="literal">true</span>,</span><br><span class="line">  writableObjectMode: <span class="literal">true</span>,</span><br><span class="line">  transform(chunk, encoding, callback) &#123;</span><br><span class="line">    <span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; chunk.length; i += <span class="number">2</span>) &#123;</span><br><span class="line">      obj[chunk[i]] = chunk[i + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.push(obj);</span><br><span class="line">    callback();</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> objectToString = <span class="keyword">new</span> Transform(&#123;</span><br><span class="line">  writableObjectMode: <span class="literal">true</span>,</span><br><span class="line">  transform(chunk, encoding, callback) &#123;</span><br><span class="line">    <span class="keyword">this</span>.push(<span class="built_in">JSON</span>.stringify(chunk) + <span class="string">"\n"</span>);</span><br><span class="line">    callback();</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">process.stdin</span><br><span class="line">  .pipe(commaSplitter)</span><br><span class="line">  .pipe(arrayToObject)</span><br><span class="line">  .pipe(objectToString)</span><br><span class="line">  .pipe(process.stdout);</span><br></pre></td></tr></table></figure><h1 id="内置流的使用"><a class="markdownIt-Anchor" href="#内置流的使用"></a> 内置流的使用</h1><p><code>Node.js</code> 内置了很多有用的变换流，例如 <code>zlib</code> 和 <code>crypto</code> 。你可以将管道和事件组合使用。因为 <code>pipe</code> 会返回下游流，所以我们可以把注册事件回调的操作级联在一起：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line"><span class="keyword">const</span> zlib = <span class="built_in">require</span>(<span class="string">"zlib"</span>);</span><br><span class="line"><span class="keyword">const</span> file = process.argv[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">fs.createReadStream(file)</span><br><span class="line">  .pipe(zlib.createGzip())</span><br><span class="line">  .on(<span class="string">"data"</span>, () =&gt; process.stdout.write(<span class="string">"."</span>))</span><br><span class="line">  .pipr(fs.createWriteStream(file + <span class="string">".zz"</span>))</span><br><span class="line">  .on(<span class="string">"finish"</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">"Done"</span>));</span><br></pre></td></tr></table></figure><p>你还可以创建一个变换流来显示进度，这样的代码更加具有可读性：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line"><span class="keyword">const</span> zlib = <span class="built_in">require</span>(<span class="string">"zlib"</span>);</span><br><span class="line"><span class="keyword">const</span> file = processs.argv[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; Transform &#125; = <span class="built_in">require</span>(<span class="string">"stream"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> reportProgress = <span class="keyword">new</span> Transform(&#123;</span><br><span class="line">  transform(chunk, encoding, callbakc) &#123;</span><br><span class="line">    process.stdout.write(<span class="string">"."</span>);</span><br><span class="line">    <span class="comment">// 我们在这里使用 callback 传递数据</span></span><br><span class="line">    <span class="comment">// 这等效于 push 推送数据</span></span><br><span class="line">    callback(<span class="literal">null</span>, chunk);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">fs.createReadStream(file)</span><br><span class="line">  .pipe(zlib.createGzip())</span><br><span class="line">  .pipe(reportProgress)</span><br><span class="line">  .pipe(fs.createWriteStream(file + <span class="string">".zz"</span>))</span><br><span class="line">  .on(<span class="string">"finish"</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">"Done"</span>));</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> stream </tag>
            
            <tag> pipe </tag>
            
            <tag> 事件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nodejs（一）—— Buffer</title>
      <link href="/2020/09/29/NodejsBuffer/"/>
      <url>/2020/09/29/NodejsBuffer/</url>
      
        <content type="html"><![CDATA[<blockquote><p>参考：<a href="http://www.semlinker.com/node-buffer/#Node-js-Buffer" target="_blank" rel="noopener">深入学习 Node.js Buffer</a></p></blockquote><h1 id="关于-buffer"><a class="markdownIt-Anchor" href="#关于-buffer"></a> 关于 Buffer</h1><p><code>Buffer</code> 是 <code>Node.js</code> 的核心模块，它使得开发者可以在 <code>TCP</code> 流或是文件系统操作等场景中处理二进制数据。<br /><code>Buffer</code> 的大小是固定的，且无法调整。它在 <code>V8</code> 堆外分配物理内存。</p><blockquote><p>V8 是一个由 Google 开发的开源 JavaScript 引擎，用于 Google Chrome 及 Chromium 中。</p></blockquote><p>常见的应用是在 <code>流</code> 中使用。流是一组数据的集合。在一般情况下，流的生产者和消费者的速度是不一致的，所以我们需要 <code>Buffer</code> 来缓存数据。</p><a id="more"></a><h1 id="buffer-的基本使用"><a class="markdownIt-Anchor" href="#buffer-的基本使用"></a> Buffer 的基本使用</h1><p>下面的代码展示了一些 <code>Buffer</code> 的基本使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个长度为 10、且用 0x1 填充的 Buffer</span></span><br><span class="line"><span class="comment">// 若无填充参数，则填充数字为 0</span></span><br><span class="line"><span class="keyword">const</span> buf1 = Buffer.alloc(<span class="number">10</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个长度为 10，且未初始化的 Buffer</span></span><br><span class="line"><span class="keyword">const</span> buf2 = Buffer.allocUnsafe(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个包含 [0x1, 0x2, 0x3] 的 Buffer。</span></span><br><span class="line"><span class="keyword">const</span> buf4 = Buffer.from([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个包含 UTF-8 字节 [0x74, 0xc3, 0xa9, 0x73, 0x74] 的 Buffer。</span></span><br><span class="line"><span class="keyword">const</span> buf5 = Buffer.from(<span class="string">"tést"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个包含 Latin-1 字节 [0x74, 0xe9, 0x73, 0x74] 的 Buffer。</span></span><br><span class="line"><span class="keyword">const</span> buf6 = Buffer.from(<span class="string">"tést"</span>, <span class="string">"latin1"</span>);</span><br></pre></td></tr></table></figure><p>你可能会在一些教程中看到可以这样创建：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> buf = <span class="keyword">new</span> Buffer(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>你需要注意，在 <code>Node.js</code> 8.0.0 之前，这种方式创建的 <code>Buffer</code> 实例持有的内存是 <strong>没有</strong> 初始化的，且 <strong>可能包含敏感数据</strong>。在 8.0.0 之后，这种方式将返回一个初始化后的 <code>Buffer</code>。</p><p>当你调用 <code>Buffer.allocUnsafe()</code> 和 <code>Buffer.allocUnsafeSlow()</code> 方法，被分配的内存段是未初始化的，这可以加速分配内存的速度，具有明显的性能优势。<br />到底是创建一个快速但未初始化的 <code>Buffer</code>，还是创建一个慢点但更安全的 <code>Buffer</code>，这需要根据实际情况做出选择。</p><p>关于更多的 <code>Buffer</code> 常用 api 的总结，你可以参考官方文档或是 <a href="https://www.cnblogs.com/chyingp/p/nodejs-learning-buffer.html" target="_blank" rel="noopener">这篇文章</a></p><h1 id="typedarray"><a class="markdownIt-Anchor" href="#typedarray"></a> TypedArray</h1><p>事实上，<code>Node.js</code> 中的 <code>Buffer</code> 和 <code>es6</code> 中的 <code>TypedArray</code> 是有很多联系的。<br />这种 <code>类型化数组(TypedArrya)</code> 描述了一个底层的二进制数据缓冲区的一个类数组视图。不过你需要注意，并没有 <code>TypedArray</code> 的全局属性，这指的是一组类型化数组。</p><p>这些类型数组包含以下这些内容：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Int8Array</span>();</span><br><span class="line"><span class="built_in">Uint8Array</span>();</span><br><span class="line"><span class="built_in">Uint8ClampedArray</span>();</span><br><span class="line"><span class="built_in">Int16Array</span>();</span><br><span class="line"><span class="built_in">Uint16Array</span>();</span><br><span class="line"><span class="built_in">Int32Array</span>();</span><br><span class="line"><span class="built_in">Uint32Array</span>();</span><br><span class="line"><span class="built_in">Float32Array</span>();</span><br><span class="line"><span class="built_in">Float64Array</span>();</span><br></pre></td></tr></table></figure><p>你可以这样使用 <code>TypeArray</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> TypedArray();</span><br><span class="line"><span class="keyword">new</span> TypedArray(length);</span><br><span class="line"><span class="keyword">new</span> TypedArray(typedArray);</span><br><span class="line"><span class="keyword">new</span> TypedArray(object);</span><br><span class="line"><span class="keyword">new</span> TypedArray(buffer, [, byteOffset [, length]]);</span><br></pre></td></tr></table></figure><p>你可以查阅 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypedArray" target="_blank" rel="noopener">mozilla 文档</a> 了解更多相关内容。</p><p>如果你期望从一个 <code>Buffer</code> 创建一个新的 <code>TypedArray</code> 实例，那么你需要注意以下两点：</p><ul><li><code>Buffer</code> 对象的内存是复制到 <code>TypedArray</code> 的，而非共享</li><li><code>Buffer</code> 对象的内存会被解析为一个明确元素的数组，而非一个目标类型的字节数组。</li></ul><p>下面这句</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Uint32Array</span>(Buffer.from([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]));</span><br></pre></td></tr></table></figure><p>会被创建为一个包含 <code>[1, 2, 3, 4]</code> 四个元素的 <code>Unit32Array</code>，而不是一个只白喊一个元素的 <code>Unit32Array</code>.</p><p>另外的，也可以通过 <code>TypedArray</code> 对象的 <code>.buffer</code> 属性创建一个新建的且与 <code>TypedArray</code> 实例共享同一分配内存的 <code>Buffer</code>。</p>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> buffer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SwiftUI 中的属性包装器</title>
      <link href="/2020/08/30/state/"/>
      <url>/2020/08/30/state/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文翻译自 <a href="https://levelup.gitconnected.com/state-vs-stateobject-vs-observedobject-vs-environmentobject-in-swiftui-81e2913d63f9" target="_blank" rel="noopener">SwiftUI: @State vs @StateObject vs @ObservedObject vs @EnvironmentObject</a></p></blockquote><p><code>SwiftUI</code> 开发者们需要做的第一个决定就是，应该选择哪个有效的属性包装器来存储数据。特别是在 IOS 14 中，<a href="https://developer.apple.com/documentation/swiftui/app" target="_blank" rel="noopener">整个应用的生命周期</a> 都可以使用 <code>SwiftUI</code> 来开发，用正确的方式存储应用的数据是确保应用正常运行，避免 bug 的前提。</p><p>在使用 <code>SwiftUI</code> 制作 app 时，一个坑就是 <code>@State</code>，<code>@StateObject</code>，<code>@ObservedObject</code>，<code>@EnvironmentObject</code> 这几个属性包装器从表面上来看，都是能够运行的。应用程序会被正常编译，甚至还能得到你想要的行为，即使你用错了属性包装器。<s>又不是不能用</s></p><p>但是，假如用错了，你可能会发现当你更新数据时，UI 却不会随之正常更新。</p><p>那么在这篇文章里，我们就来解决这些问题。我们先从 <code>@State</code> 开始。</p><a id="more"></a><h1 id="state"><a class="markdownIt-Anchor" href="#state"></a> @State</h1><blockquote><p>State: A property wrapper type that can read and write a value managed by SwiftUI.</p></blockquote><p>这是苹果关于 <code>@State</code> 的 <a href="https://developer.apple.com/documentation/swiftui/state" target="_blank" rel="noopener">定义</a>，但这是啥意思呢？</p><p><code>@State</code> 是你的 APP 可以拥有的最简单的数据来源。它被设计为仅包含简单的数据类型，例如 <code>Int</code>、<code>String</code>、<code>Bool</code>。它并不被设计用来存储复杂的、引用类型的数据，例如自定义的 <code>Class</code> 或者 <code>Struct</code>，并且将它们用于 APP</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// THIS IS GOOD</span></span><br><span class="line">@<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> isPlaying = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// THIS IS BAD</span></span><br><span class="line">@<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> isPlaying = <span class="type">IsPlaying</span>()</span><br></pre></td></tr></table></figure><p>苹果甚至 <a href="https://developer.apple.com/documentation/swiftui/managing-user-interface-state" target="_blank" rel="noopener">这么说过</a> —— 当你在将值添加到模型前，它们非常简单时，使用 State</p><p><em>You might also find this kind of storage convenient while you prototype, before you’re ready to make changes to your app’s data model.</em></p><p><code>@State</code> 会在任何视图数据更新时重新计算它。所以如果如果你的视图有一个状态，这个状态跟踪一个数字变量。当你为这个变量增加 1 时，State 将会看到并且重新编译视图。因为视图使用这个 State，所以你将会看到屏幕上的数据被刷新了。</p><p>就像我之前说的那样，这东西被用来描述简单的数据类型，例如数字、字符串或者布尔值。然而，如果你把 <code>@State</code> 用在了复杂对象上，你发现这也是可以的。在后续的文章中，我会多次使用下面这个对象作为例子：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> num: <span class="type">Int</span> = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是我如何使用它：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StateTestView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    @<span class="type">State</span> <span class="keyword">var</span> state = <span class="type">TestObject</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: some view &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">            <span class="type">Test</span>(<span class="string">"State: \(state.num)"</span>)</span><br><span class="line">            <span class="type">Button</span>(<span class="string">"Increase state"</span>) &#123;</span><br><span class="line">                state.num += <span class="number">1</span></span><br><span class="line">                <span class="built_in">print</span>(<span class="string">"State: \(state.num)"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        .onChange(of: state.num) &#123; newState <span class="keyword">in</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"State: \(newState)"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码并不会抛出错误。我就创建了一个 <code>TestObject()</code> 的复制，然后使用 <code>@State</code> 来包装。这告诉 <code>SwiftUI</code> 我想让视图追踪这个数据。</p><p>当我调用这段代码，点击按钮的时候，你可以看到输出窗口出现了加和的日志，但是 app 里的视图却没有发生任何变化，为啥嘞？</p><p><img src="https://bebopfzj.oss-cn-hangzhou.aliyuncs.com/uPic/2020-08-30-WhLJkH.gif" alt="output" /></p><p>让我们回头看看之前写的：</p><blockquote><p>@State works by re-computing the body variable of your view any time it updates.</p></blockquote><p>但是，因为我们使用了复杂、引用类型的数据，<code>state</code> 本身并不会改变。因为 <code>num</code> 是作为 <code>state</code> 的属性的，<code>@State</code> 属性包装器只知道它监视的数据有没有变化，而没法追踪监视对象的属性。所以视图当然也就不会被重新编译了。</p><p>这将导致我们可以看到控制台中值顺利的更新了，但是视图的 <code>body</code> 变量没有被重新计算，所以我们也当然看不到 UI 界面更新了。这也会导致 <code>onChange</code> 方法绝对不会被调用。因为它观察的是 <code>body</code> 变量的变化。变量不变化，它也就当然不会被调用了。</p><p>所以，我们也就知道了，<code>@State</code> 并不是一劳永逸的东西，对于复杂一些的数据它就无能为力了。比如跟踪某个数据是否可以在屏幕上可见，或是高亮显示某个行号等场景还是可以的，但是对于一些更复杂的，就得用其他办法了。</p><h1 id="stateobject"><a class="markdownIt-Anchor" href="#stateobject"></a> @StateObject</h1><p>根据苹果的介绍，<code>@StateObject</code> 是：</p><blockquote><p>A type of object with a publisher that emits before the object has changed.</p></blockquote><p>这啥意思啊。我们还是回到 <code>TestObject</code> 的例子，但是创建为 <code>ObservableObject</code> 类型的：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestObject</span>: <span class="title">ObservableObject</span> </span>&#123;</span><br><span class="line">    @<span class="type">Published</span> <span class="keyword">var</span> num: <span class="type">Int</span> = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里主要有两个变化：</p><ol><li><code>TestObject</code> 现在遵循 <code>ObservableObject</code> 协议</li><li>我们用 <code>@Published</code> 属性包装器标记了 <code>num</code></li></ol><p>总而言之，我们就是想当 <code>num</code> 更新的时候，<code>ObservableObject</code> 的任何用户都能知道应该重新编译界面了。</p><p>让我们再回到之前的示例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StateObjectTestView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    @<span class="type">StateObject</span> <span class="keyword">var</span> stateObject = <span class="type">TestObject</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">            <span class="type">Test</span>(<span class="string">"State object: \(stateObject.num)"</span>)</span><br><span class="line">            <span class="type">Button</span>(<span class="string">"Increase state object"</span>) &#123;</span><br><span class="line">                stateObject.num += <span class="number">1</span></span><br><span class="line">                <span class="built_in">print</span>(<span class="string">"State object: \(stateObject.num)"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        .onChange(of: stateObject.num) &#123; newStateObject <span class="keyword">in</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"State: \(newStateObject)"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正如你看到的那样，我就做了一点微小的工作。将 <code>@State</code> 换成了 <code>@StateObject</code>。使用这个属性包装器需要被包装的对象是 <code>ObservableObject</code> 类型的。正好我们之前已经做了。</p><p>现在，当我点击按钮，我们不仅可以看到控制台输出了新的值，UI 界面也同时随之更新了。</p><p><img src="https://bebopfzj.oss-cn-hangzhou.aliyuncs.com/uPic/2020-08-30-DB3aOl.gif" alt="@StateObject" /></p><p>这是因为，通过使用 <code>@StateObject</code>，我们可以让可观测对象的任何一个标注了 <code>@Published</code> 的属性在变化是，就去更新视图。换句话说，只要我更新了 <code>num</code>，因为它是用 <code>@Published</code> 标注的，视图也会随之更新。</p><p>我们不会遇到在使用 <code>@State</code> 时遇到的问题了，因为现在我们不仅仅是监视对象，还监视对辽中任何标注了 <code>@Published</code> 包装器的属性。真不错~</p><p>另外一个关于 <code>@StateObject</code> 需要注意的是，被标注的对象是直接绑定于视图上的。也就是说，加入你通过 <a href="https://developer.apple.com/documentation/swiftui/navigationlink" target="_blank" rel="noopener">NavigationLink</a> 进入了界面，将 <code>num</code> 的值设置为 3，回到 <code>NavigationView</code> 然后再进入视图，<code>num</code> 的值会被重置为 0。事实上，整个 <code>TestObject</code> 对象都会被重建。</p><p>尽管重置数据听起来很麻烦，不过这正是我们需要的。如果我们需要在父视图中使用数据，那么就在父视图里定义 <code>@StateObject</code> 包裹的数据。如果我们在子视图中使用数据，那么就去子视图里定义 <code>@StateObject</code> 包裹的数据。</p><p>使用这个办法，我们可以保证在视图活跃的时候，数据不会被改变或者释放。正如苹果在他们文档里提到的那样，这是实例化复杂数据的正确方法。</p><p>接下来的俩方法是使用已经实例化为 <code>@StateObject</code> 的复杂对象。</p><h1 id="observedobject"><a class="markdownIt-Anchor" href="#observedobject"></a> @ObservedObject</h1><p>苹果在 <a href="https://developer.apple.com/documentation/combine/observableobject" target="_blank" rel="noopener">文档</a> 里是这么描述的：</p><blockquote><p>A type of object with a publisher that emits before the object has changed.</p></blockquote><p>这描述几乎和 <code>@StateObject</code> 一毛一样，除了没有提到实例化或者创建变量。</p><p>这是因为 <code>@ObservedObject</code> 是用来跟踪 <strong>已经</strong> 创建了的对象，这个对象可能用了 <code>@StateObject</code>。</p><p>如果你希望将一个 Observable Object 从一个视图传送到另一个视图的话，你可以使用 <code>@ObservedObject</code>。你已经将可观测对象在父视图实例化，并且使用 <code>@StateObject</code> 包裹了，现在你期望子视图也可以访问到里面的数据。但你不想再次创建对象，因为这将不会再对象中保留任何在父视图中写入的数据。</p><p>相反的，你希望传递一个已经存在的可观测对象到子视图中去。想要做成这个，你需要将其用 <code>@ObservedObject</code> 包裹，通过 <code>NavigationLink</code> 像这样传递下去：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">NavigationLink</span>(<span class="string">"To Child"</span>, destination: <span class="type">ChildView</span>(observedObject: stateObject))</span><br></pre></td></tr></table></figure><p>然后，子视图像这样访问数据：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ChildView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    @<span class="type">ObservedObject</span> <span class="keyword">var</span> observedObject: <span class="type">TestObject</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">            <span class="type">Text</span>(<span class="string">"ObservedObject: \(observedObject.num)"</span>)</span><br><span class="line">            <span class="type">Button</span>(<span class="string">"Increase observedObject"</span>) &#123;</span><br><span class="line">                observedObject.num += <span class="number">1</span></span><br><span class="line">                <span class="built_in">print</span>(<span class="string">"ObservedObject \(observedObject.num)"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正如你看到的，<code>ChildView</code> 有一个使用 <code>@ObservedObject</code> 包裹的属性，它接收一个 <code>TestObject</code> 类型的对象。它并不重新实例化一个对象，而是在父视图读写过的数据上继续读写。</p><p>但是，如果很多子视图都需要访问相同的数据，你可能不希望将它们都传递给各个子视图。例如你可能想在应用中很多页面都展示用户名，但你并不想将 <code>UserDetails</code> 传递给各个子视图。</p><p>那么，给你安利 <code>@EnvironmentObject</code></p><h1 id="environmentobject"><a class="markdownIt-Anchor" href="#environmentobject"></a> @EnvironmentObject</h1><p>这个属性包裹器是为了解决这样的场景的：加入你期望使用一个 <code>ObservableObject</code> 对象，但是涉及的视图并不是严格的父子视图对。你可能希望在主视图使用一小部分数据，同时在层级很深的设置页面也使用一部分。但你并不想（同时也不需要）将数据分别传递给每个视图——拜托，这样写出来的代码是真的恶心。</p><p>这是苹果官方建议的解决方案，在 <a href="https://developer.apple.com/videos/play/wwdc2020/10040/" target="_blank" rel="noopener">WWDC 的视频</a> 里也能看到：</p><p><img src="https://bebopfzj.oss-cn-hangzhou.aliyuncs.com/uPic/2020-08-30-JF6bEK.png" alt="WWDC 截图" /></p><p>在这张图里，<code>ObservableObject</code> 在第一张视图就创建了，但是在其改变的时候，同时也希望比较深层级的视图也能感知到。</p><p>在使用 <code>@EnvironmentObject</code> 时，有两个需要注意的地方。</p><p>首先，你需要创建一个将要使用的对象。这之后，你需要在一个视图中使用它，以便于其所有的子视图都能访问。让我们从这里开始：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@main</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TestApp</span>: <span class="title">App</span> </span>&#123;</span><br><span class="line">    @<span class="type">StateObject</span> <span class="keyword">var</span> environmentObject = <span class="type">TestObject</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">Scene</span> &#123;</span><br><span class="line">        <span class="type">WindowGroup</span> &#123;</span><br><span class="line">            <span class="type">ContentView</span>().environmentObject(environmentObject)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以看到，我先创建了对象，然后在稍候就将其引用到了视图中。你要注意的是，所有的工作都在主视图文件中完成。假如你期望某些数据在整个 app 中都能使用，那么这就是一种常见的模式。</p><p>然后，你就可以在 <code>ContentView</code> 中任何视图使用这个对象了。比如这样做：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@<span class="type">EnvironmentObject</span> <span class="keyword">var</span> environmentObject: <span class="type">TestObject</span></span><br></pre></td></tr></table></figure><p>就用法来说，这和 <code>@ObservedObject</code> 一样。只不过这次我们期望在整个 <strong>环境</strong> 中使用，而不是从直接父视图中传递。</p><p><code>@EnvironmentObject</code> 的工作方式是，当你在视图中使用它是，它会去环境中寻找那个对象（换句话说，从任何父视图中寻找指定了该属性包装器的对象），然后让你使用它。这是在运行时完成的，而不是在编译时，所以如果你没有正确的设置环境对象，应用程序将会崩溃。</p><p>另一个需要注意的是，<code>@EnvironmentObject</code> 寻找的是对应类型的对象。所以你不要在视图树中实现多个用该属性包裹器包裹的、相同类型的对象。</p><p><code>@EnvironmentObject</code> 非常方便，当你的对象被多个视图引用的时候，这就是一个很牛批的工具。</p><h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1><ol><li>像 <code>Int</code>，<code>String</code>，<code>Bool</code> 这样的简单数据，你可以使用 <code>@State</code>。比如决定开关状态，或者 dialog 的开关的数据。</li><li>对于稍微复杂一些的数据，你就得使用 <code>@StateObject</code>。确保数据类型符合 <code>ObservableObject</code> 协议并且使用 <code>@Published</code> 包裹了你想要监控的属性。<strong>在实例化数据模型时，总是使用 <code>@StateObject</code> 注释</strong></li><li>使用 <code>@ObservedObject</code> 允许父视图可以将一个已经创建的 <code>ObservableObject</code> 传递给子视图。</li><li>使用 <code>@EnvironmentObject</code> 注释一个已经在父视图创建了的 <code>ObservableObject</code> ，同时通过视图的 <code>environmentObject()</code> 修饰符附加上去。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IOS </tag>
            
            <tag> SwiftUI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>响应式编程与Combine（四）</title>
      <link href="/2020/08/29/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B%E4%B8%8ECombine4/"/>
      <url>/2020/08/29/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B%E4%B8%8ECombine4/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文翻译自 <a href="https://www.vadimbulavin.com/error-handling-in-swift-combine-framework/" target="_blank" rel="noopener">Error Handling in Swift Combine Framework</a>，稍作修改</p></blockquote><h1 id="错误处理策略"><a class="markdownIt-Anchor" href="#错误处理策略"></a> 错误处理策略</h1><p>在计算机编程中，错误是不可避免的。我们不可能要求一段程序永远不出错，但我们需要一些手段来让程序可以尽快的从错误中恢复过来。让我们看看在 <code>Combine</code> 框架中该怎么处理。</p><h2 id="终止-app"><a class="markdownIt-Anchor" href="#终止-app"></a> 终止 APP</h2><p>最直接的错误处理就是不处理错误。当然了，我们不可能将这样的代码直接交付给客户。不过在开发过程中，这个策略是很有用的。我们希望在开发中应用越早崩溃越好，这样我们才能发现代码中的错误。<br />另外，这里还有两个不需要担心错误处理的场景：</p><ul><li>在编写实验代码时</li><li>在教授或者学习时</li></ul><p><code>Combine</code> 为这个目的提供了 <code>assertNoFailure(_ : file : line :)</code> 方法。它会在前一个 <code>Publisher</code> 发出错误前停止 app，通知打印调试信息帮助你解决问题。</p><blockquote><p>如果你确定在你的流中不会出现出错，你可以把发布者的 <code>Failure</code> 类型设置为 <code>Never</code>。它在语法上禁止错误，它比 <code>assertNoFailure(_ : file : line :)</code> 安全得多，后者可能会使你的 app 崩溃</p></blockquote><a id="more"></a><h2 id="为错误提供后路"><a class="markdownIt-Anchor" href="#为错误提供后路"></a> 为错误提供后路</h2><p>当然了，次次都以失败来停止 <code>Combine</code> 有点太极端了，况且在这之后也不能处理任何事件了。在某些场景下，错误是肯定会出现的。比如搜索了一个不存在的数据，比如网络连接特别差，或者是文本中输入了非法字符。从经验上来说，如果预期的错误对流并不致命，我们经常期望代码可以从错误中恢复过来。执行这些操作的策略是：捕获、替代、重试和忽略。<br />接下来我们详细讨论一下。</p><h3 id="捕获和替换错误"><a class="markdownIt-Anchor" href="#捕获和替换错误"></a> 捕获和替换错误</h3><p><code>catch(_ :)</code> 方法提供了一种将失败的发布者替换为另一个发布者的方法。一般情况下，你可以捕获错误并将其替换为某种占位数据。例如：</p><ol><li>将数据加载错误替换为空数据集</li><li>将图片加载失败替换为占位图片</li><li>将用户名加载失败替换为 “unknown”</li></ol><p><code>replaceError(with :)</code> 方法的行为和 <code>catch(_ :)</code> 很相似，只不过它会将错误替换为新元素，而不是创建一个新的发布者。<br />我们用下面这段代码来展示它们之间的区别：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DummyError</span>: <span class="title">Error</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="type">Just</span>(<span class="number">1</span>)</span><br><span class="line">    .tryMap &#123; <span class="number">_</span> <span class="keyword">in</span> <span class="keyword">throw</span> <span class="type">DummyError</span>() &#125;</span><br><span class="line">    .<span class="keyword">catch</span> &#123; <span class="number">_</span> <span class="keyword">in</span> <span class="type">Just</span>(<span class="number">2</span>) &#125;</span><br><span class="line">    .sink &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="type">Just</span>(<span class="number">1</span>)</span><br><span class="line">    .tryMap &#123; <span class="number">_</span> -&gt; <span class="type">Int</span> <span class="keyword">in</span> <span class="keyword">throw</span> <span class="type">DummyError</span>() &#125;</span><br><span class="line">    .replaceError(with: <span class="number">2</span>)</span><br><span class="line">    .sink &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;</span><br></pre></td></tr></table></figure><p>两个流都会打印 2，但原理却不一样：</p><ol><li><code>catch</code> 捕获了当前的 Publisher，然后将其替换为一个全新的 Publisher，这个新的 Publisher 产出了值 2</li><li><code>replaceError</code> 将错误替换成了一个值 2</li></ol><h3 id="重试错误"><a class="markdownIt-Anchor" href="#重试错误"></a> 重试错误</h3><p>重试依据给定的重试次数重新创建订阅来尝试。在耗尽所有重试次数之后，就会向下游产出一个错误。</p><blockquote><p><code>catch</code> 试图在 <strong>下游</strong> 修复错误，而<code>retry</code> 则试图在 <strong>上游</strong> 修复错误</p></blockquote><p>通常我们都重试发布者，期望它能顺利完成。一些这样的例子是：网络连接，用户输入具有验证规则的字段。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> url = <span class="type">URL</span>(string: <span class="string">"https://www.vadimbulavin.com"</span>)</span><br><span class="line"></span><br><span class="line"><span class="type">URLSession</span>.shared.dataTaskPublisher(<span class="keyword">for</span>: url!)</span><br><span class="line">    .retry(<span class="number">3</span>)   <span class="comment">// 重试次数为 3</span></span><br><span class="line">    .receive(on: <span class="type">DispatchQueue</span>.main)</span><br><span class="line">    .sink(</span><br><span class="line">        receiveCompletion: &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;,</span><br><span class="line">        receiveValue: &#123; <span class="number">_</span> <span class="keyword">in</span> &#125;</span><br><span class="line">    )</span><br></pre></td></tr></table></figure><h3 id="映射错误"><a class="markdownIt-Anchor" href="#映射错误"></a> 映射错误</h3><p>基础架构层是最常见的错误来源。然而这些错误都太底层了，需要转换为高层的，应用程序语言的额错误。</p><blockquote><p>在 <a href="https://www.vadimbulavin.com/layered-architecture-ios/" target="_blank" rel="noopener">Layered Architecture</a> 中我们讨论了 app 分层的重要性，解释的层的设计，和其信息传递。</p></blockquote><p>为了做到这个，我们需要一个方法，将底层的错误，例如 <em>HTTP 404 Not Found Error</em> 转化为对应用程序有意义的错误。<code>Combine</code> 提供了 <code>mapError(_ :)</code> 方法来进行转换。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">APIError</span>: <span class="title">Error</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> userIsOffline</span><br><span class="line">    <span class="keyword">case</span> somethingWentWrong</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="keyword">let</span> errorPubliser = <span class="type">Result</span>&lt;<span class="type">Int</span>, <span class="type">Error</span>&gt;.<span class="type">Publisher</span>(<span class="type">URLError</span>(.notConnectedToInternet))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line">errorPublisher</span><br><span class="line">    .mapError &#123; error -&gt; <span class="type">APIError</span> <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">switch</span> error &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="type">URLError</span>.notConnectedToInternet:</span><br><span class="line">                <span class="keyword">return</span> .userIsOffline</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> .somethingWentWrong</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    .sink(</span><br><span class="line">        receiveCompletiom: &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;,</span><br><span class="line">        receiveValue: &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;</span><br><span class="line">    )</span><br></pre></td></tr></table></figure><ol><li>声明定制好的错误类型</li><li>创建一个 <code>Result</code> 发布者，它以一个 <code>URLError</code> 错误结束</li><li>订阅这个发布者，将泛型错误转化为 <code>APIError</code></li></ol><blockquote><p>和 <code>Just</code> 类似，<code>Result</code> 发布者也是提交一个元素就完成。它们之间的区别是，前者肯定成功，后者则可能会失败</p></blockquote><p>上面这段代码会打印：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">failure(... APIError.userIsOffline)</span><br></pre></td></tr></table></figure><h2 id="抛出错误"><a class="markdownIt-Anchor" href="#抛出错误"></a> 抛出错误</h2><p><code>Combine</code> 有一些 <code>try</code> 前缀的算子，它们接收一个可能产出错误的闭包，然后返回一个新的发布者。如果闭包产出错误，那么发布者将会以失败结束。</p><p>这样的方法有：<code>tryMap(_ :)</code>，<code>tryFilter(_ :)</code>，<code>tryScan(_ : _ :)</code>。</p><h2 id="关于错误处理的总结"><a class="markdownIt-Anchor" href="#关于错误处理的总结"></a> 关于错误处理的总结</h2><p>总的来说，我们在遇到错误时，可以采取以下几种措施：</p><ul><li>使用 <code>assertNoFailure(_ : file : line :)</code> 来直接结束 app，这在开发和调试时都很有用</li><li>使用 <code>replaceError(with :)</code> 来将失败的发布者替换为一个值</li><li>使用 <code>catch(_ :)</code> 将失败的发布者替换为一个新的发布者</li><li>使用 <code>retry(_ :)</code> 来为你的订阅提供第二个机会</li></ul><p>你可以使用 <code>mapError(_ :)</code> 来将一个错误转换为另一个错误。</p><h1 id="调试-combine-代码"><a class="markdownIt-Anchor" href="#调试-combine-代码"></a> 调试 Combine 代码</h1><p>讨论调试方法，主要是因为 <code>Combine</code> 在实现这些炫酷的函数响应式编程范式的时候，很多特性都被埋藏在了实现中。传统的断点调试可能很难起效。当然了，打印大法依旧香。</p><h2 id="阅读控制台日志"><a class="markdownIt-Anchor" href="#阅读控制台日志"></a> 阅读控制台日志</h2><p>最简单的办法就是将事件流打印到控制台，然后跟踪日志就完事了。<code>Combine</code> 提供了两种完成这个事情的方法：<code>handleEvents()</code> 和 <code>print()</code>。两者都是非侵入性的，不会向流引入任何副作用。</p><p>给定一个发布者，它可以将数字转为正方形。我们用这个例子展示一下如何操作：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> squares = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].publisher</span><br><span class="line">    .<span class="built_in">map</span> &#123; $<span class="number">0</span> * $<span class="number">0</span> &#125;</span><br><span class="line">    .sink &#123; <span class="number">_</span> <span class="keyword">in</span> &#125;</span><br></pre></td></tr></table></figure><p>然后我们将 <code>print()</code> 算子加入到流中：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> squares = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].publisher</span><br><span class="line">    .<span class="built_in">print</span>(<span class="string">"Squares"</span>)</span><br><span class="line">    .<span class="built_in">map</span> &#123; $<span class="number">0</span> * $<span class="number">0</span> &#125;</span><br><span class="line">    .sink &#123; <span class="number">_</span> <span class="keyword">in</span> &#125;</span><br></pre></td></tr></table></figure><p>这将会打印：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Squares: receive subscription: ([1, 2, 3])</span><br><span class="line">Squares: request unlimited</span><br><span class="line">Squares: receive value: (1)</span><br><span class="line">Squares: receive value: (2)</span><br><span class="line">Squares: receive value: (3)</span><br><span class="line">Squares: receive finished</span><br></pre></td></tr></table></figure><p><code>print()</code> 会打印传递的元素和重要的订阅事件。它接收两个参数：前缀和输出。<br />第一个参数如上面例子所示，这可以帮助你阅读输出日志，不然你可能很快就看花眼了。<br />第二个参数是 <code>TextOutputStream</code> 的一个实例。你可以提供一个定制的实现来转换或者重定向日志信息。例如增加时间戳或者将其写入文件。它默认是标准输出。</p><p><code>print()</code> 经常提供特别多的输出，而 <code>handleEvents()</code> 就可以控制应该记录那些的日志。它允许拦截发布者-订阅者生命周期中任何重大事件：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> squares = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].publisher</span><br><span class="line">    .handleEvents(</span><br><span class="line">        receiveSubscription: &#123; <span class="built_in">print</span>(<span class="string">"Receive subscription: \($0)"</span>) &#125;,</span><br><span class="line">        receiveOutput: &#123; <span class="built_in">print</span>(<span class="string">"Receive output: \($0)"</span>) &#125;,</span><br><span class="line">        receiveCompletion: &#123; <span class="built_in">print</span>(<span class="string">"Receive completion: \($0)"</span>)&#125;,</span><br><span class="line">        receiveCancel: &#123; <span class="built_in">print</span>(<span class="string">"Receive cancel"</span>) &#125;,</span><br><span class="line">        receiveRequest: &#123; <span class="built_in">print</span>(<span class="string">"Receive request: \($0)"</span>) &#125;</span><br><span class="line">    )</span><br><span class="line">    .<span class="built_in">map</span> &#123; $<span class="number">0</span> * $<span class="number">0</span>&#125;</span><br><span class="line">    .sink &#123; <span class="number">_</span> <span class="keyword">in</span> &#125;</span><br></pre></td></tr></table></figure><p>这将会打印：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Receive request: unlimited</span><br><span class="line">Receive subscription: [1, 2, 3]</span><br><span class="line">Receive output: 1</span><br><span class="line">Receive output: 2</span><br><span class="line">Receive output: 3</span><br><span class="line">Receive completion: finished</span><br></pre></td></tr></table></figure><p>尽管输出看起来一样，但是 <code>handleEvents()</code> 方法可以让你做一些自定义的控制：</p><ul><li>略去我们不感兴趣的事件</li><li>手动设置断点</li><li>基于事件工作</li></ul><h2 id="生成-xcode-调试断点"><a class="markdownIt-Anchor" href="#生成-xcode-调试断点"></a> 生成 Xcode 调试断点</h2><p>如果你已经打印了日志但还是找不到 bug，那么就是时候求助于调试器了。<code>Combine</code> 提供了两种方法来完成这个需求：</p><ul><li><code>breakpointOnError()</code> ，如果上游任何发布者发送了一个错误，那么触发调试器</li><li><code>breakpoint</code> 允许在调试器中拦截重要的订约时间并且可选的结束进程</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> squares = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].publisher</span><br><span class="line">    .breakpoint(</span><br><span class="line">        receiveSubscription: &#123; subscription <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;,</span><br><span class="line">        receiveOutput: &#123; value <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;,</span><br><span class="line">        receiveCompletion: &#123; completion <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line">    .sink &#123; <span class="number">_</span> <span class="keyword">in</span> &#125;</span><br></pre></td></tr></table></figure><p>如果没有触发，这俩方法对流都是非侵入性的。如果触发了，它会抛出 <code>SIGTRAP</code> 信号。这使得调试器可以在流的特定点中断进程。</p><blockquote><p>如果没有调试器被触发，进程会终止，并且会产生停机日志报告</p></blockquote><h2 id="画图"><a class="markdownIt-Anchor" href="#画图"></a> 画图</h2><p>如果上面的都没有帮助，那么你可能得重新理一下你的逻辑了。你可以画出整个逻辑图。下面的代码会打印用户的信息，他们的全名和年龄：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> firstNames = <span class="type">PassthroughSubject</span>&lt;<span class="type">String</span>, <span class="type">Never</span>&gt; ()</span><br><span class="line"><span class="keyword">let</span> lastNames = <span class="type">PassthroughSubject</span>&lt;<span class="type">String</span>, <span class="type">Never</span>&gt; ()</span><br><span class="line"><span class="keyword">let</span> ageInYears = <span class="type">PassthroughSubject</span>&lt;<span class="type">Int</span>, <span class="type">Never</span>&gt; ()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> abbreviated = <span class="type">Publishers</span>.<span class="type">CombineLatest</span>(firstNames, lastNames)</span><br><span class="line">    .<span class="built_in">map</span> &#123; <span class="string">"\($1) \($0.prefix(1))"</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> shortInfos = <span class="type">Publishers</span>.<span class="type">CombineLatest</span>(abbreviated, ageInYears)</span><br><span class="line">    .<span class="built_in">map</span> &#123; <span class="string">"\($0), \($1) y.o."</span> &#125;</span><br><span class="line">    .sink &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;</span><br><span class="line"></span><br><span class="line">firstNames.send(<span class="string">"Vadim"</span>)</span><br><span class="line">lastNames.send(<span class="string">"Bulavin"</span>)</span><br><span class="line">ageInYears.send(<span class="number">26</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Prints 'Bulavin V., 26 y.o.'</span></span><br></pre></td></tr></table></figure><p>让我们看看如何将这段代码画成图。矩形代表发布者，矩形之间的箭头代表发布者之间的关系：<br /><img src="https://bebopfzj.oss-cn-hangzhou.aliyuncs.com/uPic/2020-08-29-RLOgzL.svg" alt="逻辑图" /></p><h2 id="时序图"><a class="markdownIt-Anchor" href="#时序图"></a> 时序图</h2><p>时序图展示了在一个响应式流中事件随时间发生的样子。这个方法在 <code>Rx</code> 社区被广泛应用，也能用在这里，帮助理解。</p><blockquote><p><a href="https://github.com/CombineCommunity/rxswift-to-combine-cheatsheet" target="_blank" rel="noopener">这张查询表</a> 可以帮你理清楚两者间的概念</p></blockquote><p>下面的图展示了 <code>Publisher.CombineLatest</code> 的逻辑：<br /><img src="https://bebopfzj.oss-cn-hangzhou.aliyuncs.com/uPic/2020-08-29-eGbkGG.png" alt="Publisher.CombineLatest" /></p>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 异步 </tag>
            
            <tag> IOS </tag>
            
            <tag> 响应式编程 </tag>
            
            <tag> combine </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>响应式编程与Combine（三）</title>
      <link href="/2020/08/28/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B%E4%B8%8ECombine3/"/>
      <url>/2020/08/28/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B%E4%B8%8ECombine3/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这篇文章基本翻译自 <a href="https://www.vadimbulavin.com/swift-combine-framework-tutorial-getting-started/" target="_blank" rel="noopener">Swift Combine Framework Tutorial: Getting Started</a>，删除了一些重复的内容</p></blockquote><h1 id="combine-的使用"><a class="markdownIt-Anchor" href="#combine-的使用"></a> Combine 的使用</h1><p>前面两篇文章已经系统的介绍了 <code>Combine</code> 框架的主要组件。在这篇文章中，我们将会介绍一下它们的基本用法。如何将各种内建组件组合起来形成一套逻辑链。</p><h1 id="publisher-与-subscriber-的连接"><a class="markdownIt-Anchor" href="#publisher-与-subscriber-的连接"></a> Publisher 与 Subscriber 的连接</h1><p><code>Combine</code> 有两个内建的 <code>Subscriber</code>：<code>Subscribers.Sink</code> 和 <code>Subscribers.Assign</code>。你可以通过调用 <code>Publisher</code> 上任何一个方法来连接它们：</p><ul><li><code>sink(receiveCompletion: receiveValue:)</code> 在闭包中处理新元素或是完成事件</li><li><code>assign(to: on:)</code> 将新元素写入属性</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> publisher = <span class="type">Just</span>(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">publisher.sink(</span><br><span class="line">    receiveCompletion: &#123; <span class="number">_</span> <span class="keyword">in</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"finished"</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    receiveValue: &#123; value <span class="keyword">in</span></span><br><span class="line">        <span class="built_in">print</span>(value)</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ol><li>创建一个 <code>Just</code> 发布者，仅发送一个值，然后完成。<code>Combine</code> 有一堆内建的 Publisher，包括 <code>Just</code></li><li>连接到 <code>Subscribers.Sink</code> 订阅者</li></ol><a id="more"></a><p>这段代码将会打印：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">finished</span><br></pre></td></tr></table></figure><p>在发送 1 之后，发布者会自动的完成。我们不必处理任何错误，因为 <code>Just</code> 不会失败。</p><h1 id="combine-发布者和订阅者的生命周期"><a class="markdownIt-Anchor" href="#combine-发布者和订阅者的生命周期"></a> Combine 发布者和订阅者的生命周期</h1><p>发布者和订阅者之间的连接被称为订阅。这类连接的步骤定义了发布者订阅者的 <em>生命周期</em>。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> subject = <span class="type">PassthroughSubject</span>&lt;<span class="type">Int</span>, <span class="type">Never</span>&gt; ()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> token = subject</span><br><span class="line">    .<span class="built_in">print</span>()</span><br><span class="line">    .sink(receiveValue: &#123; <span class="built_in">print</span>(<span class="string">"received by subscriber: \($0)"</span>) &#125;)</span><br><span class="line"></span><br><span class="line">subject.send(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>注意到上面代码片段的 <code>print(_: to:)</code>。它会打印所有有关发布事件的日志信息到控制台中，这些日志信息可以让我们更好的了解整个生命周期。</p><p>这里是我们将会在控制台得到的打印信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">receive subscription: (PassthroughSubject)</span><br><span class="line">request unlimited</span><br><span class="line">receive value: (1)</span><br><span class="line">received by subscriber: 1</span><br><span class="line">receive cancel</span><br></pre></td></tr></table></figure><p>这些信息给了我们关于发布者-订阅者生命周期的线索。调试日志中缺少了一些步骤，让我们从头到尾的研究一下生命周期：</p><ol><li>一个订阅者通过调用 <code>subscribe&lt;S&gt; (S)</code> 来连接到发布者</li><li>发布者通过在自身调用 <code>receive&lt;S&gt; (subscriber: S)</code> 来创建一个订阅</li><li>发布者确认订阅请求，它在订阅者上调用 <code>receive(subscription:)</code></li><li>订阅者请求它想要接受的元素。它在订阅上调用 <code>request(:)</code>，并且将 <code>需求</code> 当做参数传递。需求定义了发布者可以通过订阅向订阅者传递多少信息</li><li>发布者通过在订阅者上调用 <code>receive(_ :)</code> 来传递值。这个方法返回一个 <code>需求</code> 实例，需求显示了订阅者期望接收值的项数。订阅者只能增加或者保持不变需求，但不能减少它。</li><li>订阅将可能以这些结果中的一个结束：<ul><li>Cancelled 这可以在订阅者被释放时自动发生，就像上面的例子一样。另一种方法是手动取消：<code>token.cancel()</code></li><li>Finish 成功</li><li>Fail 因为错误导致失败</li></ul></li></ol><blockquote><p>Token 实际上是订阅者，将类型擦除至满足 <code>AnyCancellable</code> 协议</p></blockquote><h1 id="chaining-publishers-with-operators"><a class="markdownIt-Anchor" href="#chaining-publishers-with-operators"></a> Chaining Publishers with Operators</h1><p><code>Operator</code> 是一些 <code>Publisher</code> 调用的特殊方法，并且返回其他的 <code>Publisher</code>。这允许开发者一个接一个的使用它们，创造一个链条。每一个 <code>Operator</code> 都在前一个 <code>Operator</code> 产出的 <code>Publisher</code> 上工作。</p><p>链条必须由一个 <code>Publisher</code> 发起，然后就可以依次应用于 <code>Operator</code> 了，我们将它们的相对顺序称为 <em>上游</em> 和 <em>下游</em>。</p><p>来看看我们在处理一个 HTTP URL 请求时如何连接 <code>Operator</code>：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="keyword">let</span> url = <span class="type">URL</span>(string: <span class="string">"https://api.github.com/users/V8tr/repos"</span>)!</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="keyword">let</span> token = <span class="type">URLSession</span>.shared.dataTaskPublisher(<span class="keyword">for</span>: url)</span><br><span class="line">    .<span class="built_in">map</span> &#123; $<span class="number">0</span>.data &#125;    <span class="comment">// 3</span></span><br><span class="line">    .decode(</span><br><span class="line">        type: [<span class="type">Repository</span>].<span class="keyword">self</span>,</span><br><span class="line">        decoder: <span class="type">JSONDecoder</span>()      <span class="comment">// 4</span></span><br><span class="line">    )</span><br><span class="line">    .sink(</span><br><span class="line">        receiveCompletion: &#123; completion <span class="keyword">in</span>      <span class="comment">// 5</span></span><br><span class="line">            <span class="built_in">print</span>(completion)</span><br><span class="line">        &#125;,</span><br><span class="line">        receiveValue: &#123; repositories <span class="keyword">in</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"V8tr has \(repositories.count) repositories"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br></pre></td></tr></table></figure><ol><li>创建一个请求去加载我的 Github 仓库，我们可以直接使用 Github 的 api</li><li>Combine 可以很轻松的集成到 Swift 系统框架和 IOS SDK 中。这允许我们使用内建的 <code>Publisher</code> 去处理 <code>URLSession</code> 的数据任务</li><li>传递返回的数据。我们使用 <code>map(_ :)</code> operator，它可以将上游的 <code>(data: Data, response: URLResponse)</code> 转换为 <code>Data</code></li><li>使用 <code>JSONDecoder</code> 解码返回的内容</li><li>连接到 <code>sink</code> 订阅者，它将打印接收到的仓库的数量，然后完成</li></ol><p>这段代码将会打印：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">V8tr has 30 repositories</span><br><span class="line">finished</span><br></pre></td></tr></table></figure><h1 id="combine-中的转换-operatorsmap-flatmap-switchtolatest"><a class="markdownIt-Anchor" href="#combine-中的转换-operatorsmap-flatmap-switchtolatest"></a> Combine 中的转换 Operators：Map、FlatMap、SwitchToLatest</h1><p>题目中提到的三个 <code>Operator</code> 算是 <code>Combine</code> 框架中非常重要的三个了。所以熟练地掌握它们是很有必要的。下面一一来介绍。</p><h2 id="使用-map-转换元素"><a class="markdownIt-Anchor" href="#使用-map-转换元素"></a> 使用 Map 转换元素</h2><p><code>Combine</code> 里的 <code>map(_ :)</code> 算子的工作方式和 <code>Swift</code> 标准库中的 <code>map</code> 很相似，唯一的区别就是前者需要和 <code>Publisher</code> 工作。它接受一个闭包，这个闭包将一个元素转化为另一个元素。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">    .publisher</span><br><span class="line">    .<span class="built_in">map</span> &#123; $<span class="number">0</span> * <span class="number">2</span> &#125;</span><br><span class="line">    .sink &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;</span><br></pre></td></tr></table></figure><p>这将会打印：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">4</span><br><span class="line">6</span><br></pre></td></tr></table></figure><h2 id="使用-flatmap-转换-publisher"><a class="markdownIt-Anchor" href="#使用-flatmap-转换-publisher"></a> 使用 FlatMap 转换 Publisher</h2><p><code>flatMap(maxPublishers: _:)</code> 算子可以将一个 <code>Publisher</code> 转化为一个全新的 <code>Publisher</code>，新的发布者将以相同的方式产出元素。当你想要进入一个发布者内部并获取元素的时候，你会用得着它。</p><p>为了更好地理解算子，让我们从一个例子开始。假设我们有一个 <code>User</code> 结构体，它有一个作为发布者的 <code>name</code> 属性：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> name: <span class="type">CurrentValueSubject</span>&lt;<span class="type">String</span>, <span class="type">Never</span>&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了打印多个用户的一系列名字，我们创建了 <code>PassthroughSubject</code> 并且将 <code>User</code> 对象传入其中。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> userSubject = <span class="type">PassthroughSubject</span>&lt;<span class="type">User</span>, <span class="type">Never</span>&gt; ()</span><br><span class="line"></span><br><span class="line">userSubject</span><br><span class="line">    .<span class="built_in">map</span> &#123; $<span class="number">0</span>.name &#125;</span><br><span class="line">    .sink &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user = <span class="type">User</span>(name: .<span class="keyword">init</span>(<span class="string">"User 1"</span>))</span><br><span class="line">userSubject.send(user)</span><br></pre></td></tr></table></figure><p>这段代码会因为错误而结束，因为 <code>userSubject</code> 是发布者的发布者。<code>flatMap</code> 算子允许我们克服这个问题，并且访问到 <code>name</code> 值：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">userSubject</span><br><span class="line">    .flatMap &#123; $<span class="number">0</span>.name &#125;</span><br><span class="line">    .sink &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;</span><br></pre></td></tr></table></figure><p>这段代码将会打印：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User</span><br></pre></td></tr></table></figure><h2 id="使用-flatmap-控制-publisher-的数量"><a class="markdownIt-Anchor" href="#使用-flatmap-控制-publisher-的数量"></a> 使用 FlatMap 控制 Publisher 的数量</h2><p><code>flatMap</code> 有一个 <code>maxPublishers</code> 的参数，这控制了其可以接收多少个 <code>Publishers</code>。默认是无限个：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> anotherUser = <span class="type">User</span>(name: .<span class="keyword">init</span>(<span class="string">"AnotherUser 1"</span>))</span><br><span class="line">userSubject.send(anotherUser)</span><br><span class="line"></span><br><span class="line">anotherUser.name.send(<span class="string">"AnotherUser 2"</span>)</span><br><span class="line"></span><br><span class="line">user.name.send(<span class="string">"User 2"</span>)</span><br></pre></td></tr></table></figure><p>这会打印 <code>user</code> 和 <code>anotherUser</code> 的名字：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">User 1</span><br><span class="line">AnotherUser 1</span><br><span class="line">AnotherUser 2</span><br><span class="line">User 2</span><br></pre></td></tr></table></figure><p>一旦我们将 <code>maxPublishers</code> 的值设置为 <code>1</code>，<code>flatMap</code> 就将只接收 <code>User</code>，并且忽略 <code>anotherUser</code> 了。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">userSubject</span><br><span class="line">    .flatMap(maxPublishers: .<span class="built_in">max</span>(<span class="number">1</span>)) &#123; $<span class="number">0</span>.name &#125;</span><br><span class="line">    .sink &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user = <span class="type">User</span>(name: .<span class="keyword">init</span>(<span class="string">"User 1"</span>))</span><br><span class="line">userSubject.send(user)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> anotherUser = <span class="type">User</span>(name: .<span class="keyword">init</span>(<span class="string">"AnotherUser 1"</span>))</span><br><span class="line">userSubject.send(anotherUser)</span><br><span class="line"></span><br><span class="line">anotherUser.name.send(<span class="string">"AnotherUser 2"</span>)</span><br><span class="line">user.name.send(<span class="string">"User 2"</span>)</span><br></pre></td></tr></table></figure><p>这将会打印：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">User</span> <span class="number">1</span></span><br><span class="line"><span class="type">User</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><h2 id="切换到最新的-publiser"><a class="markdownIt-Anchor" href="#切换到最新的-publiser"></a> 切换到最新的 Publiser</h2><p>正如我们在 <code>flatMap</code> 中看到的那样，我们经常会遇到要获取到一个发布者的发布者。例如，如果每点击一次按钮就会创建一个网络请求。当请求会在很短的时间就完成时，<code>response</code> 可能会无序到达。然而，我们经常只对 <em>最新</em> 的网络请求感兴趣。在 <code>Combine</code> 中，有一个可以完成这个需求的算子：<code>switchToLatest()</code>。</p><p>继续我们的例子，让我们看看如何切换至流中最新的 <code>Publisher</code>。唯一需要修改的地方就是订阅：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">userSubject</span><br><span class="line">    .<span class="built_in">map</span> &#123; $<span class="number">0</span>.name &#125;</span><br><span class="line">    .switchToLatest()</span><br><span class="line">    .sink &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;</span><br></pre></td></tr></table></figure><p>这将会打印：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">User 1</span><br><span class="line">AnotherUser 1</span><br><span class="line">AnotherUser 2</span><br></pre></td></tr></table></figure><p>一旦 <code>anotherUser</code> 插入到了流中，<code>userSubject</code> 就会自动的切换过去，不再传递 <code>User</code> 的值。</p>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 异步 </tag>
            
            <tag> IOS </tag>
            
            <tag> 响应式编程 </tag>
            
            <tag> combine </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>响应式编程与Combine（二）</title>
      <link href="/2020/08/28/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B%E4%B8%8ECombine2/"/>
      <url>/2020/08/28/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B%E4%B8%8ECombine2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文翻译自 <a href="https://www.vadimbulavin.com/understanding-schedulers-in-swift-combine-framework/" target="_blank" rel="noopener">Understanding Schedulers in Swift Combine Framework</a> 。你可以阅读原文或者是原作者的 Combine 框架系列以了解更多内容。<br />另外的，上一篇文章介绍了 <code>Publisher</code>，<code>Subscriber</code>，<code>Subject</code>。这篇关于 <code>Scheduler</code> 的文章算是一个补充。在日常的开发中，真实的 <code>Publisher</code> 需要借助 <code>Scheduler</code> 基于时序进行产出——译者注</p></blockquote><p>现在，我们已经了解了 <code>Combine</code> 框架的 <a href="https://www.vadimbulavin.com/swift-combine-framework-tutorial-getting-started/" target="_blank" rel="noopener">全景</a>。现在是时候学习 <code>scheduler</code> 的知识了。</p><ol><li><code>Combine</code> 里内置了哪些 <code>Scheduler</code>？</li><li>怎么开关 <code>Scheduler</code>？</li><li>如何使用 <code>Combine</code> 来执行异步工作？</li><li><code>receive(on:)</code> 和 <code>subscribe(on:)</code> 的区别是什么？</li></ol><a id="more"></a><h1 id="scheduler-的定义"><a class="markdownIt-Anchor" href="#scheduler-的定义"></a> Scheduler 的定义</h1><p><code>Scheduler</code> 是 <code>Combine</code> 框架中的同步机制，它定义了何处、何时执行工作的上下文。</p><blockquote><p>Combine 不能直接使用线程。相反，它允许 Publishers 在一个指定的 Scheduler 上操作</p></blockquote><p><strong>何处</strong> 的意思是，运行在当前循环，调度队列，还是操作队列。<br /><strong>何时</strong> 代表着一个虚拟的时间，这个时间依赖于 Scheduler 的时钟。由 <code>Scheduler</code> 执行的工作只遵守调度器的时钟，这个时间可能与真实的系统时间不同。</p><h1 id="combine-中-scheduler-的类型"><a class="markdownIt-Anchor" href="#combine-中-scheduler-的类型"></a> Combine 中 Scheduler 的类型</h1><p><code>Combine</code> 框架提供了一系列的 <code>Scheduler</code>，所有的这些都遵守 <code>Scheduler</code> 协议：</p><ul><li><code>DispatchQueue</code>。将工作置于特定的分派队列上执行：串行、并发、主调度或是全局调度。对于后台工作，一般使用串行或是全局调度，主队列一般执行和 UI 相关的工作。在 <a href="https://forums.swift.org/t/runloop-main-or-dispatchqueue-main-when-using-combine-scheduler/26635/4" target="_blank" rel="noopener">Xcode 11 GM Seed</a> 中，不建议使用并发队列。</li><li><code>OperationQueue</code>。将工作置于特定的执行队列上执行。和 <code>DispatchQueue</code> 相似的是，使用 <code>OperationQueue.main</code> 来进行 UI 线管的工作，然后使用其他的队列来运行后台工作。根据论坛里的 <a href="https://forums.swift.org/t/runloop-main-or-dispatchqueue-main-when-using-combine-scheduler/26635" target="_blank" rel="noopener">这篇讨论</a> 不建议使用 <code>maxConcurrentOperations</code> 大于 1 的执行队列。</li><li><code>Runloop</code>。在特定的循环上执行工作。</li><li><code>ImmediateScheduler</code>。立即执行同步操作，如果你尝试使用此调度器执行具有延迟的工作，应用将立即因为致命错误而终止。</li></ul><blockquote><p>使用 <code>RunLoop.main</code>，<code>DispatchQueue.main</code>，<code>OperationQueue.main</code> 去执行 UI 相关的工作。正如这个 <a href="https://forums.swift.org/t/runloop-main-or-dispatchqueue-main-when-using-combine-scheduler/26635/4" target="_blank" rel="noopener">讨论</a> 中所指出的，它们之间没啥区别。</p></blockquote><p>除了 <code>ImmediateScheduler</code> 之外，<code>Combine</code> 并没有引入新的 <code>Scheduler</code> 类型。相反的，苹果扩展了 Swift 现有的多线程 api，从而实现 <code>Scheduler</code>。你不使用 <code>Combine</code> 而直接使用这些 api，可以得到相同的效果。这降低了学习成本。</p><h1 id="默认-scheduler"><a class="markdownIt-Anchor" href="#默认-scheduler"></a> 默认 Scheduler</h1><p>即使你没有指定任何的 <code>Scheduler</code> ,<code>Combine</code> 也会为你提供一个默认的。该调度程序使用与产出元素相同的线程。也就是说，你使用一个后台线程发送元素，你会在同一个线程上接收到它。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> subject = <span class="type">PassthroughSubject</span>&lt;<span class="type">Int</span>, <span class="type">Never</span>&gt; ()</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="keyword">let</span> token = subject.sink(receiveValue: &#123; value <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="type">Thread</span>.isMainThread)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line">subject.send(<span class="number">1</span>)</span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="type">DispatchQueue</span>.global().async &#123;</span><br><span class="line">    subject.send(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>如果是在主线程上接收到了值，那么打印 <code>true</code>，反之打印 <code>false</code></li><li>在主线程发送 1</li><li>在后台线程发送 2</li></ol><p>输出结果是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">false</span><br></pre></td></tr></table></figure><p>和设想一样，值在不同的线程上被接收到。</p><h1 id="切换-schedulers"><a class="markdownIt-Anchor" href="#切换-schedulers"></a> 切换 Schedulers</h1><p>耗资源的工作通常在后台处理，这样 UI 界面才不会卡住。工作结果稍候将传递到主线程中。<code>Combine</code> 框架通过切换 <code>Scheduler</code> 来完成这件事，依赖于使用这两个方法：<code>subscribe(on:)</code> 和 <code>receive(on:)</code>。</p><p><code>receive(on:)</code><br />该方法为其之后所有的发布者切换调度程序。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Just</span>(<span class="number">1</span>)</span><br><span class="line">    .<span class="built_in">map</span> &#123; <span class="number">_</span> <span class="keyword">in</span> <span class="built_in">print</span>(<span class="type">Thread</span>.isMainThread) &#125;</span><br><span class="line">    .receive(on: <span class="type">DispatchQueue</span>.global())</span><br><span class="line">    .<span class="built_in">map</span> &#123; <span class="built_in">print</span>(<span class="type">Thread</span>.isMainThread) &#125;</span><br><span class="line">    .sink &#123; <span class="built_in">print</span>(<span class="type">Thread</span>.isMainThread) &#125;</span><br></pre></td></tr></table></figure><p>这段代码将输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">false</span><br><span class="line">false</span><br></pre></td></tr></table></figure><p>该过程的可视化如下：<br /><img src="https://bebopfzj.oss-cn-hangzhou.aliyuncs.com/uPic/2020-08-28-9RW0y4.svg" alt="receive(on:)切换Scheduler" /><br /><code>receive(on:)</code> 右边的 Operator 会将元素交付至 <code>DispatchQueue.global()</code> 调度器。</p><p><code>subscribe(on:)</code><br />该方法修改用于订阅、取消和请求操作的调度程序。<code>Publisher</code> 链将会一直保持在这个调度器上，除非使用 <code>receive(on:)</code> 制定了一个新的。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Just</span>(<span class="number">1</span>)</span><br><span class="line">    .subscribe(on: <span class="type">DispatchQueue</span>.global())</span><br><span class="line">    .<span class="built_in">map</span> &#123; <span class="number">_</span> <span class="keyword">in</span> <span class="built_in">print</span>(<span class="type">Thread</span>.isMainThread) &#125;</span><br><span class="line">    .sink &#123; <span class="built_in">print</span>(<span class="type">Thread</span>.isMainThread) &#125;</span><br></pre></td></tr></table></figure><p>这段代码将输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">false</span><br><span class="line">false</span><br></pre></td></tr></table></figure><p>该过程的可视化如下：<br /><img src="https://bebopfzj.oss-cn-hangzhou.aliyuncs.com/uPic/2020-08-28-fSN7ci.svg" alt="subscribe(on:)" /><br />所有的操作都将发生在 <code>DispatchQueue.global()</code> 调度器上。</p><p><code>subscribe(on:)</code> 的位置无所谓，因为它会影响订阅的时机。这段代码和前面是等效的：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Just</span>(<span class="number">1</span>)</span><br><span class="line">    .<span class="built_in">map</span> &#123; <span class="number">_</span> <span class="keyword">in</span> <span class="built_in">print</span>(<span class="type">Thread</span>.isMainThread) &#125;</span><br><span class="line">    .subscribe(on: <span class="type">DispatchQueue</span>.global())  <span class="comment">// subscribe(on:) 的位置变化了</span></span><br><span class="line">    .sink &#123; <span class="built_in">print</span>(<span class="type">Thread</span>.isMainThread) &#125;</span><br></pre></td></tr></table></figure><p>虽然订阅的位置变了，但所有事件的产出值还是会在 <code>DispatchQueue.global()</code> 调度器上被接收到。</p><p>敏锐的读者应该已经注意到了，<code>subscribe(on:)</code> 的定义并没有提到应该由哪个调度器接收值。如果发布者在不同的线程上发布值，那么将会在那个线程上接收到值。典型的例子就是一个数组任务的 <code>Publisher</code>:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">URLSession</span>.shared.dataTaskPublisher(<span class="keyword">for</span>: <span class="type">URL</span>(string: <span class="string">"https://www.vadimbulavin.com"</span>)!)</span><br><span class="line">    .subscribe(on: <span class="type">DispatchQueue</span>.main)      <span class="comment">// Subscribe on the main thread</span></span><br><span class="line">    .sink(</span><br><span class="line">        receiveCompletion: &#123; <span class="number">_</span> <span class="keyword">in</span> &#125;,</span><br><span class="line">        receiveValue: &#123; <span class="number">_</span> <span class="keyword">in</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="type">Thread</span>.isMainThread)      <span class="comment">// Are we on the main thread?</span></span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br></pre></td></tr></table></figure><p>这段代码将会打印 false，因为 <code>Publisher</code> 会在后台线程上提交值。在这个例子里我们得使用 <code>receive(on:)</code> 来指定一个 <code>Scheduler</code>。</p><blockquote><p>我得感谢 <a href="https://twitter.com/heckj" target="_blank" rel="noopener">Joseph Heck</a> 给我解释了这个。请务必阅读他 <a href="https://heckj.github.io/swiftui-notes/" target="_blank" rel="noopener">关于 Combine 的书</a> ，这是迄今为止关于这个主题最全面、最可靠的资料来源。</p></blockquote><h1 id="使用-combine-执行异步工作"><a class="markdownIt-Anchor" href="#使用-combine-执行异步工作"></a> 使用 Combine 执行异步工作</h1><p>最后，让我们来看看如何结合使用 <code>subscribe(on:)</code> 和 <code>receive(on:)</code> 来控制调度器。</p><p>假设，我们有一个需要执行长耗时任务的 Publisher：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BusyPublisher</span>: <span class="title">Publisher</span> </span>&#123;</span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">Output</span> = <span class="type">Int</span></span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">Failure</span> = <span class="type">Never</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">receive</span>&lt;S&gt; <span class="params">(subscriber: S)</span></span> <span class="keyword">where</span></span><br><span class="line">        <span class="type">S</span>: <span class="type">Subscriber</span>,</span><br><span class="line">        <span class="type">Failure</span> == <span class="type">S</span>.<span class="type">Failure</span>,</span><br><span class="line">        <span class="type">Output</span> == <span class="type">S</span>.<span class="type">Input</span> &#123;</span><br><span class="line">            sleep(<span class="number">10</span>)</span><br><span class="line">            subscriber.receive(subscription: <span class="type">Subscriptions</span>.empty)</span><br><span class="line">            <span class="number">_</span> = subscriber.receive(<span class="number">1</span>)</span><br><span class="line">            subscriber.receive(completion: .finished)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当在 UI 线程调用时，会导致 app 卡 10 秒左右。记住，<code>Combine</code> 会默认使用和调用处相同的线程。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BusyPublisher</span>()</span><br><span class="line">    .sink &#123; <span class="number">_</span> <span class="keyword">in</span> <span class="built_in">print</span>(<span class="string">"Received value"</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Hello"</span>)</span><br></pre></td></tr></table></figure><p>和期望的一样，<em>Hello</em> 会在接收值 <strong>后</strong> 打印。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Received value</span><br><span class="line">Hello</span><br></pre></td></tr></table></figure><p>在 <code>Combine</code> 中进行异步工作的一般模式是在后台调度器订阅，然后将事件发送至 UI 调度器：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BusyPublisher</span>()</span><br><span class="line">    .subscribe(on: <span class="type">DispatchQueue</span>.global())</span><br><span class="line">    .receive(on: <span class="type">DispatchQueue</span>.main)</span><br><span class="line">    .sink &#123; <span class="number">_</span> <span class="keyword">in</span> <span class="built_in">print</span>(<span class="string">"Received value"</span>)&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Hello"</span>)</span><br></pre></td></tr></table></figure><p>这段代码将会输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hello</span><br><span class="line">Received value</span><br></pre></td></tr></table></figure><p><em>Hello</em> 会在接收到值之前打印。这意味着 Publisher 没有因为阻塞主线程而冻结 app。</p><h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1><p>让我们总结一下需要记忆的要点：</p><ul><li><code>subscrive(on:)</code> 和 <code>receive(on:)</code> 是 <code>Combine</code> 框架中主要的多线程方法</li><li>默认 Scheduler 会使用和产出元素相同的线程</li><li><code>receive(on:)</code> 会为之后所有的执行都设置相同的 Scheduler</li><li><code>subscribe(on:)</code> 为整个流设置一个 Scheduler，从 Publisher 被订阅开始。整个流将会一直使用一个 Scheduler，除非使用 <code>receive(on:)</code> 指定了一个新的</li><li><code>subscribe(on:)</code> 的位置无所谓</li><li>一般情况下，异步工作通常通过在后台调度器订阅，然后由 UI 调度器接收值来执行。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 异步 </tag>
            
            <tag> IOS </tag>
            
            <tag> 响应式编程 </tag>
            
            <tag> combine </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>响应式编程与Combine（一）</title>
      <link href="/2020/08/27/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B%E4%B8%8ECombine/"/>
      <url>/2020/08/27/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B%E4%B8%8ECombine/</url>
      
        <content type="html"><![CDATA[<h1 id="响应式编程"><a class="markdownIt-Anchor" href="#响应式编程"></a> 响应式编程</h1><p>借用维基百科的定义：</p><blockquote><p>在计算中，响应式编程或反应式编程（英语：Reactive programming）是一种面向数据流和变化传播的声明式编程范式。这意味着可以在编程语言中很方便地表达静态或动态的数据流，而相关的计算模型会自动将变化的值通过数据流进行传播。</p></blockquote><p>从定义中可以看出，响应式编程的核心就是：数据流和数据流的变化。<br />数据流自不必说，很多实际的应用场景都会产生数据流。如果仅限于 <code>IOS</code> 客户端开发的话，网络请求就是一个常见的应用场景了。很多语言都给出了自己的响应式编程的解决方案，但本篇文章只谈谈苹果给出的解决方案——<code>Combine</code> 框架。</p><p>另外的，基于响应式编程的特点，我们很容易想到可以把函数式编程与响应式编程结合起来。而函数式编程的核心就是“模糊数据与过程的界限”。函数式编程的这一特点可以让我们更加清楚的处理数据流，明确其输入和输出。</p><p>而这一套范式可以用来很轻松的解决异步编程的种种问题。而提到异步编程，对于前端开发的程序员来说应该不会陌生。在过去，前端工程师依赖于 <code>闭包回调</code> 这一方案来解决异步编程的问题。简单来说，就是在调用需要耗时的方法时，同时提供一个回调函数来处理方法的结果。先不说这样很容易导致回调地狱的问题，当多个异步函数同时工作的时候，你很难搞清楚在任一情况下数据到底变成了什么样子，而这也就是大多数 bug 的来源。</p><a id="more"></a><h1 id="响应式异步编程模型"><a class="markdownIt-Anchor" href="#响应式异步编程模型"></a> 响应式异步编程模型</h1><p>在客户端的异步编程中，最核心的概念就是：事件。换句话说，就是数据流变化的标志。比如当一个请求 api 的函数获取到了返回结果，这就是一个事件。异步编程的职责就是去处理好这些事件和事件所带有的数据。当然了，这些数据并不一定就是最终要使用的数据，我们可能需要对这些数据做点处理，才能最终应用。</p><p>简单来说，大概就是这样的模型：</p><p><img src="https://bebopfzj.oss-cn-hangzhou.aliyuncs.com/uPic/2020-08-27-P0OKcw.png" alt="响应式异步编程模型" /></p><p>不过在接下来的关于 <code>Combine</code> 的介绍中，我们会发现，实际中事件的出现与数据处理有时候并不是独立地，它们会经常结对出现。不过最终还是会通过一个事件的订阅者来使用这些数据。</p><h1 id="combine-介绍"><a class="markdownIt-Anchor" href="#combine-介绍"></a> Combine 介绍</h1><p>这里引用一下苹果关于 <code>Combine</code> 的 <a href="https://developer.apple.com/documentation/combine" target="_blank" rel="noopener">介绍</a>:</p><blockquote><p>The Combine framework provides a declarative Swift API for processing values over time. These values can represent many kinds of asynchronous events. Combine declares publishers to expose values that can change over time, and subscribers to receive those values from the publishers.</p></blockquote><p>可以看出，这里的核心就是 <code>values over time</code>。通过 <code>publishers</code> 来提供随时间变化的数据，然后由 <code>subscribers</code> 来接收这些数据并处理。注意到这里模糊了事件产出和数据处理的界限。因为一个数据处理的行为同样也可以产出一个事件。<code>Combine</code> 将 <code>Publisher</code> 和 <code>Subscribers</code> 定义为协议，从而控制其行为。</p><h2 id="publisher"><a class="markdownIt-Anchor" href="#publisher"></a> Publisher</h2><p>关于 <code>Publisher</code>，苹果给出了一段定义：</p><blockquote><p>The Publisher protocol declares a type that can deliver a sequence of values over time. Publishers have operators to act on the values received from upstream publishers and republish them.</p></blockquote><p>从定义可以看出，<code>Publisher</code> 实际上就是一个可以随时间交付一系列值的过程。理所当然的，你也可以组合多个不同的 <code>Publisher</code> 来形成你自己的数据更新逻辑。这里给出协议的定义：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">Publisher</span> </span>&#123;</span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">Output</span></span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">Failure</span> : <span class="type">Error</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">receive</span>&lt;S&gt; <span class="params">(subscriber: S)</span></span> <span class="keyword">where</span></span><br><span class="line">        <span class="type">S</span> : <span class="type">Subscriber</span>,</span><br><span class="line">        <span class="type">Self</span>.<span class="type">Failure</span> == <span class="type">S</span>.<span class="type">Failure</span></span><br><span class="line">        <span class="type">Self</span>.<span class="type">Output</span> == <span class="type">S</span>.<span class="type">Input</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总的来说，一个 <code>Publisher</code> 可以发布三种事件：（有一说一，从设计上来说，跟 Promise 没啥区别）</p><ul><li>Output 类型的新值</li><li>Failure 类型的错误</li><li>事件完成</li></ul><p>第一种事件是由 <code>Publisher</code> 直接发布的，后两种则是使用 <code>Subscribers.Completion</code> 来描述。它是一个含有两个成员的 <code>enum</code>，成员类型为 <code>.failure</code> 和 <code>finished</code>。</p><p>另外的，<code>Publisher</code> 所必须实现的 <code>receive(subscriber:)</code> 方法是用来接受 <code>Subscriber</code> 的。</p><p>最后，<code>Combine</code> 提供了一系列内建的 <code>Publisher</code> 来处理数据，你可以在 <a href="https://developer.apple.com/documentation/combine/publisher" target="_blank" rel="noopener">官方文档</a> 获得更多信息。</p><h2 id="subscriber"><a class="markdownIt-Anchor" href="#subscriber"></a> Subscriber</h2><p>同样的，我们直接引用苹果关于 <code>Subscriber</code> 的定义：</p><blockquote><p>At the end of a chain of publishers, a Subscriber acts on elements as it receives them. Publishers only emit values when explicitly requested to do so by subscribers. This puts your subscriber code in control of how fast it receives events from the publishers it’s connected to.</p></blockquote><p>可以看出，<code>Subscriber</code> 是作为 <code>Publisher</code> 链的结束的。这里我们给出 <code>Subscriber</code> 协议的定义：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">Subscriber</span> </span>&#123;</span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">Input</span></span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">Failure</span> : <span class="type">Error</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">receive</span> <span class="params">(subscription: Subscription)</span></span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">receive</span> <span class="params">(<span class="number">_</span> input: <span class="keyword">Self</span>.Input)</span></span> -&gt; <span class="type">Subscribers</span>.<span class="type">Demand</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">receive</span> <span class="params">(completion: Subscribers.Completion&lt;<span class="keyword">Self</span>.Failure&gt;)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果一个 <code>Subscriber</code> 想要订阅 <code>Publisher</code>，那么 <code>Subscriber</code> 的 <code>Input</code> 与 <code>Failure</code> 必须与 <code>Publisher</code> 的 <code>Output</code> 和 <code>Failure</code> 相同。</p><p>另外的，你可以参考这段话来理解 <code>Publisher</code> 和 <code>Subscriber</code> 的工作方式：</p><blockquote><p>You connect a subscriber to a publisher by calling the publisher’s subscribe() method. After making this call, the publisher invokes the subscriber’s receive(subscription:) method. This gives the subscriber a Subscription instance, which it uses to demand elements from the publisher, and to optionally cancel the subscription. After the subscriber makes an initial demand, the publisher calls receive(), possibly asynchronously, to deliver newly-published elements. If the publisher stops publishing, it calls receive(completion:), using a parameter of type Subscribers.Completion to indicate whether publishing completes normally or with an error.</p></blockquote><p>简单来说，大致包含以下几个部分的内容：</p><ol><li>关于订阅。<code>Subscriber</code> 通过调用 <code>Publisher</code> 的 <code>subscribe(_ :)</code> 方法来将自己与发布者连接起来。</li><li>关于订阅的处理。<code>Publisher</code> 会调用 <code>Subscriber</code> 的 <code>receive(subscription:)</code> 方法来为订阅者产出一个订阅实例。订阅者可以通过这个实例来从发布者获取数据，或是取消订阅。另外的，发布者可能会异步的调用自身协议实现的 <code>receive()</code>方法来为订阅者产出值。</li><li>关于发布者的终止。当发布者停止时，会调用 <code>receive(completion: Subscribers.Completion&lt;Self.Failure&gt;)</code> 来表示发布是正常完成还是由于错误导致终止。</li></ol><h2 id="subject"><a class="markdownIt-Anchor" href="#subject"></a> Subject</h2><p>其实这东西本身就是一个 <code>Publisher</code> 。单独提出来说的原因是，它是作为一座桥梁，将传统的指令式异步 API 里的事件转换到响应式的世界中。这里我们给出协议的定义：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">Subject</span>: <span class="title">AnyObject</span>, <span class="title">Publisher</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">(<span class="number">_</span> value: <span class="keyword">Self</span>.Output)</span></span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">(completion: Subscribers.Completion&lt;<span class="keyword">Self</span>.Failure&gt;)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个协议暴露了两个 <code>send</code> 方法，来让外部调用者主动发布 <code>Output</code> 值或是 <code>failure</code> ，<code>finished</code> 事件。</p><p><code>Combine</code> 内置了两个常用的 <code>Subject</code>。即 <code>CurrentValueSubject</code> 和 <code>PassthroughSubject</code></p><h3 id="currentvaluesubject"><a class="markdownIt-Anchor" href="#currentvaluesubject"></a> CurrentValueSubject</h3><p>官方文档已经解释的很清楚了：</p><blockquote><p>A subject that wraps a single value and publishes a new element whenever the value changes.</p></blockquote><p>这里有一个例子：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> curr = <span class="type">CurrentValueSubject</span>&lt;<span class="type">Int</span>, <span class="type">Never</span>&gt; (<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">curr.sink(</span><br><span class="line">    receiveCompletion: &#123; complete <span class="keyword">in</span></span><br><span class="line">        <span class="built_in">print</span>(complete)</span><br><span class="line">    &#125;,</span><br><span class="line">    receiveValue &#123; value <span class="keyword">in</span></span><br><span class="line">        <span class="built_in">print</span>(value)</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">curr.value = <span class="number">1</span></span><br><span class="line">curr.value = <span class="number">2</span></span><br><span class="line">curr.send(completion: .finished)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// finished</span></span><br></pre></td></tr></table></figure><p>在订阅后，<code>Publisher</code> 里存储的值立即被发送给了 <code>receiveValue</code>。另外的，每一次的 <code>curr.value</code> 赋值都会触发订阅者的响应。</p><h3 id="passthroughsubject"><a class="markdownIt-Anchor" href="#passthroughsubject"></a> PassthroughSubject</h3><p>同样的，直接引用官方文档的解释：</p><blockquote><p>A subject that broadcasts elements to downstream subscribers.</p></blockquote><p>比起前者，它很简单，就直接将 <code>send</code> 接收到的值转发给了下游的 <code>Publisher</code> 或者是 <code>Subscriber</code>。这里是例子：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> pass = <span class="type">PassthroughSubject</span>&lt;<span class="type">Int</span>, <span class="type">Never</span>&gt; ()</span><br><span class="line"></span><br><span class="line">pass.sink(</span><br><span class="line">    receiveCompletion: &#123; complete <span class="keyword">in</span></span><br><span class="line">        <span class="built_in">print</span>(complete)</span><br><span class="line">    &#125;,</span><br><span class="line">    receiveValue: &#123; value <span class="keyword">in</span></span><br><span class="line">        <span class="built_in">print</span>(value)</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">pass.send(<span class="number">1</span>)</span><br><span class="line">pass.send(<span class="number">2</span>)</span><br><span class="line">pass.send(completion: .finished)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// finished</span></span><br></pre></td></tr></table></figure><p>订阅之后的第一次 <code>send</code> 才会将值传给下游。如果你在订阅前就调用了 <code>send</code>，那么下游是接收不到这个值的。</p>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 异步 </tag>
            
            <tag> IOS </tag>
            
            <tag> 响应式编程 </tag>
            
            <tag> combine </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从计算的本质来讨论递归</title>
      <link href="/2020/08/25/%E4%BB%8E%E8%AE%A1%E7%AE%97%E7%9A%84%E6%9C%AC%E8%B4%A8%E6%9D%A5%E8%AE%A8%E8%AE%BA%E9%80%92%E5%BD%92/"/>
      <url>/2020/08/25/%E4%BB%8E%E8%AE%A1%E7%AE%97%E7%9A%84%E6%9C%AC%E8%B4%A8%E6%9D%A5%E8%AE%A8%E8%AE%BA%E9%80%92%E5%BD%92/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文的核心思想来自于 SICP 第一章与第二章的内容，你可以同时阅读以深刻理解</p></blockquote><h1 id="关于递归"><a class="markdownIt-Anchor" href="#关于递归"></a> 关于递归</h1><p>事实上，递归一直是一个很难懂但却应用广泛的概念。例如在树的深度优先遍历中，我们就经常使用递归来简化代码。<br />在维基百科中，关于递归的<a href="https://zh.wikipedia.org/wiki/%E9%80%92%E5%BD%92" target="_blank" rel="noopener">定义</a>是这样的：</p><blockquote><p>递归（英语：Recursion），又译为递回，在数学与计算机科学中，是指在函数的定义中使用函数自身的方法。</p></blockquote><p>在很多关于递归的文章中，都趋向于从这三个方面来解释递归。或者说。教授读者从这三个方面来理解递归：</p><ul><li>明确递归函数的作用</li><li>寻找递归结束的条件</li><li>寻找函数的等价关系式</li></ul><p>但这种理解本质上是用常规的迭代思维来理解递归过程，自然很容易导致对递归相关的题目或者工程场景的代码，一看就会，一做就废。</p><p>事实上，理解递归的核心要点是，要理解下面这句话：</p><ul><li>即，递归是一个 <strong>推迟执行</strong> 的计算过程</li></ul><a id="more"></a><h1 id="关于推迟执行"><a class="markdownIt-Anchor" href="#关于推迟执行"></a> 关于推迟执行</h1><p>首先，我们给定一个常规的计算过程：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">res = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">10</span>):</span><br><span class="line">    res += i</span><br><span class="line"></span><br><span class="line">print(res)      <span class="comment"># 45</span></span><br></pre></td></tr></table></figure><p>这个段代码很好理解，我们事实上在做一个等差数列的和的计算。上面这段代码的逻辑可以代换成实际的数字：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res &#x3D; 0 + 1 + 2 + 3 + ... + 9</span><br></pre></td></tr></table></figure><p>注意到，每一次 <code>for</code> 循环，我们都真真切切的完成了一次计算。例如当 <code>i = 1</code> 的时候，循环内部的代码应该是 <code>res = 0 + 1</code> 。此时计算机会立即计算出 <code>res</code> 的值是 <code>1</code>。并将这个 <code>res</code> 值写入内存，以备下一次的循环调用。</p><p>接着，我们使用栈来重写这段代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">stack = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">9</span>, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">    stack.append(i)</span><br><span class="line"></span><br><span class="line">res = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> stack:</span><br><span class="line">    res += stack.pop()</span><br><span class="line"></span><br><span class="line">print(res)      <span class="comment"># 45</span></span><br></pre></td></tr></table></figure><p>这里我们做了一个重要的改变，即，我们先使用 <code>for</code> 循环将要计算的数据放入 <code>stack</code> 中，再将它们依次取出并累加。你可以看到我们这里将栈当成了一个 <code>待办事项清单</code> 来存储数据，并在适宜的时候弹出。</p><p>栈中每一个元素都包含了当前计算步骤所需的全部信息。另外的，栈中元素的顺序事实上就是计算的顺序信息。</p><p>接下来，我们使用递归再次的完成这个功能：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    curr_res = n + add(n<span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> curr_res</span><br><span class="line"></span><br><span class="line">res = <span class="number">0</span> + add(<span class="number">9</span>)</span><br><span class="line"></span><br><span class="line">print(res)      <span class="comment"># 45</span></span><br></pre></td></tr></table></figure><p>你可能会认为这与之前的用栈实现的思路完全不同，我会解释为什么在本质上它们是相同的。但在这之前，我需要引述 SICP 第二章的一个核心思想之一：</p><ul><li>数据与过程之间并没有明显的界限</li></ul><p>如何理解这段话？你可以观察上面那个实现的这行代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curr_res = n + add(n<span class="number">-1</span>)</span><br></pre></td></tr></table></figure><p>有一定 <code>Python</code> 语法基础的读者会发现，<code>add(n-1)</code> 是一个函数调用。而函数是什么？函数是一组过程的集合。但在这里你会发现，我们模糊了过程与数据的定义。我们直接将 <code>add(n-1)</code> 作为一个数据使用了。</p><p>而这样做的意义是什么？事实上，就是压栈。</p><p>如果你学习过关于程序设计语言中函数的调用相关内容的话，你应该会知道函数调用相关的信息是存储在一个被称为 <code>调用栈</code> 的东西中的。</p><p>我们通过 <code>add(n-1)</code> 这样的调用，将 <code>add(n)</code> 这一层信息压入栈中，以待将来使用。那么，什么时候停止压栈呢？就是我们的 <code>待办事项清单</code>，也就是调用栈中已经存储满了整个计算所需要的数据的时候。</p><p>而这个停止的标志，就是</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p>事实上，你可以看出，这就是我们的栈 <code>pop()</code> 出的第一个元素。</p><p>那么，既然栈开始工作了，我们就需要依次的处理弹出的元素。其中，栈已经帮我们维护好了计算顺序，所以我们只需要关心在每一步具体需要做什么计算就可以了。在上面等差数列求和的例子中，我们对于每一步的操作是这段代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> curr_res</span><br></pre></td></tr></table></figure><p>使用代换模型，事实上是这段：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> n + add(n<span class="number">-1</span>)</span><br></pre></td></tr></table></figure><p>每当一个递归函数从调用栈返回的时候，都会有一个曾经被记录好的携带着局部变量 n 的调用信息被弹出。而 <code>n + add(n-1)</code> 就是我们的计算公式。</p><p>事实上读到这里你也会发现，递归其实就是计算机帮助我们维护了一个栈。尽管和我们自己维护的栈在元素信息上有所不同，但本质上它们是一样的。</p><h1 id="几道-leetcode-原题"><a class="markdownIt-Anchor" href="#几道-leetcode-原题"></a> 几道 leetcode 原题</h1><blockquote><p>在解释里我可能会混用 “调用栈” 与 “栈” 的概念，尽管从逻辑上来讲它们是相同的</p></blockquote><p>实践是检验真理的唯一标准。那么我们就解释几道 leetcode 中应用递归可以解答的题目。</p><h2 id="合并两个有序链表"><a class="markdownIt-Anchor" href="#合并两个有序链表"></a> 合并两个有序链表</h2><p>leetcode 的 21 题，<a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/" target="_blank" rel="noopener">合并两个有序链表</a><br />给定两个升序链表，将其合并为一个新的升序链表并返回。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span><br><span class="line">输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><br></pre></td></tr></table></figure><p>我们首先来分析这个问题。题目要求合并两个升序链表，这其中的关键是 <code>升序</code>。换句话说，对于链表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1-&gt;2-&gt;4</span><br></pre></td></tr></table></figure><p>和链表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1-&gt;2</span><br></pre></td></tr></table></figure><p>在题目中是等效的。也就是说，我们可以将原题缩小为一个较小规模的问题，而对于这个较小规模问题的解答，实际上是和原题是一样的。这也就意味着，这道题可以使用递归的思想来解答。</p><p>接下来，我们用栈的思想来分析一下这个递归的逻辑。</p><p>首先，题目要求我们输出一个升序的链表。这也就意味着我们在栈中存储的元素应该是降序的。<br />其次，栈顶元素，或者说第一个被弹出的元素是什么？应该是两个链表中最大的那个元素，也就是 4。至于这个数字具体是哪个链表中的实际上并不重要。<br />最后，对于每一个弹出的元素我们应该干啥？因为我们要输出的是一个链表，而大小顺序的信息就是栈中元素的信息，所以我们将元素连接起来就行了。</p><p>另外的，尽管这里有两个链表需要处理，但这并不意味着我们需要搞两个递归函数。你要记得递归事实上是在整理数据的顺序，而不是遍历什么东西。</p><p>然后我们会在每一个递归的时候进行压栈。前面说了，我们最终是想得到一个元素递减的栈。所以我们就需要在把这俩链表中较小的那个元素压入栈。也就是说，我们需要一个比较大小的逻辑。</p><p>最后，我们对于节点的定义是这样的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, val=<span class="number">0</span>, next=None)</span>:</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.next = next</span><br></pre></td></tr></table></figure><p>所以我们只需要对 <code>node.next</code> 赋值，就能连接起来链表了。</p><p>完整的代码应该是这样的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span><span class="params">(self, l1: ListNode, l2: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 这两个是弹出栈顶元素</span></span><br><span class="line">        <span class="comment"># 也就是说，两个链表中最后剩下的那个元素就是最大的</span></span><br><span class="line">        <span class="keyword">if</span> l1 <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> l2</span><br><span class="line">        <span class="keyword">elif</span> l2 <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> l1</span><br><span class="line"></span><br><span class="line">        <span class="keyword">elif</span> l1.val &lt; l2.val:</span><br><span class="line">            <span class="comment"># 实际上是把 l1 压入了栈，并将指针指向了 l1.next</span></span><br><span class="line">            l1.next = self.mergeTwoLists(l1.next, l2)</span><br><span class="line">            <span class="keyword">return</span> l1</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            l2.next = self.mergeTwoLists(l1, l2.next)</span><br><span class="line">            <span class="keyword">return</span> l2</span><br></pre></td></tr></table></figure><h2 id="反转链表"><a class="markdownIt-Anchor" href="#反转链表"></a> 反转链表</h2><p>leetcode 的 206 题，<a href="https://leetcode-cn.com/problems/reverse-linked-list/" target="_blank" rel="noopener">反转链表</a><br />反转一个单项链表。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span><br></pre></td></tr></table></figure><p>我们依旧使用栈的思想来分析。</p><p>栈中存储的元素顺序应该是原链表的逆序。幸运的是，基于栈的特点，我们只需要遍历栈就可以得到了。<br />栈顶元素？当下一个元素是 <code>NULL</code>。也就是说，到这个时候，我们遍历完了栈。<br />每一个元素的处理？很简单，将节点向后的指向改为向前即可。</p><p>下面是完整的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="comment"># 边界条件</span></span><br><span class="line">        <span class="keyword">if</span> head <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 栈顶元素</span></span><br><span class="line">        <span class="keyword">if</span> head.next <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line">        next_node = self.reverseList(head.next)</span><br><span class="line"></span><br><span class="line">        head.next.next = head</span><br><span class="line">        head.next = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> next_node</span><br></pre></td></tr></table></figure><p>需要注意的是，在这道题中，我们对于每一个元素的处理实际上是这两行代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">head.next.next = head</span><br><span class="line">head.next = <span class="literal">None</span></span><br></pre></td></tr></table></figure><p><code>next_node</code> 仅仅是记录了将要弹出的元素。<br />换句话说，我们可以将弹出元素的操作分开为两行代码。这两行代码之间的就是对当前元素的处理逻辑。</p><h2 id="最长同值路径"><a class="markdownIt-Anchor" href="#最长同值路径"></a> 最长同值路径</h2><p>leetcode 的 687 题，<a href="https://leetcode-cn.com/problems/longest-univalue-path/" target="_blank" rel="noopener">最长同值路径</a><br />给定一个二叉树，找到一条最长路径，路径所经过节点的值都相同。路径可以经过根节点也可以不经过。两节点间的路径长度由它们之间的边数表示。</p><p>首先，需要注意到，任何一颗二叉树都是由这样的节点组成的：</p><p><img src="https://bebopfzj.oss-cn-hangzhou.aliyuncs.com/uPic/2020-08-26-ZzAnSH.png" alt="树的节点" /></p><p>当然了，其中 <code>B</code> 和 <code>C</code> 可以为 <code>NULL</code>。在这种情况下，<code>A</code> 也被称为叶子节点。</p><p>有了这个认识之后，我们就会很清楚的看出，这道题中处理的最小单元就是这样的一个节点组。其中 <code>B</code> 和 <code>C</code> 可以通过指针访问到。所以你只需要这样一个节点组中的“根节点”即可完整的描述整个节点组。（注意这里的根节点并不指代整棵树的根节点）换句话说，我们压入栈的基本元素应该是这个“根节点”。</p><p>接下来就是要思考压栈的顺序了。众所周知，二叉树有两种遍历方式，即深度优先和广度优先。但注意到题目中提到了一件事，即这条最长路径可能经过根节点也可能不经过。这就意味着，我们如果从根节点就开始访问节点本身，那么对于这样的树：</p><p><img src="https://bebopfzj.oss-cn-hangzhou.aliyuncs.com/uPic/2020-08-26-1wfaPE.png" alt="不经过树根节点的最长路径" /></p><p>我们不可能找到最长路径的。因为没有其他任何一个节点的值与根节点相同。所以我们选择后序遍历，从最后一个叶子节点开始访问整棵树。</p><p>后序遍历很好理解，我们会先持续的访问左子树，并将所有经过的节点压入栈。当这条路径进行到终点，即 <code>node.left == None</code> 的时候，就算做完了准备工作。顺便提一句，我们并没有将树中所有的元素都压入栈，但我们已经将访问整棵树的所有 <strong>必须信息</strong> 都压入了栈。因为我们每弹出一个节点，都会检查其右子树，如果右子树存在，那么就会继续检查右子树的左子树。通过有限步访问，我们就能遍历完整棵树。</p><p>另外因为是“最长 <strong>同值</strong> 路径”，所以我们对于每一个元素的处理就是检查其“根节点”与子节点值是否相等。</p><p>不过你需要注意一件事，就是不一定每一个节点都在我们要寻找的最长同值路径上。所以我们不能将路径长度的信息也放入栈进行维护。</p><p>所以我们可以写出代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestUnivaluePath</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        self.res = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(node: TreeNode)</span> -&gt; int:</span></span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 左子树的最长同值路径</span></span><br><span class="line">            left = helper(node.left)</span><br><span class="line">            <span class="comment"># 右子树的最长同值路径</span></span><br><span class="line">            right = helper(node.right)</span><br><span class="line"></span><br><span class="line">            curr_left, curr_right = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> node.left <span class="keyword">and</span> node.val == node.left.val:</span><br><span class="line">                curr_left = left + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> node.right <span class="keyword">and</span> node.val == node.right.val:</span><br><span class="line">                curr_right = right + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            self.res = max(self.res, curr_left + curr_right)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 注意传递的信息是子树的最长同值路径</span></span><br><span class="line">            <span class="comment"># 较短的那条就没必要传了</span></span><br><span class="line">            <span class="keyword">return</span> max(curr_left, curr_right)</span><br><span class="line"></span><br><span class="line">        helper(root)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从合并排序数组谈谈指针遍历</title>
      <link href="/2020/08/22/doublepointer/"/>
      <url>/2020/08/22/doublepointer/</url>
      
        <content type="html"><![CDATA[<h1 id="leetcode-原题"><a class="markdownIt-Anchor" href="#leetcode-原题"></a> leetcode 原题</h1><p>你可以在<a href="https://leetcode-cn.com/problems/sorted-merge-lcci/" target="_blank" rel="noopener">这里</a>找到原题。<br />给定两个排序后的数组，其中一个数组末端有足够的空间容纳另一个数组，同时给出两个数组的元素数量。将两个数组合并并排序。</p><p>一个很容易想到的思路就是 <strong>双指针遍历</strong>。<br />也就是说，我们可以创建一个缓存的新数组 <code>res</code>，然后同时遍历两个给定数组。可能有以下几种情况：</p><ol><li>A 的元素比 B 的大 —— 将 B 的元素推入 res</li><li>B 的元素比 A 的大 —— 将 A 的元素推入 res</li><li>A 的元素遍历完了 —— 直接将 B 的元素推入 res</li><li>B 的元素遍历完了 —— 直接将 A 的元素推入 res</li></ol><a id="more"></a><p>按照这个思路，可写出代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, A: List[int], m: int, B: List[int], n: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line">        index_of_a, index_of_b = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> index_of_a &lt; m <span class="keyword">or</span> index_of_b &lt; n:</span><br><span class="line">            <span class="keyword">if</span> index_of_a == m:</span><br><span class="line">                res.append(B[index_of_b])</span><br><span class="line">                index_of_b += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> index_of_b == n:</span><br><span class="line">                res.append(A[index_of_a])</span><br><span class="line">                index_of_a += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> A[index_of_a] &lt; B[index_of_b]:</span><br><span class="line">                res.append(A[index_of_a])</span><br><span class="line">                index_of_a += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.append(B[index_of_b])</span><br><span class="line">                index_of_b += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        A[:] = res</span><br></pre></td></tr></table></figure><p>事实上，指针遍历的核心就是控制 index 的值，以及各种边界条件下的行为。特别是在循环语句中，你应当清楚地知道循环会停在哪里。</p><h1 id="另一种解法"><a class="markdownIt-Anchor" href="#另一种解法"></a> 另一种解法</h1><p>从上面的代码中，我们可以很清楚的看到，为了避免覆盖 A 数组，我们另行创建了一个缓存数组 res 来存储每次遍历的产出值。这样的确容易理解，但会产生额外的空间复杂度。</p><p>在原题中，为了容纳数组 B，数组 A 后面都有足够的容量来容纳 B。而题目最终要求我们提供一个排序后的数组。那么我们可以考虑反向遍历这两个数组。对于较大的值则放入 A 的尾部。这样既保证了按序，同时也不会覆盖 A 的元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, A: List[int], m: int, B: List[int], n: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line"></span><br><span class="line">        index_of_a, index_of_b = m - <span class="number">1</span>, n - <span class="number">1</span></span><br><span class="line">        end = m + n - <span class="number">1</span>     <span class="comment"># 在数组 A 填入的位置</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> index_of_a &gt;= <span class="number">0</span> <span class="keyword">or</span> index_of_b &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> index_of_a == <span class="number">-1</span>:</span><br><span class="line">                A[end] = B[index_of_b]</span><br><span class="line">                index_of_b -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> index_of_b == <span class="number">-1</span>:</span><br><span class="line">                A[end] = A[index_of_a]</span><br><span class="line">                index_of_a -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> A[index_of_a] &gt; B[index_of_b]:</span><br><span class="line">                A[end] = A[index_of_a]</span><br><span class="line">                index_of_a -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                A[end] = B[index_of_b]</span><br><span class="line">                index_of_b -= <span class="number">1</span></span><br><span class="line">            end -= <span class="number">1</span></span><br></pre></td></tr></table></figure><p>你可能疑惑，这个解法如何保证 A 的元素一定不会被覆盖？<br />考虑当数组 A 遍历至 index_of_a 而 B 遍历至 index_of_b 时，数组 B 有 n - index_of_b - 1 个元素被推入数组 A。而数组 A 有 m - index_of_a - 1 个元素被复制进数组 A 的尾部。那么此时，数组 A 的尾部有</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext> </mtext><mi>n</mi><mo>−</mo><mi>i</mi><mi>n</mi><mi>d</mi><mi>e</mi><mi>x</mi><mi mathvariant="normal">_</mi><mi>o</mi><mi>f</mi><mi mathvariant="normal">_</mi><mi>b</mi><mo>−</mo><mn>1</mn><mo>+</mo><mi>m</mi><mo>−</mo><mi>i</mi><mi>n</mi><mi>d</mi><mi>e</mi><mi>x</mi><mi mathvariant="normal">_</mi><mi>o</mi><mi>f</mi><mi mathvariant="normal">_</mi><mi>a</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\ n - index\_of\_b - 1 + m - index\_of\_a - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mspace"> </span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.00444em;vertical-align:-0.31em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.00444em;vertical-align:-0.31em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></p><p>个元素。<br />而此时 index_of_a 指针后还有 m + n - index_of_a - 1 的空间。注意 index_of_a 后面的元素是已经被遍历了的，这些元素即使被覆盖了也无妨。</p><p>假设 A 数组的尾部此时已经无法容纳填充进来的元素了，我们可以得到不等式：</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext> </mtext><mi>m</mi><mo>+</mo><mi>n</mi><mo>−</mo><mi>i</mi><mi>n</mi><mi>d</mi><mi>e</mi><mi>x</mi><mi mathvariant="normal">_</mi><mi>o</mi><mi>f</mi><mi mathvariant="normal">_</mi><mi>a</mi><mo>−</mo><mn>1</mn><mo>&lt;</mo><mi>n</mi><mo>−</mo><mi>i</mi><mi>n</mi><mi>d</mi><mi>e</mi><mi>x</mi><mi mathvariant="normal">_</mi><mi>o</mi><mi>f</mi><mi mathvariant="normal">_</mi><mi>b</mi><mo>−</mo><mn>1</mn><mo>+</mo><mi>m</mi><mo>−</mo><mi>i</mi><mi>n</mi><mi>d</mi><mi>e</mi><mi>x</mi><mi mathvariant="normal">_</mi><mi>o</mi><mi>f</mi><mi mathvariant="normal">_</mi><mi>a</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\ m + n - index\_of\_a - 1 &lt;  n - index\_of\_b - 1 + m - index\_of\_a - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mspace"> </span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.00444em;vertical-align:-0.31em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.00444em;vertical-align:-0.31em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.00444em;vertical-align:-0.31em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></p><p>整理可得：</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext> </mtext><mi>i</mi><mi>n</mi><mi>d</mi><mi>e</mi><mi>x</mi><mi mathvariant="normal">_</mi><mi>o</mi><mi>f</mi><mi mathvariant="normal">_</mi><mi>b</mi><mo>&lt;</mo><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\ index\_of\_b &lt; -1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00444em;vertical-align:-0.31em;"></span><span class="mspace"> </span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span></p><p>根据题意，当 index_of_b 等于 -1 的时候，数组 B 就已经被遍历完了。所以得到的不等式不成立，立即推，数组 A 的尾部可以容纳填充进来的元素。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从反转链表谈谈递归</title>
      <link href="/2020/08/21/reverseList/"/>
      <url>/2020/08/21/reverseList/</url>
      
        <content type="html"><![CDATA[<h1 id="反转链表"><a class="markdownIt-Anchor" href="#反转链表"></a> 反转链表</h1><p>关于反转链表的题目已经是老生常谈了。主要的解法有双指针迭代和递归两种。这里仅仅谈谈递归。<br />你可以在 <a href="https://leetcode-cn.com/problems/reverse-linked-list/" target="_blank" rel="noopener">这里</a> 找到原题。</p><p>下面是题解：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> head <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> head.next <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line">        next_node = self.reverseList(head.next)</span><br><span class="line">        head.next.next = head</span><br><span class="line">        head.next = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> next_node</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="递归"><a class="markdownIt-Anchor" href="#递归"></a> 递归</h1><p>从定义上将，程序调用自身的行为便称为递归。想要使用递归解决问题，需要注意以下两个方面：</p><ol><li>问题可以拆分为层次性的子问题，且子问题更容易解答</li><li>递归需要有出口，即停止点</li></ol><p>在上面反转链表的例子中，可以这样考虑：</p><ul><li>如果要反转整个链表，那么我需要得到一个仅剩一个元素没有反转的链表，然后直接翻转那个最后的元素即可</li><li>如果要完成上面的任务，我们需要一个仅剩两个元素没有反转的链表</li><li>同理</li></ul><p>而翻转链表的出口就是当我执行到了最后一个元素的时候，就完成了整个操作。而对最后一个元素的操作是这样的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">head.next.next = head</span><br><span class="line">head.next = <span class="literal">None</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于并发——从一道 leetcode 原题说起</title>
      <link href="/2020/08/21/concurrency/"/>
      <url>/2020/08/21/concurrency/</url>
      
        <content type="html"><![CDATA[<p>并发应该是一个老生常谈的主题了，尽管它并不是那么好理解。我们这里从一道 leetcode 原题开始，详细阐述一下这个主题。<br />文中涉及的内容大部分是从各个地方找的，在文章结尾我会放上参考资料的链接。</p><h2 id="按序打印"><a class="markdownIt-Anchor" href="#按序打印"></a> 按序打印</h2><p>这是一道 leetcode 原题，你可以在 <a href="https://leetcode-cn.com/problems/print-in-order/" target="_blank" rel="noopener">这里</a> 读到原题。简单来说，就是我们需要设计一个类，从而实现方法的按序执行。</p><p>使用 <code>JAVA</code> 语言的 <code>volatile</code> 关键字可以很轻松的解决掉这道题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Foo</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">first</span><span class="params">(Runnable printFirst)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        printFirst.run();   <span class="comment">// this method output "first"</span></span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">second</span><span class="params">(Runnable printSecond)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (index != <span class="number">2</span>);</span><br><span class="line">        printSecond.run();</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">third</span><span class="params">(Runnable printThird)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (index != <span class="number">3</span>);</span><br><span class="line">        printThird.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>题解的思路很好理解。我们实际上是构造了一道屏障，对于满足条件的方法就令其执行，不满足的就先等着。在这里 <code>volatile</code> 是一个核心。当只有一个变量，且同一时间只有一个线程执行写操作，而其他线程执行读操作时，可以考虑使用这个关键字。</p><a id="more"></a><h2 id="并发问题的根源"><a class="markdownIt-Anchor" href="#并发问题的根源"></a> 并发问题的根源</h2><p>很多语言都有一套自己的并发场景解决方案，当然有些像 Go 这种，就是原生支持。有些像 Java 则是自己给出了一套方案。但不管具体的写法怎么样，我们想要理解这些语言的解决方案，就得先了解问题的根源，也就是到底是计算机哪一部分的设计导致了这些问题。</p><p>下面我们逐一的分析一下原因。</p><h3 id="根源一多核-cpu-缓存的相互不可见"><a class="markdownIt-Anchor" href="#根源一多核-cpu-缓存的相互不可见"></a> 根源一：多核 CPU 缓存的相互不可见</h3><p>考虑一个单核 CPU 的工作场景。一般情况下，CPU 工作所需数据都是持久化的存储在磁盘上的。为了使用这部分数据，数据首先要被拷贝到内存中，然后 CPU 拷贝到 CPU 缓存中。实际场景可能会涉及到数据的切分，CPU 工作调度什么的，但我们仅仅考虑如前所述的简单模型。这时候不论我们启动了多少个线程，它们访问的 CPU 缓存都是同一个。所以操作结果就不存在所谓的可见性问题了。<br />而当我们将单核 CPU 替换为多核 CPU 的时候，问题就来了。我们很难控制某一个线程具体由哪个 CPU 核心来执行，换句话说，线程自己根本不知道它访问的是哪一个 CPU 缓存。那么如果多个线程间同时操作一个共享变量，就会导致该变量的不确定性。因为缓存间是不可见的，谁也不知道这个变量是新的还是旧的。</p><h3 id="根源二cpu-切换线程导致的原子性问题"><a class="markdownIt-Anchor" href="#根源二cpu-切换线程导致的原子性问题"></a> 根源二：CPU 切换线程导致的原子性问题</h3><p>在计算机中，IO、内存和 CPU 读写速度差异巨大。所以为了提高 CPU 的利用率，人们开发了很多任务调度算法，比如著名的多级反馈队列（MLFQ）。但不管是哪种调度算法，其中都包含着一个关键性的操作：即在适当的时候切换进程。同时为了保证操作系统对计算机硬件绝对的控制，所有的进程都是 <code>受限执行</code> 的。同时操作系统还开发了加锁（locking）方案，以解决并发情况下数据的访问问题。</p><p>随后为了进一步提高 CPU 在切换进程方面的效率，操作系统又产生了线程这个概念，以更精细化的调度任务。</p><p>这些措施都提高了硬件的利用路，但却产生了原子性的问题。</p><p>例如我们有如下语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> number = <span class="number">1</span>;</span><br><span class="line">number = number + <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>对于第二句，CPU 实际在执行的时候并不是原子性的。如果你想了解更多，你可以将代码改写为 Python，并使用 dis 来详细了解实际执行的汇编指令。但在这里我们仅仅分析其可能进行的操作：</p><ol><li>CPU 将 number 从内存拷贝到 CPU 缓存</li><li>将 number 进行 +1 操作</li><li>将得到的新 number 回写到内存</li></ol><p>你可以清楚的看出，这行代码并不是原子性的，它可能包含多个实际步骤。而 CPU 在调度任务时并不会关心实际代码逻辑，它可能在任意一点进行切换。这就导致了 B 线程读取到的 number 可能是 A 线程执行完 +1 操作后的值。</p><h3 id="根源三编译器优化带来的指令重排序问题"><a class="markdownIt-Anchor" href="#根源三编译器优化带来的指令重排序问题"></a> 根源三：编译器优化带来的指令重排序问题</h3><p>比如下面这句代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyClass instance = <span class="keyword">new</span> MyClass();</span><br></pre></td></tr></table></figure><p>在实际执行中，会被分解为三个指令：</p><ol><li>为对象分配内存空间</li><li>在分配的内存空间实例化对象</li><li>将 instance 引用地址指向内存空间</li></ol><p>但在某些时候，编译器可能会对指令进行优化，从而导致指令顺序变成：</p><ol><li>为对象分配内存空间</li><li>将 instance 引用地址指向内存空间</li><li>在分配的内存空间实例化对象</li></ol><p>而这样如果是并发访问的话，可能会导致新线程拿到了旧线程还未实例化完全的对象，从而引发错误。</p><h2 id="关于并发和并行"><a class="markdownIt-Anchor" href="#关于并发和并行"></a> 关于并发和并行</h2><p>这段内容和主题关系不大，不过这是两个很容易就会弄混的词，所以说明一下。<br />简单来说，并发指的是一种程序的设计结构，而并行指的是运行时的状态。</p><p>并发事实上是认为设计的，它使得多个操作可以在重叠的时间段内进行。<br />而并行则是同时执行。如果同一时刻有多个工作单位在运行，那么就是并行状态。比如 Python 因为它的 GIL，所以实际上是不可能存在并行状态的。</p><h2 id="java-的解决方案"><a class="markdownIt-Anchor" href="#java-的解决方案"></a> Java 的解决方案</h2><p>这里我们先考虑一下 Java 的解决方案。因为目前后端的主流语言还是 <code>Java</code>，在读写数据库或者做其他工作的时候，很容易遇到这个问题。</p><h3 id="volatile"><a class="markdownIt-Anchor" href="#volatile"></a> volatile</h3><p>这个关键字就是文章开头题解的关键了。<br />此关键字有两个特性：</p><ol><li>保证变量的可见性，不保证原子性。在写一个 volatile 变量时，JVM 会强制将本地内存的变量刷新到主内存中，也就是覆盖了其他线程的缓存。</li><li>禁止指令重排。</li></ol><p>如果有一个变量，在同一时间只有一个线程执行写操作，其他线程都只是读操作，那么就可以使用 volatile 来修饰这个变量。因为不能保证原子性，所以如果同时有多个线程写的话，就不能用这个了。</p><p>在 JVM 底层，volatile 使用了 <strong>内存屏障</strong>。其提供了三个功能：</p><ol><li>使用内存屏障强制控制某些语句编译出来的指令顺序，确保他们按照一定的顺序执行</li><li>强制将缓存的修改操作立即写到主内存</li><li>写操作会使其他 CPU 中的缓存失效，使其他线程只能从主内存读取数据</li></ol><h3 id="synchronized"><a class="markdownIt-Anchor" href="#synchronized"></a> Synchronized</h3><p>如果你一定要多个线程同时写一个变量，那么你可以使用这个关键字。</p><p>（未完待续）</p><h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2><ol><li><a href="https://zhuanlan.zhihu.com/p/64988344" target="_blank" rel="noopener">并发问题产生的三大根源</a></li><li><a href="https://mp.weixin.qq.com/s/K9gsRxy9idy2_k6Gbmyw9g" target="_blank" rel="noopener">让我们找出并发编程 bug 的罪魁祸首吧！</a></li><li><a href="https://laike9m.com/blog/huan-zai-yi-huo-bing-fa-he-bing-xing,61/" target="_blank" rel="noopener">还在疑惑并发和并行？</a></li><li><a href="https://juejin.im/post/6844903941830869006#heading-3" target="_blank" rel="noopener">面试官：说说多线程并发问题</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 核心概念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发 </tag>
            
            <tag> 锁 </tag>
            
            <tag> CPU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>给懒人的伸缩性讲解</title>
      <link href="/2020/08/19/Scalability/"/>
      <url>/2020/08/19/Scalability/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文是 <a href="https://www.lecloud.net/tagged/scalability/chrono" target="_blank" rel="noopener">Scalability for Dummies</a> 的翻译。文中提及的具体技术可能过时，但思想依然很值得参考</p></blockquote><h2 id="克隆"><a class="markdownIt-Anchor" href="#克隆"></a> 克隆</h2><p>最近有人问我，需要做点什么才能让 Web 服务器具有可伸缩性。我的回答很长，并且其他人可能会对这个主题感兴趣。所以写了这篇文章放在 Blog 里，并将其划分为几个主题，以确保容易阅读。祝您阅读愉快，欢迎评论，</p><p>提供可伸缩 Web 服务的公共服务器通常都隐藏在负载均衡器之后。这个负载均衡器会将流量（来自于用户的请求）均匀的分配给你的应用程序服务器组/集群。这意味着，比如，用户 Steve 访问了你的服务器。他的第一个请求可能被转发给 2 号服务器，他的第二个请求可能被转发给 9 号 服务器，他的第三个请求可能又会被转发给 2 号服务器。</p><p>Steve 应该从每次的访问中取得相同的结果，而不是依赖于他具体访问了哪个服务器。这就引出了可伸缩性的第一条黄金准则：每一个服务器都应该包含完全相同的代码库，而不应该存储任何用户相关的数据，例如 session 或者用户头像在服务器的磁盘或者内存中。</p><p>session 需要被集中存储在一个数据库中，这个数据库需要可以被所有你的应用服务器访问。它可以是一个外部数据库，或者是外部的持久缓存库，例如 Redis。外部持久缓存库的性能通常比外部数据库好。我所说的“外部”，指的是数据不存储在应用程序服务器上。相反的，它应该在数据中心或是你的应用服务器附近。</p><p>但是部署呢？我怎么能确定代码的修改被推送到了所有服务器上，而没有一台服务器仍然跑着旧代码？幸运的是，这个棘手的问题已经被一个很牛逼的工具 Capistrano 解决了。这需要你学习一下，特别是如果你不太懂 Ruby on Rails，你可能需要付出两倍的努力。</p><p>在将你的 sessions 外包，并且为所有的服务器提供相同代码之后，你可以用这些服务器其中一个的代码构建一个镜像。将这个镜像作为新实例的 “超级克隆”。每当启动一个新实例的时候，只需要对最新代码进行部署，就可以准备好了！</p><a id="more"></a><h2 id="数据库"><a class="markdownIt-Anchor" href="#数据库"></a> 数据库</h2><p>如果你遵守了上一节的内容，那么你的服务器现在已经可以横向扩展了，并且还可以为数千个并发请求提供服务了。但随着时间的推移，你的应用程序会变得越来越慢，然后最终挂掉。而这一切的原因就是你的数据库，MySQL，不是吗？</p><p>现在需要做的改变可能要比仅仅增加一些相同的服务器更加激进一些，并且有些时候可能需要一些大胆的举措。你可以选择以下两种举措：</p><ul><li><p>PATH 1 坚持使用 MySQL，并保持 “野兽” 运行。雇佣一个 DBA，告诉他去做一些主-从复制（从服务器读取，向主服务器写入），然后给你的主服务器增加更多的 RAM。几个月后，你的 DBA 可能会想到 分页、反规范化、SQL 调优 等关键词，并且开始担心接下来几周的加班。接下来，每一个保持数据库运行的行为都将比前一个操作花费更多的时间与成本。如果你的数据集很小并且容易迁移，那么你可以选择路径二，这可能会是一个更好的选择。</p></li><li><p>PATH 2 从一开始就取消规范化，并且在任何数据库查询中都不包含 <code>join</code> 。你可以依旧使用 MySQL，然后像使用 NoSQL 数据库那样使用它。或者你可以转移到一个更好、更容易迁移的 NoSQL 数据库，例如 MongoDB 或者 CouchDB。数据的链接现在需要在你的应用程序代码中做了。你越早开始做这件事，你就会在未来更改越少的代码。但即使你成功的切换到了最新、最好的 NoSQL 数据库，并且让你的应用程序做数据连接的工作。一段时间之后，你的数据库又会变得越来越慢。这时候你就需要缓存了。</p></li></ul><h2 id="缓存"><a class="markdownIt-Anchor" href="#缓存"></a> 缓存</h2><p>在完成了上一节的内容，你现在已经拥有了一个可伸缩的数据库解决方案。您将不必担心在存储 tb 级别的数据时出什么问题。不过一旦用户想要一口气从数据库中提取很多数据的时候，他们仍将忍受非常慢的数据库请求速度。解决办法是实现缓存。</p><p>当我提到“缓存”时，我一般指的是内存缓存，例如 Memcached 或者 Redis。请绝对不要做基于文件的缓存，这会使得克隆和自动扩展服务器变成一件非常痛苦的事。</p><p>回到内存缓存。缓存是简单的 key-value 存储，并且应该作为应用程序和数据储存的中间层。每当应用需要读取数据的时候，它应该先尝试从缓存中获取。只有当缓存中不存在想要的数据时，才会尝试去主数据库中获取。为什么你得这样做？因为缓存是超级快的。它将每个数据集都保存在 RAM 中，并且每一次请求都会处理的非常快。例如，一个托管在标准服务器上的 Redis 可以做到每秒数十万次的读取操作。特别是增量，非常非常的快，你真的应该尝试一下！</p><p>这里有两种缓存数据的模式，一种旧的，一种新的：</p><h3 id="1-缓存数据库查询"><a class="markdownIt-Anchor" href="#1-缓存数据库查询"></a> 1 - 缓存数据库查询</h3><p>这仍然是最常用的缓存模式。每当你从数据库获取数据了，你都会将获取结果缓存下来。查询结果的 hash 结果就是缓存的 key。等下次你再运行查询时，你应当首先检查一下它是否已经存储在缓存中了。再下次运行查询时，你应当检查一下查询结果是否已经存储在缓存中了。这种模式有几个问题。主要的问题就是缓存到期，当你缓存了一个复杂的查询结果时，你很难将其删除。当其中一小段数据发生改变，例如一个表格单元格，你可能不得不删除所有包含该单元格的缓存数据。你明白我想要表达的了 🐎？</p><h3 id="2-缓存对象"><a class="markdownIt-Anchor" href="#2-缓存对象"></a> 2 - 缓存对象</h3><p>这是我强烈推荐的，并且我也一直比较喜欢使用这种模式。通常的，将你的数据看作是对象，就像是你已经在代码中做的那样（例如类，对象什么的）。让类从数据库中组装数据集，然后将类的完整实例或者是组装好的数据集整个儿的存储到缓存中去。听起来好像有点纸上谈兵，我懂，不过看看你平常是怎么写代码的。例如，你有一个名为 <code>Product</code> 的类，然后这个类有一个名为 <code>data</code> 的属性。这是一个数组，其中包含了产品的价格、文本、图片，还有用户评价。属性 <code>data</code> 由类中的多个方法通过对数据库的多个请求来填充，这种数据很难缓存，因为很多数据都是相互关联的。现在，你可以这么做：当你完成了对数据数组的组装之后，就将其整个的存储下来，或者更好的是，将类的整个实例存储在缓存中。这可以让你在其中某些部分发生变化时，更快的处理好对象，让整体的阿代码更快、更有逻辑性。</p><p>更大的好处是：这使得异步处理成为可能。想象一下，你有一大堆服务器可以为你组装对象，而应用程序只需要使用最新的缓存对象，而不必去接触数据库了。</p><p>一些缓存对象的想法：</p><ul><li>用户的 session （绝对不要使用数据库！）</li><li>完全渲染的博客文章</li><li>活动流</li><li>用户的社交关系</li></ul><p>也许你已经意识到了，我是缓存的超级粉丝。这很好理解，因为缓存很好实现，并且效果惊人。通常，我更喜欢使用 Redis 而不是 Memcached，因为我更喜欢前者额外的数据库特性比如持久化，并且它还有一些内建的数据结构，例如 list 和 set。通过使用 Redis，并且赋予适当的 key，你甚至可以摆脱数据库。但如果你只需要缓存，那么就使用 Memcached 吧，它的伸缩性更好。</p><p>HAPPY CAHCHING ！</p><h2 id="异步"><a class="markdownIt-Anchor" href="#异步"></a> 异步</h2><p>第四部分将从一个场景开始：想象一下你正在你最喜欢的面包店买面包。你进入面包店，并且向店员询问面包，但店里的面包已经卖完了！相反的，他们告诉你，你想要的面包得两个小时之后才能做好，这很烦人，不是 🐎？</p><p>为了避免这种“请等一下”的状况，你需要做一些 <code>异步</code> 的工作。这对面包店有好处，当然也对你的 Web 服务有好处。一般来说，有两种方法/范式可以实现异步。</p><h3 id="方法一"><a class="markdownIt-Anchor" href="#方法一"></a> 方法一</h3><p>让我们重新考虑面包店的例子。第一种实现异步过程的方法是，晚上烤面包，早晨卖。没有等待，即到即取。在 Web 服务中，这指的是提前完成耗时的请求，这样当用户的请求抵达时，就能更快的完成了。</p><p>这种范式通常用于将动态内容转化为静态内容。网站的页面可能是使用大型框架或者 CMS 来构建的，每次更改时都以静态 HTML 文件的形式呈现并且存储在本地。这些计算任务通常是定期完成的，可能是使用脚本，通过定时任务每小时固定执行。这种对总体数据进行预编译的方法可以额极大的改善网站和应用程序，并且让其更具有扩展性和高性能。想象一下，如果使用脚本将你的网站的预编译 HTML 文档上传到 AWS S3 或者 Cloudfront 或者其他 CDN 中，你的网站将会有非常快的响应速度，每小时能处理上百万的请求！</p><h3 id="方法二"><a class="markdownIt-Anchor" href="#方法二"></a> 方法二</h3><p>再次回到面包店的例子。不幸的是，有些时候用户可能会有一些特殊的要求，比如他们可能想要一个上面写有 “Happy Birthday, Steve!” 字样的生日蛋糕。面包店不可能预先想到客户的这种需求，所以只有当客户到面包店提出这种需求之后才能开始工作，并且告诉客户第二天再来取蛋糕。这在 Web 服务中就意味着异步的处理任务。</p><p>下面是一个典型的工作流：</p><p>一个用户访问了你的网站，并且发出了一个计算密集型的请求，这可能需要花费几分钟的时间才能处理完成。所以你的网站前端应该将任务填充进任务队列，并且在前端立即提示用户：您的请求已经在处理中了，请先看看网站的其他内容。处理程序经常检查工作队列，以发现新推入的工作。如果有新工作，处理程序就会进行这项工作，在几分钟后完成这项工作之后，就会发出信号，表示已经完成了这项工作。前端会经常检查是否接收到了工作完成的信号，一旦发现工作已经完成，就会通知用户。我明白，这是一个非常简单的例子。</p><p>现在如果你想更深入的了解技术细节，我建议你阅读一下 <a href="https://t.umblr.com/redirect?z=http%3A%2F%2Fwww.rabbitmq.com%2F&amp;t=YzFlZGZhMTBjODdmZWZhYzdmZjNmM2VlZDU4YjQ0YmUxZDkzNWM1NixqbHhiaDBWZQ%3D%3D&amp;b=t%3AeE4iDilbUfNhGIklAbjWYQ&amp;p=https%3A%2F%2Fwww.lecloud.net%2Fpost%2F9699762917%2Fscalability-for-dummies-part-4-asynchronism&amp;m=1&amp;ts=1597805914" target="_blank" rel="noopener">RabbitMQ 的前三个教程</a>。RabbitMQ 是帮助实现异步处理的众多系统之一。你也可以使用 ActiveMQ 或者更简单的 Redis list。这里面最核心的思想就是拥有一个可以处理的任务队列。异步化看起来很复杂，但绝对值得你花费时间去学习，并且自己实现。后端几乎可以无限扩展，并且前端也更加现代化，你的用户也会有更加流畅的体验。</p><p>如果你总是做一些耗时的工作，那么请尝试使用异步。</p>]]></content>
      
      
      <categories>
          
          <category> 翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 克隆 </tag>
            
            <tag> 数据库 </tag>
            
            <tag> 缓存 </tag>
            
            <tag> 异步 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树和二叉树的遍历，嗨嗬！</title>
      <link href="/2020/08/17/binaryTree/"/>
      <url>/2020/08/17/binaryTree/</url>
      
        <content type="html"><![CDATA[<h1 id="关于二叉树"><a class="markdownIt-Anchor" href="#关于二叉树"></a> 关于二叉树</h1><p>二叉树是一个老生常谈的数据结构了，这里直接引用 <code>wikipedia</code> 的定义：</p><blockquote><p>In computer science, a binary tree is a tree data structure in which each node has at most two children, which are referred to as the left child and the right child.</p></blockquote><p>当然，二叉树本身还可以再继续细分，比如常用的完全二叉树。不过我们这里先不深究这些内容，而仅仅关注 <code>遍历二叉树</code> 这一主题。</p><p>关于二叉树的表示，有两种方法。<br />一种是使用数组来描述。在这种方法中，二叉树的元素按照其编号存储在数组的对应位置。<br />另一种是使用链表来描述。在这种方法中，每个元素用一个节点来表示，节点有两个指针，分别指向 <code>leftChild</code> 和 <code>rightChild</code>。另外节点还有一个 <code>val</code> 属性，用来存储元素本身的信息。</p><p>关于二叉树的遍历，有 4 种常用的遍历方法：</p><ul><li>前序遍历 中、左、右</li><li>中序遍历 左、中、右</li><li>后序遍历 左、右、中</li><li>层次遍历<br />可以看出，前、中、后序遍历的区别就是父节点与子节点的访问次序。</li></ul><a id="more"></a><h1 id="使用递归进行遍历"><a class="markdownIt-Anchor" href="#使用递归进行遍历"></a> 使用递归进行遍历</h1><p>递归遍历应该是最好理解的一种遍历代码的写法了。<br />在写递归代码时，需要注意两个方面：</p><ul><li>递归停止的条件</li><li>递归本身的代码</li></ul><p>其中递归停止的条件是很重要的，如果处理不好，就很容易爆栈。<br />另外的，递归实质上就是利用了栈，只不过是编程语言帮你维护了这个栈。而在文章 <a href="https://www.bebopser.com/2020/08/11/NGE/">单调栈与 Next Greater Number 问题</a> 我们发现，栈可以理解为 <code>未处理清单</code> 这一概念。换句话说，在二叉树的遍历中，不论是哪种遍历，我们都可能会需要先略过一些节点本身，而去访问其子节点。这个时候我们就需要一种数据结构来帮我们有序的记录好那些未处理的节点了。</p><p>假设我们有一颗二叉树，使用链表来描述。其节点的定义如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>我们的前序遍历代码将会是这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        result = []</span><br><span class="line">        self.visit(root, result)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">visit</span><span class="params">(self, root, result)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            result.append(root.val)</span><br><span class="line">            self.visit(root.left, result)</span><br><span class="line">            self.visit(root.right, result)</span><br></pre></td></tr></table></figure><p>我们的中序遍历代码将会是这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        result = []</span><br><span class="line">        self.visit(root, result)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">visit</span><span class="params">(self, root, result)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            self.visit(root.left, result)</span><br><span class="line">            result.append(root.val)</span><br><span class="line">            self.visit(root.right, result)</span><br></pre></td></tr></table></figure><p>我们的后续遍历代码将会是这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        result = []</span><br><span class="line">        self.visit(root, result)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">visit</span><span class="params">(self, root, result)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            self.visit(root.left, result)</span><br><span class="line">            self.visit(root.right, result)</span><br><span class="line">            result.append(root.val)</span><br></pre></td></tr></table></figure><h1 id="使用迭代进行遍历"><a class="markdownIt-Anchor" href="#使用迭代进行遍历"></a> 使用迭代进行遍历</h1><p>当然了，递归遍历二叉树是非常简单的，也很容易阅读。非递归的遍历方法会有一些复杂，需要借助栈来实现。<br />在实际中，树的深度一般不会太深，但如果一旦很深的情况下，如果使用递归的办法来遍历，就会导致调用栈溢出。<br />虽然名称上似乎都是栈，但递归方法中，计算机在维护调用栈时会保存一大堆环境数据，例如入栈变量、地址等。事实上这些东西对我们的算法来说毫无必要。所以我们其实可以手动维护一个栈来遍历二叉树。</p><p>同样的，对于二叉树节点的定义如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br></pre></td></tr></table></figure><h2 id="二叉树的迭代前序遍历"><a class="markdownIt-Anchor" href="#二叉树的迭代前序遍历"></a> 二叉树的迭代前序遍历</h2><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        stack, result, curr = [], [], root</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (curr != <span class="literal">None</span> <span class="keyword">or</span> stack):</span><br><span class="line">            result.append(curr.val)</span><br><span class="line">            <span class="keyword">if</span> (curr.right):</span><br><span class="line">                stack.append(curr)</span><br><span class="line">            curr = curr.left</span><br><span class="line">            <span class="keyword">if</span> (curr == <span class="literal">None</span> <span class="keyword">and</span> stack):</span><br><span class="line">                curr = stack.pop().right</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>前序遍历，也就是先访问节点本身，然后访问左子树，再访问右子树。<br />可以看出，这种遍历方法，每次当访问到一个节点，就会处理掉一个节点，然后再向左子树方向移动。而这时右子树还没有处理，所以我们将其放入 <code>待办事项</code> 栈中。等左子树都访问光了，再从栈里依次弹出节点来处理。</p><h2 id="二叉树的迭代中序遍历"><a class="markdownIt-Anchor" href="#二叉树的迭代中序遍历"></a> 二叉树的迭代中序遍历</h2><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        stack, result, curr = [], [], root</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (curr != <span class="literal">None</span> <span class="keyword">or</span> stack):</span><br><span class="line">            <span class="keyword">while</span> (curr != <span class="literal">None</span>):</span><br><span class="line">                stack.append(curr)</span><br><span class="line">                curr = curr.left</span><br><span class="line"></span><br><span class="line">            curr = stack.pop()</span><br><span class="line">            result.append(curr.val)</span><br><span class="line">            curr = curr.right</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>中序遍历，也就是先访问左子树，然后访问节点本身，最后访问右子树。<br />对于一个有一定层级的树来说，这种遍历意味着我们应该先一直的访问到左子树。而在循环访问的时候，我们还未访问到节点。所以途径的每一个节点都要压入 <code>待办事项</code> 栈。<br />其次，访问右节点的时机是，访问过当前节点本身之后。</p><h2 id="二叉树的迭代后序遍历"><a class="markdownIt-Anchor" href="#二叉树的迭代后序遍历"></a> 二叉树的迭代后序遍历</h2><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        stack, result = [root, ], []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            curr = stack.pop()</span><br><span class="line">            result.append(curr.val)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (curr.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>):</span><br><span class="line">                stack.append(curr.left)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (curr.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>):</span><br><span class="line">                stack.append(curr.right)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> [::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><p>后序遍历是个很麻烦的事情。我们需要先遍历左子树，然后遍历右子树，最后才能访问节点本身。所以我们可以用逆向思维来理解。<br />为了说明这种逆向思维，可以考虑高中物理中一个非常经典的逆向思维题目：方块正向的匀减速运动可以理解为反向的匀加速运动。这样在某些问题下，方程会非常容易写出。<br />而反向遍历也是，我们只要按照 节点本身-右子树-左子树 的顺序遍历整棵树，然后将遍历结果逆序输出，就能很容易的写出遍历代码。<br />而 节点本身-右子树-左子树 的遍历顺序逻辑上其实和中序遍历是一样的。只不过前者是先访问右子树而后者是先访问左子树罢了。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
            <tag> 遍历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串解码——关于栈的理解</title>
      <link href="/2020/08/17/encodedstring/"/>
      <url>/2020/08/17/encodedstring/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h1><p>这是一道 <code>leetcode</code> 上的原题。题目描述如下：</p><p>给定一个经过编码的字符串，返回它解码后的字符串。<br />编码规则为：<code>k[encoded_string]</code>。k 为正整数，其表示方括号内部的 <code>encoded_string</code> 重复的次数。<br />假定输入总是有效的，且不含有空格或无意义字符。k 总是表示重复次数。</p><h1 id="解释"><a class="markdownIt-Anchor" href="#解释"></a> 解释</h1><p>可以看出，在题目描述中，一个字符串可以由以下结构的元素所组成：</p><p><code>数字</code> + <code>被方括号包裹的字母</code></p><p>当然了，这个结构是不一定的，有时候也仅仅出现单独的字母。但从逻辑上来讲，这种情况是上面公式所描述情况的子集。<br />另外的，还有一种显而易见的状况，就是嵌套。例如：</p><p><code>3[c2[a]]</code></p><p>在这种情况下，内部的计算结果将会作为外部的计算依据。这意味着我们可能需要通过某种方式来缓存计算结果。其次，我们也需要一个具有 <code>待办事项</code> 属性的数据结构来存储一个计算单元，也就是栈。</p><a id="more"></a><h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1><p>本题使用 <code>python3</code> 来实现比较简单。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decodeString</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        result, current_num, stack = <span class="string">""</span>, <span class="string">""</span>, []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> c.isdigit():</span><br><span class="line">                <span class="comment"># 直接连接数字字符串，简化代码</span></span><br><span class="line">                current_num += c</span><br><span class="line">            <span class="keyword">elif</span> c.isalpha():</span><br><span class="line">                <span class="comment"># 1. 计算结果</span></span><br><span class="line">                <span class="comment"># 2. 待计算字符串的缓存</span></span><br><span class="line">                result += c</span><br><span class="line">            <span class="keyword">elif</span> c == <span class="string">'['</span>:</span><br><span class="line">                <span class="comment"># 入栈</span></span><br><span class="line">                stack.append([current_num, result])</span><br><span class="line">                current_num, result = <span class="string">""</span>, <span class="string">""</span></span><br><span class="line">            <span class="keyword">elif</span> c == <span class="string">']'</span>:</span><br><span class="line">                <span class="comment"># 出栈</span></span><br><span class="line">                mul, last_result = stack.pop()</span><br><span class="line">                <span class="comment"># int(mul) 计算的时候再转换</span></span><br><span class="line">                result = last_result + int(mul) * result</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h1 id="代码解析"><a class="markdownIt-Anchor" href="#代码解析"></a> 代码解析</h1><ol><li>使用栈保存计算单元。而栈本身先进后出的特性同时保存了嵌套的计算顺序。</li><li>注意入栈的单元是 <code>[current_num, result]</code>。这个数组的第一个元素是方括号中字母的重复次数，而第二个元素是 <strong>已经计算出来的字符，而不是待计算的字母</strong>。这样做的原因是，我们需要继续往下遍历才能知道需要重复的字母是什么样的。所以这里实际上是使用 <code>result</code> 做了两个角色：结果与待计算字符串的缓存。</li><li>使用字符串形式保存数字可以让我们不必在意数字位数，直接使用 <code>+</code> 连接。这个只是起到了简化代码的作用，核心算法并不受其影响。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单调栈与 Next Greater Number 问题</title>
      <link href="/2020/08/11/NGE/"/>
      <url>/2020/08/11/NGE/</url>
      
        <content type="html"><![CDATA[<h1 id="栈与单调栈"><a class="markdownIt-Anchor" href="#栈与单调栈"></a> 栈与单调栈</h1><p>栈是一种非常常见的线性数据结构，其中的元素遵循 <code>First In Last Out</code> 的原则，并且仅能在一端，即栈顶操作数据。<br />以 <code>C++</code> 为例，栈一般提供以下几种操作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s</span><br><span class="line"></span><br><span class="line">s.empty()       <span class="comment">// 栈是否为空</span></span><br><span class="line">s.<span class="built_in">size</span>()        <span class="comment">// 栈中元素个数</span></span><br><span class="line">s.push(<span class="number">1</span>)       <span class="comment">// 向栈中压入元素</span></span><br><span class="line">s.top()         <span class="comment">// 返回栈顶元素</span></span><br><span class="line">s.pop()         <span class="comment">// 弹出栈顶元素</span></span><br></pre></td></tr></table></figure><p>不同语言，同一操作的细节可能不同，但大体思路都是一致的。</p><p>单调栈是一种特殊的栈，通过一些逻辑处理，使得入栈后的元素都保持单调。这种数据结构算是处理 <code>Next Greater Number</code> 问题的银弹。</p><a id="more"></a><h1 id="关于-ngn-问题"><a class="markdownIt-Anchor" href="#关于-ngn-问题"></a> 关于 <code>NGN</code> 问题</h1><p>原始问题：给定一个数组 A，要求返回等长数组 B。B 中元素是 A 中比对应位置元素大的下一个元素的位置。<br />举例：<br />给定数组 [73, 74, 75, 71, 69, 72, 76, 73]<br />输出 [1, 1, 4, 2, 1, 1, 0, 0]</p><p>从问题的结构上来看，很像是数学中求函数极值点的问题。也就是说，我们并不需要挑出这一组数字的最大值，也不需要对这组数字进行单调排序。我们只需要在遍历数组的时候，依次对数字进行局部的单调排序。而实现这件事的就必须依赖 <code>单调栈</code></p><h1 id="leetcode-原题及解"><a class="markdownIt-Anchor" href="#leetcode-原题及解"></a> LeetCode 原题及解</h1><p><a href="https://leetcode-cn.com/problems/daily-temperatures" target="_blank" rel="noopener">问题</a>：<br />请根据每日 气温 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用  0 来代替。<br />例如，给定一个列表  temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是  [1, 1, 4, 2, 1, 1, 0, 0]。<br />提示：气温 列表长度的范围是  [1, 30000]。每个气温的值的均为华氏度，都是在  [30, 100]  范围内的整数。</p><p>Python 解</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dailyTemperatures</span><span class="params">(self, T: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">        result = [<span class="number">0</span>] * len(T)</span><br><span class="line">        stack = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> index, temp <span class="keyword">in</span> enumerate(T):</span><br><span class="line">            <span class="keyword">while</span> len(stack) &gt; <span class="number">0</span> <span class="keyword">and</span> temp &gt; T[stack[<span class="number">-1</span>]]:</span><br><span class="line">                min_temp_index = stack.pop()</span><br><span class="line">                result[min_temp_index] = index - min_temp_index</span><br><span class="line"></span><br><span class="line">            stack.append(index)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>解析：<br />我们维护了一个单调栈 <code>stack</code> 。这个单调栈的运行机制是这样的。当我们遍历给定数组 <code>T</code> 时，会参考 <code>stack</code> 栈顶的元素值。如果当前元素比栈顶元素大，那么当前元素就是栈顶元素需要找的那个 <code>Greater Element</code> 更大的值。如果较小，那么就将当前元素压入 <code>stack</code> 栈。<br />这个单调栈的作用实际上并不是在排序，而是在存储“还未处理的元素”。比如题目中的 71，它的下一个元素是 69，并不是我想要的更大的值，所以 69 也将会被压入栈内。但是当我遍历到 72 这个值的时候，我们会发现这个值同时比 71 和 69 还要大，所以这两个值将会被处理，而处理完成之后，将会被从栈内弹出。而 72 这个元素，也就是当前值作为一个还未处理的元素，将会被压入栈内。<br />这个解法需要遍历一遍给定数组，故时间复杂度为 <code>O(n)</code>。其次我们还需要维护一个存储给定温度列表数组下标的栈，所以其空间复杂度为 <code>O(n)</code>。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
            <tag> 单调栈 </tag>
            
            <tag> nge </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS 的一种命名规范——BEM</title>
      <link href="/2020/08/05/bem/"/>
      <url>/2020/08/05/bem/</url>
      
        <content type="html"><![CDATA[<h1 id="关于-css-架构"><a class="markdownIt-Anchor" href="#关于-css-架构"></a> 关于 CSS 架构</h1><p>事实上，编写可维护的 <code>CSS</code> 一直是一个看似简单，但实际执行起来，特别是在大型网站中执行时，经常会遇到问题。很多时候这并不是技术问题，而是工程问题。当一个网站拥有众多的元素、组件、页面时，如何保证 <code>class</code> 的准确性，以及 <code>CSS</code> 的可维护性，一直是一个需要投入大量时间去达到的事情。<br />不过，幸运的是，社区里已经出现了一些解决方案。在这里我们仅介绍 <code>BEM</code> 这一种。这也许不是最好的一种，但至少可以帮你解决某些具体应用情景下的问题，聊胜于无。</p><a id="more"></a><h1 id="关于-bem"><a class="markdownIt-Anchor" href="#关于-bem"></a> 关于 BEM</h1><p>BEM，也就是：<code>Block Element Modifier</code>。这个架构的命名规范是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 模块名 + 元素名 + 修饰器名</span><br><span class="line">block-name__element-name--modifier-name</span><br></pre></td></tr></table></figure><p>在这里，模块的意义并不同于特定前端框架所定义的模块。这种划分是作者基于代码的功能人为划分的。例如对于一个包含列表和操作按钮的卡片，一个可选的命名思路是这样的：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.books-card</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.books-card__list</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.books-card__func-btn</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事实上，你并不要严格的遵循 <code>HTML</code> 的层级关系来命名。比如下面这段 <code>HTML</code>:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">"article"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">header</span> <span class="attr">class</span>=<span class="string">"article__header"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">"article__title"</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以看到，<code>h1</code> 实际上是 <code>article</code> 的孙元素。但在命名时，我们依然将其搞成了 <code>article</code> 模块的直接元素。</p><p>另外的，还有一种更常见的情况。在嵌套过深的 <code>HTML</code> 中，我们可能会不得不将一些元素无意义的连接到父模块。但也没有必要为了命名的整洁而创建一个新的模块。<br />在这种情况下，我们可以创建一个伪块：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"block"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h3</span> <span class="attr">class</span>=<span class="string">"block__title"</span>&gt;</span><span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">u1</span> <span class="attr">class</span>=<span class="string">"block__list"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"block__item"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h3</span> <span class="attr">class</span>=<span class="string">"item__title"</span>&gt;</span><span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">u1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以看到，在这里我们创建了一个名为 <code>.main</code> 的伪块。它并不实际的存在于 <code>HTML</code> 中。而只是单纯的提供了一个上下文。</p><h1 id="关于-bem-修饰器"><a class="markdownIt-Anchor" href="#关于-bem-修饰器"></a> 关于 BEM 修饰器</h1><p>在很多情况下，我们需要在不同的场景中使用同一种类的、不同样式的组件。比如一个按钮，主要功能按钮和危险操作按钮肯定不能是同一个样式的。在这种情况下，我们就可以使用这样的命名：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"button"</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span> <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"button button--danger"</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样我们可以一眼就看出来按钮的区别了，同时海能保证 <code>CSS</code> 代码的简洁。<br />不过这样做的坏处是，<code>class</code> 命名将会很繁琐，但如果我们删除第二个 <code>button</code> 中的 <code>.button</code>，又会使 <code>CSS</code> 代码中充满了许多相同代码。<br />一个解决办法是，使用 <code>mixin</code>。例如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@mixin</span> button &#123;</span><br><span class="line">  <span class="selector-tag">padding</span>: 0<span class="selector-class">.5em</span> 0<span class="selector-class">.75em</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.button</span> &#123;</span><br><span class="line">  @include button;</span><br><span class="line">  <span class="selector-tag">background-color</span>: <span class="selector-tag">red</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.button--secondary</span> &#123;</span><br><span class="line">  @include button;</span><br><span class="line">  <span class="selector-tag">background-color</span>: <span class="selector-tag">green</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们使用 <code>mixin</code> 封装了可重用的所有代码，只需要在需要使用的地方调用即可。</p><h1 id="关于使用子选择器"><a class="markdownIt-Anchor" href="#关于使用子选择器"></a> 关于使用子选择器</h1><p>子选择器是一种常用的 <code>CSS</code> 选择器，它是通过根节点的名称来选取子元素。基于这种用法，你可能会写出这样的 <code>CSS</code> 代码：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.page</span> <span class="selector-class">.list</span> &#123;</span><br><span class="line">  <span class="comment">/*  */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这当然会保证 <code>HTML</code> 非常整洁，没有额外的东西。但这种做法仅仅是利用了耦合来解决命名空间的问题。这并不能让你在开发一个新组件时无所顾忌的起名，特别是在开发另一个 <code>list</code> 组件时。<br />另一个问题是，很多时候我们都会写出一些嵌套层级很深的 <code>HTML</code> 代码。如果我们在这种情况下使用子选择器甚至诸如 <code>:first-child</code> <code>&gt;</code> 等选择器时，对于一个新接手代码的人来说，他仅仅看 <code>CSS</code> 代码时，完全不知道其中的某一部分是在干什么。如果他决定新增加一个组件，那么他将不得不使用一些奇怪的命名，或是使用 <code>覆盖</code> 的特性来实现样式。这是非常严重的问题，这会导致样式代码随着时间推移，非常快速的膨胀起来，这对于后期的维护和重构来说是不可想象的工作量。</p>]]></content>
      
      
      <categories>
          
          <category> 编程范式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工程化 </tag>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue 核心（一）—— Vue 中的数据</title>
      <link href="/2020/07/24/vueData/"/>
      <url>/2020/07/24/vueData/</url>
      
        <content type="html"><![CDATA[<h1 id="总述关于数据"><a class="markdownIt-Anchor" href="#总述关于数据"></a> 总述——关于数据</h1><p><code>Vue</code> 作为一个构建用户界面的前端框架，学会如何使用它在各种情况下流畅的处理数据，是写出漂亮健壮的代码的前提。<br />在一个对网站对基本的认识中，比如我们将网站仅仅理解为 <code>HTML</code> + <code>JavaScript</code> + <code>CSS</code> 的话，我们会发现在处理数据方面并没有什么太大的问题。因为我们所要做的仅仅是通过 <code>API</code> 向后端请求数据，使用 <code>JavaScript</code> 代码进行一些简单的处理之后，将其填入到 <code>HTML</code> 中就好。尽管这个模型漏洞百出，但它还是描述了在大局上数据的走向。它要经过三个阶段才能从服务器抵达用户的屏幕上。<br />在这里，我们讨论的数据以及数据的流向，并不是如前所述的整体上的流向，而是局部的。换句话说，我们重点讨论的是如何在 <code>Vue</code> 中使用 <code>JavaScript</code> 代码处理他们。<br />这个问题的来源是，<code>Vue</code> 为了方便构建大型应用，引入了 <code>组件</code> 这一概念。事实上你可以将其理解为 <code>类</code>。在一般情况下，一个组件是具有一定功能的一段代码。每个组件都是高内聚、低耦合的，他们有序的组织起来，共同构成一个由特定范围功能的应用。<br /><img src="https://bebopfzj.oss-cn-hangzhou.aliyuncs.com/uPic/2020-07-24-pgAiWG.png" alt="组件" /><br />那么这个时候就会有一个核心问题—— <strong>我该如何处理在组件间流动的数据？</strong></p><a id="more"></a><h1 id="父子组件间的单向数据流prop"><a class="markdownIt-Anchor" href="#父子组件间的单向数据流prop"></a> 父子组件间的单向数据流：<code>prop</code></h1><p>在 <code>Vue</code> 中，通过使用 <code>prop</code> ，数据流被设计为单向的。根据官方的解释，这是为了避免双向数据流所带来的的复杂的状态变动。也就是说，你不应该在子组件中修改通过 <code>prop</code> 传过来的数据。尽管你可以通过 <code>计算属性</code> 等方法来达到这个目的，但这一部分留到后期再说。<br />下面是一段使用 <code>prop</code> 的示例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Home.vue  父组件 *&#x2F;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;PropTestComponent :receiveDataFromParent&#x3D;&quot;parentComponentMessage&quot; &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import PropTestComponent from &quot;@&#x2F;components&#x2F;PropTestComponent.vue&quot;;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">    name: &quot;Home&quot;;</span><br><span class="line">    components: &#123;</span><br><span class="line">        PropTestComponent,</span><br><span class="line">    &#125;,</span><br><span class="line">    data() &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            parentComponentMessage: &quot;Hello World&quot;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* PropTestComponent.vue  子组件 *&#x2F;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;&#123;&#123;childComponentMessage&#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    name: &quot;PropTestComponent&quot;,</span><br><span class="line">    props: &#123;</span><br><span class="line">        &quot;receiveDataFromParent&quot;: &#123;</span><br><span class="line">            type: String,</span><br><span class="line">            default: &quot;default string&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    data() &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            childComponentMessage: this.receiveDataFromParent</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>可以看到，页面上已经正确的渲染出字符串了：<br /><img src="https://bebopfzj.oss-cn-hangzhou.aliyuncs.com/uPic/2020-07-24-PZ1c0K.png" alt="prop test" /></p><h1 id="通过子组件触发父组件的事件emit"><a class="markdownIt-Anchor" href="#通过子组件触发父组件的事件emit"></a> 通过子组件触发父组件的事件：<code>$emit</code></h1><p>正是因为 <code>prop</code> 单向数据流的设计，我们只能操作一个方向的数据。但在很多时候，我们也需要由子组件发起一个请求，来触发父组件的事件。<br />比如我们在写一个 Button 组件，我们期望的设计是，用户可以直接引入 <code>button</code> 并在上面自定义 <code>click</code> 事件。但如果我们不在 <code>button</code> 中做任何处理的话，组件是无法响应用户设置的 <code>click</code> 事件处理函数的。那么这个时候，我们就会需要使用 <code>$emit</code> 来在适当的时候触发父组件的逻辑处理事件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Home.vue 父组件 *&#x2F;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;emitTestComponent @click&#x3D;&quot;sayHi&quot; &#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import emitTestComponent from &quot;@&#x2F;components&#x2F;emitTestComponent.vue&quot;;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;Home&quot;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    emitTestComponent,</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    sayHi() &#123;</span><br><span class="line">      console.log(&quot;Hi&quot;);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div @click&#x3D;&quot;handleClick&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;emitTestComponent&quot;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    handleClick() &#123;</span><br><span class="line">      this.$emit(&quot;click&quot;);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>下面是控制台的输出：<br /><img src="https://bebopfzj.oss-cn-hangzhou.aliyuncs.com/uPic/2020-07-24-F7o2ds.png" alt="console" /></p><p>当然了，<code>$emit</code> 也可以同时传入参数，或者是调用非原生事件，你可以通过 <a href="https://cn.vuejs.org/v2/api/#vm-emit" target="_blank" rel="noopener">官方文档</a> 了解更多。</p><h1 id="跨级组件的数据流-attrs-listeners"><a class="markdownIt-Anchor" href="#跨级组件的数据流-attrs-listeners"></a> 跨级组件的数据流 —— <code>$attrs</code>、<code>$listeners</code></h1><p>首先简单说说这两个 api 的意义：<br /><code>$attrs</code>: 如果在父作用域中绑定了属性，但在子作用域中没有使用 <code>props</code> 接收，那么剩下的那些数据就会被包含在这个属性中。并且你可以使用 <code>v-bind=&quot;$attrs&quot;</code> 来将其传入到内部组件中去。<br /><code>$listeners</code>: 父作用域中那些没有使用 <code>.native</code> 修饰的 <code>v-on</code> 监听的事件监听器将会被放在这里。同样的，你也可以使用 <code>v-on=&quot;$listeners&quot;</code> 来传入到内部组件中去。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* home.vue 父组件 *&#x2F;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;B :parentMessage&#x3D;&quot;parentComponentMessage&quot; @sayHi&#x3D;&quot;sayHi&quot; &#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import B from &quot;@&#x2F;components&#x2F;B.vue&quot;;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;Home&quot;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    B,</span><br><span class="line">  &#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      parentComponentMessage: &quot;Hello World&quot;,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    sayHi(message) &#123;</span><br><span class="line">      console.log(&quot;Hello &quot; + message);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* B.vue 第一层子组件 *&#x2F;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;C v-bind&#x3D;&quot;$attrs&quot; v-on&#x3D;&quot;$listeners&quot; &#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import C from &quot;.&#x2F;C.vue&quot;;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;B&quot;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    C,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* C.vue 第二层子组件 *&#x2F;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;&#123;&#123; $attrs.parentMessage &#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;C&quot;,</span><br><span class="line">  created() &#123;</span><br><span class="line">    this.emit(&quot;sayHi&quot;, &quot;World&quot;);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>简单来说，组件 B 充当了中间人的作用，它将属性和事件监听器传递到了 C 处。这在嵌套层数过多的情况下也是适用的。尽管在 3 层以上的嵌套中，<code>vuex</code> 显然是更好的解决方案。</p><h1 id="高阶组件的父子组件通信-provide-inject"><a class="markdownIt-Anchor" href="#高阶组件的父子组件通信-provide-inject"></a> 高阶组件的父子组件通信 —— <code>provide</code> <code>inject</code></h1><p>在一些嵌套层级过深的父子组件中，单纯的使用 <code>$attrs</code> 来传递数据似乎有点太麻烦了。<code>Vue</code> 提供了一个新的办法来传递。不过官方建议仅在开发组件库或者是高阶插件时才使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;A &#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import A from &quot;..&#x2F;components&#x2F;A&quot;;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;Home&quot;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    A,</span><br><span class="line">  &#125;,</span><br><span class="line">  provide: &#123;</span><br><span class="line">    dataFromHome: &quot;Hello World&quot;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;&#123;&#123; dataFromHome &#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;A&quot;,</span><br><span class="line">  inject: [&quot;dataFromHome&quot;],</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>在父组件中使用 <code>provide</code> 来暴露一些属性，然后可以在孙子组件中使用 <code>inject</code> 来注入这些属性。这些属性都是挂载到 <code>Vue</code> 实例上的，在组件内部可以通过 <code>this</code> 来访问。</p><h1 id="没有层级的组件通信-eventbus"><a class="markdownIt-Anchor" href="#没有层级的组件通信-eventbus"></a> 没有层级的组件通信 —— EventBus</h1><p>简单来说，事件总线并不是一个新的概念，它仅仅是创建了一个新的 <code>Vue</code> 实例来承载各种事件。使用者可以通过 <code>$on</code> 来绑定事件，也可以通过 <code>$emit</code> 来调用事件。</p><p>在操作前，你必须在当前的 <code>vue</code> 实例上绑定好事件总线。当然你也可以不绑定在实例上，不过那样子会比较麻烦。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype.$EventBus = <span class="keyword">new</span> Vue();</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Home.vue 父组件 *&#x2F;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;A &#x2F;&gt;</span><br><span class="line">    &lt;B &#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import A from &quot;..&#x2F;components&#x2F;A&quot;;</span><br><span class="line">import B from &quot;..&#x2F;components&#x2F;B&quot;;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;Home&quot;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    A,</span><br><span class="line">    B,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* A.vue 独立的子组件 *&#x2F;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;container&quot; @click&#x3D;&quot;sayHi&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;A&quot;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    sayHi() &#123;</span><br><span class="line">      this.$EventBus.$emit(&quot;globalSayHi&quot;, &quot; World&quot;);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* B.vue 独立的子组件 *&#x2F;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;container&quot;&gt;&#123;&#123; message &#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;B&quot;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      message: &quot;&quot;,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    this.$EventBus.$on(&quot;globalSayHi&quot;, (mes) &#x3D;&gt; &#123;</span><br><span class="line">      this.message &#x3D; &quot;Hello&quot; + mes;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>这个时候，单击 <code>A</code> 组件，就可以看到在 <code>B</code> 组件上显示出 “Hello World” 了。</p>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 框架 </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树的常规操作——从树的基本概念说起</title>
      <link href="/2020/06/22/treeHandle/"/>
      <url>/2020/06/22/treeHandle/</url>
      
        <content type="html"><![CDATA[<h1 id="关于树"><a class="markdownIt-Anchor" href="#关于树"></a> 关于树</h1><p>树是一种用来表示层次结构数据的数据类型。<br /><strong>定义</strong>：一棵树 t 是一个非空的有限元素的集合，其中一个元素为根 root ，其他的元素（如果有的话）组成 t 的子树 subtree 。</p><p>一棵树的 <strong>高度</strong> 或 <strong>深度</strong> 是树中级的个数。<br />一个元素的 <strong>度</strong> 是指其孩子的个数。</p><h2 id="二叉树"><a class="markdownIt-Anchor" href="#二叉树"></a> 二叉树</h2><p><strong>定义</strong>：一颗 <strong>二叉树</strong> t 是有限个元素的集合（可以为空）。当二叉树非空时，其中有一个元素称为 <strong>根</strong>，余下的元素（如果有的话）被划分为两棵二叉树，分别称为 t 的左子树和右子树。<br /><strong>特性 1</strong>：一颗二叉树有 n 个元素（n&gt;0），它有 n-1 条边。<br /><strong>特性 2</strong>：一颗二叉树高度为 h（h&gt;=0），则其最少有 h 个元素，最多有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>h</mi></msubsup><msup><mn>2</mn><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>=</mo><msup><mn>2</mn><mi>h</mi></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\sum_{i=1}^{h} 2^{i-1} = 2^h - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2887179999999998em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9890079999999999em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">h</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.932438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">h</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 个元素<br /><strong>特性 3</strong>：一颗二叉树有 n 个元素（n&gt;0），它的最大高度为 n，最小高度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mo fence="true">∣</mo><mi>log</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo fence="true">∣</mo></mrow><mspace linebreak="newline"></mspace></mrow><annotation encoding="application/x-tex">\left|\log(n+1)\right|\\</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">∣</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mclose delimcenter" style="top:0em;">∣</span></span></span><span class="mspace newline"></span></span></span> （向上取整）</p><a id="more"></a><h2 id="完全二叉树"><a class="markdownIt-Anchor" href="#完全二叉树"></a> 完全二叉树</h2><p><strong>定义</strong>：从根往下数，除了最下层外都是全满（都有两个子节点），而最下层所有叶结点都向左边靠拢填满。</p><p>在完全二叉树中，一个元素与其孩子的编号有很好的对应关系：<br /><strong>特性 1</strong>：若 i=1，则该元素为完全二叉树的根。若 i&gt;1，则其父节点的编号为 i/2 向下取整<br /><strong>特性 2</strong>：若 2i&gt;n ，则该元素无左孩子。否则，其左孩子编号为 2i<br /><strong>特性 3</strong>：若 2i+1&gt;n， 则该元素无右孩子。否则，其右孩子编号为 2i+1</p><h1 id="二叉树的遍历"><a class="markdownIt-Anchor" href="#二叉树的遍历"></a> 二叉树的遍历</h1><h2 id="深度优先遍历"><a class="markdownIt-Anchor" href="#深度优先遍历"></a> 深度优先遍历</h2><p>在深度优先遍历中，我们从根节点开始，一直访问至最深的节点。与图不同，树中不存在环形结构，所以我们不必记录已经访问过的元素。<br />前、中、后序遍历实际上利用了迭代。</p><h3 id="准备工作"><a class="markdownIt-Anchor" href="#准备工作"></a> 准备工作</h3><p>在这里，我们将 <code>visit</code> 函数定义为一个函数指针，以便于执行不同的访问函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">void</span> <span class="params">(*visit)</span> <span class="params">(binaryTreeNode&lt;T&gt; *)</span></span></span><br></pre></td></tr></table></figure><p>也就是说，我们可以将 <code>visit</code> 定义为访问、删除、输出等各种功能。这样就将遍历与实际对元素的操作拆分开了。</p><p>在这里， <code>binaryTreeNode&lt;T&gt;</code> 是一个自定义的元素结构，其数据结构如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">binaryTreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    T element;</span><br><span class="line">    binaryTreeNode&lt;T&gt; *leftChild, *rightChild;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略构造方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="前序遍历"><a class="markdownIt-Anchor" href="#前序遍历"></a> 前序遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">linkedBinaryTree</span>&lt;T&gt;:</span>:preOrder(binaryTreeNode&lt;T&gt;* t)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (t != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        linkedBinaryTree&lt;T&gt;::visit(t);</span><br><span class="line">        preOrder(t-&gt;leftChild);</span><br><span class="line">        preOrder(t-&gt;rightChild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="中序遍历"><a class="markdownIt-Anchor" href="#中序遍历"></a> 中序遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">linkedBinaryTree</span>&lt;T&gt;:</span>:inOrder(binaryTreeNode&lt;T&gt;* t)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (t != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        inOrder(t-&gt;leftChild);</span><br><span class="line">        linkedBinaryTree&lt;T&gt;::visit(t);</span><br><span class="line">        inOrder(T-&gt;rightChild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="后序遍历"><a class="markdownIt-Anchor" href="#后序遍历"></a> 后序遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">linkedBinaryTree</span>&lt;T&gt;:</span>:postOrder(binaryTreeNode&lt;T&gt;* t)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (t != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        postOrder(t-&gt;leftChild);</span><br><span class="line">        postOrder(t-&gt;rightChild);</span><br><span class="line">        linkedBinaryTree&lt;T&gt;::visit(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="广度优先遍历"><a class="markdownIt-Anchor" href="#广度优先遍历"></a> 广度优先遍历</h2><p>这种遍历是按照层次来遍历整棵树，需要借助队列来实现。<br />沿着每一层，按从左到右的顺序，将元素塞入队列。而队列是先进先出的，所以遍历的时候也将会从该层最左边的元素开始遍历。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">linkedBinaryTree</span>&lt;T&gt;:</span>:levelOrder(binaryTreeNode&lt;T&gt;* t)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;binaryTreeNode&lt;T&gt; *&gt; q;</span><br><span class="line">    binaryTreeNode&lt;T&gt; *t = root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (t != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        theVisit(t);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (t-&gt;leftChild != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            q.push(t-&gt;leftChild);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (t-&gt;rightChild != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            q.push(t-&gt;rightChild);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        t = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 重载 </tag>
            
            <tag> 遍历 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SICP笔记——构造过程抽象</title>
      <link href="/2020/06/05/processAbstraction/"/>
      <url>/2020/06/05/processAbstraction/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文是 《计算机程序的构造与解释》 这本书的笔记</p></blockquote><h1 id="总述"><a class="markdownIt-Anchor" href="#总述"></a> 总述</h1><p>理解复杂事物的关键是：避免不必要的观察、计算和思考。而这也正是构造复杂软件所必须的。通过一些软件设计技术，我们可以很好的将整体拆分为细小的、具有独立功能的、可描述的模块。而在这一行为中，<strong>抽象</strong> 就是必不可少的魔法。为了理解这一行为，我们在这里引用原书：</p><blockquote><p>心智的活动，除了尽力产生各种简单的认识之外，主要表现在如下三个方面：</p><ol><li>将若干简单认识 <strong>组合</strong> 为一个复合认识，由此产出各种复杂的认识</li><li>将两个认识放在一起对照，不管它们如何简单或者复杂，在这样做时并不将它们合二为一。由此得到有关他们的 <strong>相互关系</strong> 的认识。</li><li>将有关认识与那些在实际中和它们同在的所有其他认识 <strong>隔离开</strong>，这就是抽象。<br />所有具有普遍性的认识都是这样得到的。</li></ol></blockquote><a id="more"></a><h1 id="一些程序设计的基本元素"><a class="markdownIt-Anchor" href="#一些程序设计的基本元素"></a> 一些程序设计的基本元素</h1><p>每一种程序设计语言，都会提供一整套的框架，以便于我们能够凭借其组织起自己有关于计算过程的思想。而这个框架将会包含以下三种核心魔法：</p><ol><li>基本表达形式</li><li>组合的方法</li><li>抽象的方法</li></ol><p>比如以下这段程序：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">square</span> x)</span><br><span class="line">    (<span class="name"><span class="builtin-name">*</span></span> x x))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">sum-of-square</span> x y)</span><br><span class="line">    (<span class="name"><span class="builtin-name">+</span></span> (<span class="name">square</span> x) (<span class="name">square</span> y)))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">f</span> a)</span><br><span class="line">    (<span class="name">sum-of-square</span> (<span class="name"><span class="builtin-name">+</span></span> a <span class="number">1</span>) (<span class="name"><span class="builtin-name">*</span></span> a <span class="number">2</span>)))</span><br><span class="line"></span><br><span class="line">(<span class="name">f</span> <span class="number">5</span>)    <span class="comment">; 136</span></span><br></pre></td></tr></table></figure><p>我们通过层层抽象，可以将一个父级问题分解为子问题，而子问题又可以继续向下分解。每一个子问题只对自己的父级问题负责。<br />这样做的好处就是，我们只需要独立地评判每一个过程的正确性就行，而不用每次都全盘的考虑过程的所有细节。<br />不过上面这段程序并不符合我们设计程序的通常思路，事实上，通常的思路是从整体向局部细化。</p><p>比如，我们得到一个计算任务，需要对一个数字做两种处理后，求它们的平方和。在这里，如何处理数字是已经确定了的。</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">f</span> a)</span><br><span class="line">    (<span class="name">sum-of-square</span> (<span class="name"><span class="builtin-name">+</span></span> a <span class="number">1</span>) (<span class="name"><span class="builtin-name">*</span></span> a <span class="number">2</span>)))</span><br></pre></td></tr></table></figure><p>事实上，我现在还不知道怎样对两个数字求平方和。但我知道，我需要对输入值先加 1，作为求平方和程序的一个值。同时将输入值翻倍，作为求平方和程序的另一个值。<br />这里面蕴含着一个思想：<strong>按愿望思维</strong> <s>（作者这么起的名……）</s>。也就是说，我们先假设子问题已经被解决，我们在一开只需要关注父级问题的逻辑层面，然后再向下推进。<br />接着，我就能继续设计求平方和的过程了。</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">sum-of-square</span> x y)</span><br><span class="line">    (<span class="name"><span class="builtin-name">+</span></span> (<span class="name">square</span> x) (<span class="name">square</span> y)))</span><br></pre></td></tr></table></figure><p>在这里，我将求平方的任务委托给了 <code>square</code> 过程，在这一层面，我只需要关注如何将两个值求和就行了。<br />按照同样的思路，我们也可以继续写出 <code>square</code> 过程的实现。</p><p>而这里的核心就是：<strong>分解中的每一个过程完成了一件可以清楚标明的工作，这使它们可以被用作定义其他过程的模块</strong></p><h2 id="代换模型"><a class="markdownIt-Anchor" href="#代换模型"></a> 代换模型</h2><p>为了理解这种抽象是如何工作的，首先介绍一下如何求值一个组合式。为了求值一个组合式，我们需要做如下工作：</p><ol><li>求值该组合式的各个子表达式</li><li>将作为最左子表达式（运算符）的值的那个过程应用于相应的实际参数，所谓实际参数也就是其他子表达式（运算对象）的值</li></ol><p>而当我们面对一个复合过程的时候，也就是上面的形式时，为了理解这个过程，我们可以将复合过程应用于实际参数。也就是说，在将过程体中的每个形参用相应的实参取代之后，对这一过程体求值。</p><p>例如这个求平方和的过程：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">square</span> x)</span><br><span class="line">    (<span class="name"><span class="builtin-name">*</span></span> x x))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">sum-of-square</span> x y)</span><br><span class="line">    (<span class="name"><span class="builtin-name">+</span></span> (<span class="name">square</span> x) (<span class="name">square</span> y)))</span><br></pre></td></tr></table></figure><p>在计算的时候，我们会将 <code>(square x)</code> 委托给 <code>square</code> 过程。我们也可以将其代换入原始代码：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">sum-of-square</span> x y)</span><br><span class="line">    (<span class="name"><span class="builtin-name">+</span></span> (<span class="name"><span class="builtin-name">*</span></span> x x) (<span class="name"><span class="builtin-name">*</span></span> y y)))</span><br></pre></td></tr></table></figure><p>不过你需要注意这只能帮助理解，但它并不代表解释器实际工作的形式。</p><h2 id="关于代码风格"><a class="markdownIt-Anchor" href="#关于代码风格"></a> 关于代码风格</h2><p>事实上，这种计算机程序的抽象，也可以立即的令人想到我们关于良好代码中函数的定义：短小，且只做一件事。<br />在《代码整洁之道》这本书的函数一章，作者提出了一个写好函数的准则：<br /><strong>函数应该只做一件事。做好这件事。只做这一件事。</strong></p><p>更进一步的，究竟做哪件事？各个函数之间究竟该有怎样的关系？<br />相信这个问题，SICP 已经给出了解释：做逻辑的层面抽象。<br />每一个函数都应当在自己的一个逻辑层面工作。比如下面这段爬虫代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">spider</span><span class="params">(url)</span>:</span></span><br><span class="line">    html = fetchHTML(url)</span><br><span class="line">    result = handleHTML(html)</span><br><span class="line">    writeResultIntoDatabase(result)</span><br></pre></td></tr></table></figure><p>我们可以清楚的看到，整个爬虫代码由三个层面组成。我们首先获取网站的 <code>html</code> 文档，接着，我们对获得的文档进行分析并得到我们想要的结果。最后，我们将结果写入数据库。<br />这样做的好处是，一旦其中的一个模块出了问题，我们只需要单独修复那个模块就可以了。我们可以在错误栈上清楚地看到到底是哪一步出了错。<br />如果你只用一个函数完成整个功能，那你可能会得到一个几英里长的<s>随机数生成器</s>。<br />更为麻烦的是，这三个步骤并不是一蹴而就的。比如 <code>fetchHTML()</code> 函数。我们并不是仅仅只需要发送 <code>request</code> 请求就可以立即得到需要处理的文档了。我们可能需要应付登录，我们可能需要伪造 <code>User-Agent</code>，我们可能需要维护一个代理来防止被 ban，我们可能需要一个调度程序来按照文档处理的速度产出新的爬取内容等等。这一些功能都是各自独立的，如果我们没有在一开始就将其拆分好，后期的维护难度是巨大的。你肯定不希望在纠结多线程的时候，还要关注 <code>User-Agent</code> 是不是正确设置了吧。</p><h1 id="过程与产生的计算"><a class="markdownIt-Anchor" href="#过程与产生的计算"></a> 过程与产生的计算</h1><p>就像是学象棋一样，我们在知道各种棋子如何走之后，还需要知道典型的开局和套路。这些套路就像是摄影参数一样，一个优秀的摄影师应当知道自己的设置会大致产生什么样的结果。程序也是一样的。<br />这里，我们给出三种计算过程。</p><h2 id="线性递归"><a class="markdownIt-Anchor" href="#线性递归"></a> 线性递归</h2><p>考虑如下程序：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; time = O(n)</span></span><br><span class="line"><span class="comment">; space = O(n)</span></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">factorial</span> n)</span><br><span class="line">    (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">=</span></span> n <span class="number">1</span>)</span><br><span class="line">        <span class="number">1</span></span><br><span class="line">        (<span class="name"><span class="builtin-name">*</span></span> n (<span class="name">factorial</span> (<span class="name"><span class="builtin-name">-</span></span> n <span class="number">1</span>)))))</span><br><span class="line"></span><br><span class="line">(<span class="name">factorial</span> <span class="number">6</span>)</span><br></pre></td></tr></table></figure><p>这是一个计算 <code>n!</code> 的程序。我们使用代换模型，可以得到如下的计算过程：</p><p><img src="https://bebopfzj.oss-cn-hangzhou.aliyuncs.com/uPic/2020-06-05-zIJ2BH.png" alt="线性递归" /></p><p>可以看到，整个计算方式是呈现了一个先扩展，后收缩的形式。<br />这种形式的核心在于，解释器将会维护这些中间值，一旦我们计算的数值比较大，将会需要很多的空间。另一个问题是，一旦程序在中间中断，我们不可能恢复程序，因为我们根本不知道中间量是多少，该怎么处理。</p><h2 id="线性迭代"><a class="markdownIt-Anchor" href="#线性迭代"></a> 线性迭代</h2><p>如果我们自己维护这部分中间变量，那么考虑如下程序：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; time = O(n)</span></span><br><span class="line"><span class="comment">; space = O(1)</span></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">factorial</span> n)</span><br><span class="line">    (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">iter</span> product counter)</span><br><span class="line">        (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">&gt;</span></span> counter n)</span><br><span class="line">            product</span><br><span class="line">            <span class="comment">; 将结果重复代入参数，得到一个笔直的计算过程</span></span><br><span class="line">            (<span class="name">iter</span></span><br><span class="line">                (<span class="name"><span class="builtin-name">*</span></span> counter product)</span><br><span class="line">                (<span class="name"><span class="builtin-name">+</span></span> counter <span class="number">1</span>))))</span><br><span class="line">    (<span class="name">iter</span> <span class="number">1</span> <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">(<span class="name">factorial</span> <span class="number">6</span>)</span><br></pre></td></tr></table></figure><p>也就是说，我们每次计算得出的值，都重新的传入函数作为参数了。它的计算过程是这样的：</p><p><img src="https://bebopfzj.oss-cn-hangzhou.aliyuncs.com/uPic/2020-06-05-zHzBm3.png" alt="线性迭代" /></p><p>从形状上，我们可以很清楚的看到，计算过程并没有任何增长或者收缩。这就是所谓的迭代计算过程，也就是说，其状态可以用固定数目的状态变量描述的计算过程。</p><h2 id="树形递归"><a class="markdownIt-Anchor" href="#树形递归"></a> 树形递归</h2><p>我们考虑一个斐波那契数序列的计算：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; time = O(fib(n))</span></span><br><span class="line"><span class="comment">; space = O(n)</span></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">fib</span> n)</span><br><span class="line">    (<span class="name"><span class="builtin-name">cond</span></span></span><br><span class="line">        ((<span class="name"><span class="builtin-name">=</span></span> n <span class="number">0</span>) <span class="number">0</span>)</span><br><span class="line">        ((<span class="name"><span class="builtin-name">=</span></span> n <span class="number">1</span>) <span class="number">1</span>)</span><br><span class="line">        (<span class="name"><span class="builtin-name">else</span></span></span><br><span class="line">            <span class="comment">; 将父问题分裂为多个子问题，从而展开为树形</span></span><br><span class="line">            (<span class="name"><span class="builtin-name">+</span></span></span><br><span class="line">                (<span class="name">fib</span> (<span class="name"><span class="builtin-name">-</span></span> n <span class="number">1</span>))</span><br><span class="line">                (<span class="name">fib</span> ( - n <span class="number">2</span>))))))</span><br></pre></td></tr></table></figure><p>注意到，<code>else</code> 子句将一个父级问题，分解成了两个子级问题。这可能会导致很多的重复计算，但这样做的好处是清晰。你可以发现，用 <code>shceme</code> 语言写出的程序与实际的数学表达式并没有什么不同。</p><h1 id="用高阶函数做抽象"><a class="markdownIt-Anchor" href="#用高阶函数做抽象"></a> 用高阶函数做抽象</h1><p>事实上，过程也是一类抽象。它们并不依赖于特定的数，它们仅仅是描述了一些对于数的复合操作。这就意味着，可能一些过程之间会有相同之处，我们可以将其抽象出来。</p><p>例如对于下面这个求和：</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>n</mi><mo>=</mo><mi>a</mi></mrow><mi>b</mi></msubsup><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo><mo>+</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>+</mo><mi>f</mi><mo stretchy="false">(</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\sum_{n=a}^{b} f(n) = f(a) + ... + f(b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2887179999999998em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9890079999999999em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mrel mtight">=</span><span class="mord mathdefault mtight">a</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span></p><p>我们可以抽象出如下的模式：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">sum</span> f a next b)</span><br><span class="line">    (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">&gt;</span></span> a b)</span><br><span class="line">        <span class="number">0</span></span><br><span class="line">        (<span class="name"><span class="builtin-name">+</span></span> (<span class="name">f</span> a)</span><br><span class="line">            (<span class="name">sum</span> f (<span class="name">next</span> a) next b))))</span><br></pre></td></tr></table></figure><p>在这里，<code>f</code> 就是数学公式中的 <code>f(x)</code>。在具体的形式中，有可能表现为：<code>f(x) = x + 1</code>。但具体是什么形式并不重要。同样的，<code>next</code> 表示了下一个 <code>n</code> 应当怎样计算出来。在这个求和中，为 <code>n = n + 1</code>。</p><p>我们在这里，将 <code>f</code> 和 <code>next</code> 这两个过程当做参数传入了 <code>sum</code> 过程。这就是高阶函数抽象一部分。</p><p>另外的，过程也可以作为返回值。比如下面这个求导的程序：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">deriv</span> g)</span><br><span class="line">    (<span class="name"><span class="builtin-name">lambda</span></span> (x)</span><br><span class="line">        (<span class="name"><span class="builtin-name">/</span></span> (<span class="name"><span class="builtin-name">-</span></span> (<span class="name">g</span></span><br><span class="line">                (<span class="name"><span class="builtin-name">+</span></span> x dx))</span><br><span class="line">                (<span class="name">g</span> x))</span><br><span class="line">            dx)))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> dx <span class="number">0.000001</span>)</span><br></pre></td></tr></table></figure><p>在这里，<code>deriv</code> 接收一个过程 <code>g</code>，并产出了一个求导的过程。我们为了简便，使用了 <code>lambda</code> 形式来描述这个过程。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 抽象 </tag>
            
            <tag> 复杂度 </tag>
            
            <tag> scheme </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《操作系统导论》笔记——CPU虚拟化</title>
      <link href="/2020/05/26/virtualCPU/"/>
      <url>/2020/05/26/virtualCPU/</url>
      
        <content type="html"><![CDATA[<h1 id="思维导图"><a class="markdownIt-Anchor" href="#思维导图"></a> 思维导图</h1><p><img src="https://bebopfzj.oss-cn-hangzhou.aliyuncs.com/uPic/2020-05-26-81yGep.png" alt="虚拟化CPU" /></p><h1 id="关于虚拟化"><a class="markdownIt-Anchor" href="#关于虚拟化"></a> 关于虚拟化</h1><p>虚拟化一直都是操作系统设计中的一个重要主题。虚拟化的目的就是为了让计算机硬件更容易使用，例如，虚拟化 CPU 使得“同时”运行多个进程成为可能。<br />从逻辑上讲，这种技术将有限的硬件转化成“无限”的硬件，从而使得进程不必关系底层，专注于自身的任务就行。而操作系统通过提供这一实现，从而完成对硬件资源的管理。所以事实上你也可以将操作系统称为资源管理器。</p><h1 id="进程"><a class="markdownIt-Anchor" href="#进程"></a> 进程</h1><p>操作系统为正在运行的程序提供的抽象，就是进程（process）。进程的机器状态（在运行时可以读取或更新的内容）分为：内存、寄存器、持久存储设备。<br />它有三种状态：运行（running）、就绪（ready）、阻塞（blocked）。一个常见的进入阻塞的例子是进程发起<code>I/O</code>请求。<br />为了执行一个程序，操作系统将会先将代码和静态数据加载到内存中，然后创建并初始化进程的运行时栈，执行与 <code>I/O</code> 设置相关的工作。最后，在程序入口处运行。OS 将 CPU 的控制权交给进程。<br />UNIX 系统提供了相关的 API，来轻松的完成这些任务：<code>fork()</code>、<code>exec()</code>、<code>wait()</code>。</p><p>为了实现进程，我们需要一些低级<code>机制</code>来支撑。同时为了调度这些进程，我们还需要一些高级<code>策略</code>。下面分别分析。</p><a id="more"></a><h1 id="机制"><a class="markdownIt-Anchor" href="#机制"></a> 机制</h1><p>为了虚拟化 CPU，我们采用时分共享（time sharing）CPU 的方式。</p><h2 id="受限直接执行"><a class="markdownIt-Anchor" href="#受限直接执行"></a> 受限直接执行</h2><p>为了限制进程使用 CPU 的程度，我们为处理器引入了 <code>用户模式</code>。<br />同时，我们引入 <code>LDE协议</code>。这个协议分为两个阶段：</p><ol><li>在系统引导时，内核初始化陷阱表，并且 CPU 记住它的位置以供随后使用。</li><li>运行进程时，CPU 会以用户模式运行进程，当进程希望发出系统调用时，进程会陷入操作系统，CPU 控制权交给操作系统。待调用完成后，重新返回进程，将 CPU 控制权交还给进程。</li></ol><p>陷阱指令：在执行系统调用时执行。该指令跳入内核并将特权级别提升到内核模式。待操作完成后，调用从陷阱返回指令。<br />陷阱表：内核通过配置陷阱表来实现在陷阱中执行的代码。换句话说，就是告诉硬件在发生系统调用和其他异常事件时应当做什么。</p><h2 id="在进程之间切换"><a class="markdownIt-Anchor" href="#在进程之间切换"></a> 在进程之间切换</h2><p>我们引入时钟中断（timer interrupt）来保证操作系统在一个周期内可以重新获取硬件控制权，而不论进程是否想交出控制权。<br />操作系统在取得控制权后，需要决定是继续运行当前进程，还是切换至另一进程。若决定切换，需要执行上下文切换（context switch）。详细来说，操作系统会为当前进程保存寄存器、程序计数器和内核栈指针。并为新进程恢复这些东西，以供使用。<br />注意，这些操作是在陷阱中执行的。当操作系统最终执行从陷阱返回指令时，就意味着完成了上下文切换。</p><h1 id="策略"><a class="markdownIt-Anchor" href="#策略"></a> 策略</h1><p>为了更好地调度程序，我们开发了一些调度策略。<br />为了优化周转时间，我们优先运行最短的工作。<br />为了优化响应时间，我们交替运行所用工作。<br />但你要知道的是，我们无法同时兼顾周转时间和响应时间。</p><h2 id="多级反馈队列-mlfq"><a class="markdownIt-Anchor" href="#多级反馈队列-mlfq"></a> 多级反馈队列 MLFQ</h2><p>MLFQ 中有多个优先级不同的队列，MLFQ 总是执行优先级较高的工作。对于相同优先级的工作，采取轮转调度。详细的规则如下：</p><ol><li>如果 A 优先级 &gt;= B 优先级，仅允许 A</li><li>如果 A 优先级 = B 优先级，轮转允许 A 与 B</li><li>新工作进入系统时，放在最高优先级</li><li>一旦工作用完了其在某一层中的时间配额，就降低其优先级</li><li>经过一段时间 S，就将系统中所有工作重新加入最高优先级队列</li></ol><h2 id="比例份额"><a class="markdownIt-Anchor" href="#比例份额"></a> 比例份额</h2><p>这种调度策略确保每个工作都获得一定比例的 CPU 时间，而不是优化周转时间和响应时间。<br />操作系统每隔一段时间举行彩票抽奖，以确定接下来该运行哪个程序。每个程序都被分配了一定的彩票。因为抽奖是随机的，所以在较长的时间后，各程序所使用 CPU 的时间将会趋于预先设置的比例。<br />进程可以临时提高自己的彩票持有数来获取更多的 CPU 时间。这一操作不需要和其他进程通信。</p><p>这种策略的缺点是，当执行工作时间很短时，平均不公平度很糟糕。为了优化，提出了步长调度（stride scheduling）。<br />简单来说，系统中每一个工作都有与票数值成反比的步长。各进程的最初行程值都为 0，系统会优先运行具有最小行程值的进程，然后将其步长加入到行程值中。<br />这样做的好处是在一定周期内可以保证调度公平。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> 虚拟化 </tag>
            
            <tag> cpu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模板类中的运算符重载与T&amp;</title>
      <link href="/2020/05/24/friendAndReferenceInC/"/>
      <url>/2020/05/24/friendAndReferenceInC/</url>
      
        <content type="html"><![CDATA[<blockquote><p>最近在读《数据结构、算法与应用》这本书。因为对<code>C++</code>不太熟悉，<s>所以总感觉像是在学 C++而不是算法一样</s>。在读书里的代码时，遇到了两个算是比较常见的问题，查了查资料后发现涉及到的内容还挺多的，故而记录一下。</p></blockquote><h1 id="问题描述"><a class="markdownIt-Anchor" href="#问题描述"></a> 问题描述</h1><ol><li>如何区分 <code>T</code> 和 <code>T&amp;</code>？<br />换句话说，如何理解以下两种代码的区别？</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span>&amp; <span class="title">getData</span>() &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span> <span class="title">getData</span>() &#123;</span>&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>为何在模板类中的运算符重载不生效？<br />有如下模板类和实现：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">matrix</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp;, <span class="keyword">const</span> matrix&lt;T&gt;&amp;);</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      matrix(<span class="keyword">int</span> theRows = <span class="number">0</span>, <span class="keyword">int</span> theColumns = <span class="number">0</span>);</span><br><span class="line">      matrix(<span class="keyword">const</span> matrix&lt;T&gt;&amp;);</span><br><span class="line">      ~matrix() &#123;<span class="keyword">delete</span> [] element;&#125;</span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">rows</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> theRows;&#125;</span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">columns</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> theColumns;&#125;</span><br><span class="line">      <span class="function">T&amp; <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> <span class="keyword">const</span></span>;</span><br><span class="line">      matrix&lt;T&gt;&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> matrix&lt;T&gt;&amp;);</span><br><span class="line">      matrix&lt;T&gt; <span class="keyword">operator</span>+() <span class="keyword">const</span>; <span class="comment">// unary +</span></span><br><span class="line">      matrix&lt;T&gt; <span class="keyword">operator</span>+(<span class="keyword">const</span> matrix&lt;T&gt;&amp;) <span class="keyword">const</span>;</span><br><span class="line">      matrix&lt;T&gt; <span class="keyword">operator</span>-() <span class="keyword">const</span>; <span class="comment">// unary minus</span></span><br><span class="line">      matrix&lt;T&gt; <span class="keyword">operator</span>-(<span class="keyword">const</span> matrix&lt;T&gt;&amp;) <span class="keyword">const</span>;</span><br><span class="line">      matrix&lt;T&gt; <span class="keyword">operator</span>*(<span class="keyword">const</span> matrix&lt;T&gt;&amp;) <span class="keyword">const</span>;</span><br><span class="line">      matrix&lt;T&gt;&amp; <span class="keyword">operator</span>+=(<span class="keyword">const</span> T&amp;);</span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">       <span class="keyword">int</span> theRows,    <span class="comment">// number of rows in matrix</span></span><br><span class="line">           theColumns; <span class="comment">// number of columns in matrix</span></span><br><span class="line">       T *element;     <span class="comment">// element array</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 省略其他方法及构造函数、析构函数的实现</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">ostream</span>&amp; <span class="title">operator</span>&lt;&lt;(ostream&amp; out, const matrix&lt;T&gt;&amp; m)</span></span><br><span class="line"><span class="class">&#123;// Put matrix m into the stream out.</span></span><br><span class="line"><span class="class"> // One row per line.</span></span><br><span class="line"><span class="class">   int k = 0;  // index into element array</span></span><br><span class="line"><span class="class">   for (int i = 0; i &lt; m.theRows; i++)</span></span><br><span class="line"><span class="class">   &#123;// do row i</span></span><br><span class="line"><span class="class">      for (int j = 0; j &lt; m.theColumns; j++)</span></span><br><span class="line"><span class="class">         out &lt;&lt; m.element[k++] &lt;&lt; "  ";</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">      // row i finished</span></span><br><span class="line"><span class="class">      out &lt;&lt; endl;</span></span><br><span class="line"><span class="class">   &#125;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">   return out;</span></span><br><span class="line"><span class="class">&#125;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">int main()</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class">    matrix&lt;int&gt; x(3,2);</span></span><br><span class="line"><span class="class">    cout &lt;&lt; x;</span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure><p>运行这个代码，会得到如下错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Undefined symbols for architecture x86_64:</span><br><span class="line">  &quot;operator&lt;&lt;(std::__1::basic_ostream&lt;char, std::__1::char_traits&lt;char&gt; &gt;&amp;, matrix&lt;int&gt; const&amp;)&quot;, referenced from:</span><br><span class="line">      _main in matrix-04a950.o</span><br><span class="line">ld: symbol(s) not found for architecture x86_64</span><br><span class="line">clang: error: linker command failed with exit code 1 (use -v to see invocation)</span><br></pre></td></tr></table></figure><p>接下来分别分析这两个问题。</p><a id="more"></a><h1 id="如何区分-t-和-t"><a class="markdownIt-Anchor" href="#如何区分-t-和-t"></a> 如何区分 <code>T</code> 和 <code>T&amp;</code></h1><p>在模板类中，我们经常需要对私有数据设置取值方法，以便于精确地控制对应实例的行为。而 <code>C++</code> 的函数具有两种返回类型：引用类型、非引用类型。</p><h2 id="引用类型与非引用类型"><a class="markdownIt-Anchor" href="#引用类型与非引用类型"></a> 引用类型与非引用类型</h2><blockquote><p>你可以通过<a href="https://en.wikipedia.org/wiki/Reference_%28C++%29" target="_blank" rel="noopener">维基百科</a>获取更详细的信息。</p></blockquote><p>简单来说，<code>C++</code> 中的引用类型就是为已存在的对象指定一个新的名字。<br />你可以这样声明一个引用类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Type&gt;&amp; &lt;Nmae&gt;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> name = <span class="string">"Spike"</span>;</span><br><span class="line"><span class="built_in">string</span>&amp; name_reference = name;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">myAge</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>在上面的例子中，我们声明了一个 <code>string</code> 类型的变量 <code>name</code>，并将 <code>Spike</code> 字符串存储在其中。接着，我们声明了一个引用类型的变量，用来存储 <code>name</code>。<br />在 <code>myAge()</code> 的声明中，我们定义了其返回类型为 <code>int&amp;</code> 。这意味着该函数将会返回<strong>int 类型的引用（reference to int）</strong>。</p><h2 id="原问题的解释"><a class="markdownIt-Anchor" href="#原问题的解释"></a> 原问题的解释</h2><p>事实上，只要理解了 <code>C++</code> 中的引用类型，这个问题也就迎刃而解了。<br /><code>T getDate()</code> 是一个函数，它返回类型 <code>T</code> 的对象。换句话说，无论函数返回什么，这个返回值都将会被复制，然后交给调用者。也就是所谓的“复制返回”。不过在实际代码中，往往不需要总是复制返回值，所以编译器会在适当的情况下处理这种情况，这也就是众所周知的<strong>复制省略</strong></p><p><code>T&amp; getData()</code> 是一个函数，它返回类型 <code>T</code> 的对象<strong>的引用</strong>。也就是说，它仅仅会返回值在内存中的地址的引用。你可以通过引用去访问源对象。</p><p><strong>注意</strong>：不要返回对局部变量的引用。因为函数执行完成后，相关的数据都将会被销毁，这时的引用将会变得无效。</p><blockquote><p>上述解释参考了 <a href="https://stackoverflow.com/questions/14413376/difference-between-t-and-t" target="_blank" rel="noopener">stackoverflow 中的相同问题</a> 。你可以参考原问题以获取更详细的信息。</p></blockquote><h1 id="为何在模板类中的运算符重载不生效"><a class="markdownIt-Anchor" href="#为何在模板类中的运算符重载不生效"></a> 为何在模板类中的运算符重载不生效</h1><p>事实上，这个问题涉及到 <code>C++</code> 的友元处理。所以我们先从友元的概念说起。</p><p>你可以通过关键词，在类中定义函数或其他类，以访问源类的<code>private</code> 或 <code>protected</code> 成员。这种特性被称为 <code>友元（friend declaration）</code>。</p><p>如果你需要在模板类中定义友元运算符重载，那么你应当在 class body 中实现这个重载函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">matrix</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">friend</span> ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, <span class="keyword">const</span> matrix&lt;T&gt; &amp; m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>; <span class="comment">// index into element array</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m.theRows; i++)</span><br><span class="line">        &#123; <span class="comment">// do row i</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m.theColumns; j++)</span><br><span class="line">                out &lt;&lt; m.element[k++] &lt;&lt; <span class="string">"  "</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// row i finished</span></span><br><span class="line">            out &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> out;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过这样做的结果是，你会为每个 <code>T</code> 都生成一个非模板的运算符 <code>&lt;&lt;</code>。</p><p>如果你一定要生成一个模板化的 <code>&lt;&lt;</code>。那么你可以这样做：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">matrix</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// 这个模板的任何实例都是友元</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">friend</span> <span class="title">ostream</span> &amp;<span class="title">operator</span>&lt;&lt;(ostream &amp;, const matrix&lt;T1&gt; &amp;);</span></span><br><span class="line"><span class="class">&#125;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">template &lt;class T&gt;</span></span><br><span class="line"><span class="class">ostream &amp;operator&lt;&lt;(ostream &amp;, const matrix&lt;T&gt; &amp;)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class">    int k = 0; // index into element array</span></span><br><span class="line"><span class="class">    for (int i = 0; i &lt; m.theRows; i++)</span></span><br><span class="line"><span class="class">    &#123; // do row i</span></span><br><span class="line"><span class="class">        for (int j = 0; j &lt; m.theColumns; j++)</span></span><br><span class="line"><span class="class">            out &lt;&lt; m.element[k++] &lt;&lt; "  ";</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">        // row i finished</span></span><br><span class="line"><span class="class">        out &lt;&lt; endl;</span></span><br><span class="line"><span class="class">    &#125;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">    return out;</span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure><p>这样做的结果是，在明确地调用该运算符时，才会生成它。</p><blockquote><p>你可以参考<a href="https://stackoverflow.com/questions/4660123/overloading-friend-operator-for-template-class" target="_blank" rel="noopener">stackoverflow 上的回答</a>以获取更多信息。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 语言特性 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 友元 </tag>
            
            <tag> T&amp; </tag>
            
            <tag> Reference </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>桶排序——以 C++ 实现</title>
      <link href="/2020/05/20/bucketSort/"/>
      <url>/2020/05/20/bucketSort/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文基于 《数据结构、算法与应用： C++ 语言描述》 第 5 章的内容。线性表的实现则可参考之前的文章。</p></blockquote><h1 id="桶排序"><a class="markdownIt-Anchor" href="#桶排序"></a> 桶排序</h1><p><code>桶排序（Bucket Sort）</code>，也叫箱排序。在维基百科上对桶排序的<a href="https://en.wikipedia.org/wiki/Bucket_sort" target="_blank" rel="noopener">定义</a>是：</p><blockquote><p>Bucket sort, or bin sort, is a sorting algorithm that works by distributing the elements of an array into a number of buckets. Each bucket is then sorted individually, either using a different sorting algorithm, or by recursively applying the bucket sorting algorithm.</p></blockquote><p>总的来说，桶排序是这样一种方法。它将要排序的数组切分为几个部分，对各部分独立的排序，然后将桶连接起来就得到了排序结果。当要被排序的数组内的数值是均匀分配的时候，桶排序使用线性时间 <code>O(n)</code>。</p><p>桶排序的步骤是这样的：</p><ol><li>创建一个数组，数组的每一个元素都是一个初始化了的空桶。</li><li><strong>分散</strong>：遍历准备要排序的原始序列，依据各桶的数值范围，将其放入不同的桶中。</li><li>对每一个不为空的桶独立的进行排序</li><li><strong>合并</strong>：遍历非空桶，将元素重新依次放回源序列中</li></ol><a id="more"></a><h1 id="桶排序伪代码"><a class="markdownIt-Anchor" href="#桶排序伪代码"></a> 桶排序伪代码</h1><p>这里的伪代码参考了维基百科。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function bucket-sort(array, n) is</span><br><span class="line">  buckets ← new array of n empty lists</span><br><span class="line">  for i &#x3D; 0 to (length(array)-1) do</span><br><span class="line">    insert array[i] into buckets[msbits(array[i], k)]</span><br><span class="line">  for i &#x3D; 0 to n - 1 do</span><br><span class="line">    next-sort(buckets[i])</span><br><span class="line">  return the concatenation of buckets[0], ..., buckets[n-1]</span><br></pre></td></tr></table></figure><h1 id="c-实现"><a class="markdownIt-Anchor" href="#c-实现"></a> C++ 实现</h1><p>基于前面文章实现的线性表，我们考虑这样一个实际应用：<br />现有 20 名学生，其成绩 <strong>均匀的</strong> 分布于 <code>[1, 2]</code> 的区间中。试设计算法排序。</p><p>首先，我们先设计一个链表节点的数据类型，用以存储学生成绩数据：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">studentRecord</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">int</span> score;</span><br><span class="line">   <span class="built_in">string</span>* name;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">int</span> <span class="keyword">operator</span> !=(studentRecord x) <span class="keyword">const</span></span><br><span class="line">      &#123;<span class="keyword">return</span> (score != x.score);&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, <span class="keyword">const</span> studentRecord&amp; x)</span><br><span class="line">   &#123;out &lt;&lt; x.score &lt;&lt; <span class="string">' '</span> &lt;&lt; *x.name &lt;&lt; <span class="built_in">endl</span>; <span class="keyword">return</span> out;&#125;</span><br></pre></td></tr></table></figure><p>我们重载了操作符 <code>!=</code> 以便于比较成绩。</p><p>接着，我们按照第一节给出的步骤，实现桶排序的函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">binSort</span><span class="params">(chain&lt;studentRecord&gt;&amp; theChain, <span class="keyword">int</span> range)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 基于原始数据的大小，创建动态数组</span></span><br><span class="line">    chain&lt;studentRecord&gt; *bin = <span class="keyword">new</span> chain&lt;studentRecord&gt; [range + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分散</span></span><br><span class="line">    <span class="keyword">int</span> numberOfElements = theChain.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= numberOfElements; i++)</span><br><span class="line">    &#123;</span><br><span class="line">      studentRecord x = theChain.<span class="built_in">get</span>(<span class="number">0</span>);</span><br><span class="line">      bin[x.score].insert(<span class="number">0</span>,x);</span><br><span class="line">      theChain.erase(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = range; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">        <span class="keyword">while</span> (!bin[j].empty())</span><br><span class="line">        &#123;</span><br><span class="line">            studentRecord x = bin[j].<span class="built_in">get</span>(<span class="number">0</span>);</span><br><span class="line">            bin[j].erase(<span class="number">0</span>);</span><br><span class="line">            theChain.insert(<span class="number">0</span>,x);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> [] bin;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 桶排序 </tag>
            
            <tag> 链表 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性表——链式描述</title>
      <link href="/2020/05/18/linearListChain/"/>
      <url>/2020/05/18/linearListChain/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文基于 《数据结构、算法与应用：C++ 语言描述》 第 5 章的内容。</p></blockquote><h1 id="关于链表"><a class="markdownIt-Anchor" href="#关于链表"></a> 关于链表</h1><p>本文使用链表来实现线性表。因为链表本身的特性，很多操作会比数组实现轻松容易的多。下面简单介绍一下链表：</p><p><img src="https://bebopfzj.oss-cn-hangzhou.aliyuncs.com/uPic/2020-05-18-0cAcpm.png" alt="链表" /><br />如图所示，就是链表，更准确的来说，是单向链表。<br />链表由节点组成，每个节点分为 <code>链域</code> 和 <code>数据域</code>。数据域中保存的就是数据了，而链域保存着指针，这个指针指向了链表中下一个节点的内存地址。换句话说，为了寻找到索引为 <code>theIndex</code> 的元素，你需要从 <code>firstNode</code> 一路寻找下去。这也意味着不论是删除还是插入，越靠近链表头，算法的执行效率将越快。</p><a id="more"></a><h1 id="定义链表节点"><a class="markdownIt-Anchor" href="#定义链表节点"></a> 定义链表节点</h1><p>基于上面的描述，我们知道一个链表节点将包含两个位置。所以我们需要使用 <code>C++</code> 的结构体来描述这种数据类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">chainNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// 数据</span></span><br><span class="line">    T element;</span><br><span class="line">    chainNode&lt;T&gt; *next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    chainNode() &#123;&#125;;</span><br><span class="line">    chainNode(<span class="keyword">const</span> T&amp; element)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;element = element;</span><br><span class="line">    &#125;</span><br><span class="line">    chainNode(<span class="keyword">const</span> T&amp; element, chainNode&lt;T&gt; *next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;element = element;</span><br><span class="line">        <span class="keyword">this</span>-&gt;next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，因为数据名称和形参一样，所以使用了 <code>this-&gt;element</code> 来访问结构体的数据成员。</p><blockquote><p>此外，因为文本的实现也需要错误类，但为了防止重复就不写了，你可以参考<a href="https://www.bebopser.com/2020/05/17/linearListArrayList/#%E9%94%99%E8%AF%AF%E7%B1%BB">数组描述中的实现</a>。</p></blockquote><h1 id="线性表的链表实现"><a class="markdownIt-Anchor" href="#线性表的链表实现"></a> 线性表的链表实现</h1><p>首先，我们继承 <code>linearList</code>，实现一个 <code>chain</code> 类。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">chain</span> :</span> <span class="keyword">public</span> linearList&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数，复制构造函数和析构函数</span></span><br><span class="line">    chain(<span class="keyword">int</span> initialCapacity = <span class="number">10</span>);</span><br><span class="line">    chain(<span class="keyword">const</span> chain&lt;T&gt; &amp;);</span><br><span class="line">    ~chain();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据类型的 ADT 方法</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> listSize == <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> listSize&#125;;</span><br><span class="line">    <span class="function">T &amp;<span class="title">get</span><span class="params">(<span class="keyword">int</span> theIndex)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(<span class="keyword">const</span> T &amp;theElement)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">erase</span><span class="params">(<span class="keyword">int</span> theIndex)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> theIndex, <span class="keyword">const</span> T &amp;theElement)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(ostream &amp;out)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">checkIndex</span><span class="params">(<span class="keyword">int</span> theIndex)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    chainNode&lt;T&gt; *firstNode;</span><br><span class="line">    <span class="keyword">int</span> listSize;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意到其中的 <code>firstNode</code> 是一个指针，指向了线性表的首元素。而 <code>listSize</code> 则为线性表元素的个数。<br />如果线性表为空，那么 <code>firstNode</code> 的值为 <code>NULL</code>。</p><h2 id="构造函数"><a class="markdownIt-Anchor" href="#构造函数"></a> 构造函数</h2><p>为了与数组实现的构造函数兼容，我们依然提供了指定元素最大个数的形参 <code>initialCapacity</code>。但你知道这是事实并没有什么卵用。<br />我们通过此构造函数创建了一个空的线性表。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">chain</span>&lt;T&gt;:</span>:chain(<span class="keyword">int</span> initialCapacity)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 链表实现中不需要 initialCapacity，此处的意义是兼容 arrayList</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ostringstream</span> s;</span><br><span class="line">        s &lt;&lt; <span class="string">"Initial capacity = "</span> &lt;&lt; initialCapacity &lt;&lt; <span class="string">" Must be &gt; 0 "</span>;</span><br><span class="line">        <span class="keyword">throw</span> illegalParameterValue(s.str());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fitstNode = <span class="literal">NULL</span>;</span><br><span class="line">    listSize = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接着，我们实现一个复制构造函数。你需要注意的是，复制构造函数需要复制链表 <code>theList</code> 的每一个节点。换句话说，你需要迭代线性表的每一个元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">chain</span>&lt;T&gt;:</span>:chain(<span class="keyword">const</span> chain&lt;T&gt; &amp;theList)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 复制构造函数</span></span><br><span class="line"></span><br><span class="line">    listSize = theList.listSize;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (listSize == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 链表为空</span></span><br><span class="line">        firstNode = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 链表非空</span></span><br><span class="line">    chaninNode&lt;T&gt; *sourceNode = theList.firstNode;</span><br><span class="line">    firstNode = <span class="keyword">new</span> chainNode&lt;T&gt;(sourceNode-&gt;element);</span><br><span class="line">    sourceNode = sourceNode-&gt;next;</span><br><span class="line">    <span class="comment">// 使用一个新指针来迭代</span></span><br><span class="line">    <span class="comment">// 因为原本 firstNode 就是指向链表第一个元素的指针，如果使用 firstNode 迭代的话，逻辑就错了</span></span><br><span class="line">    chainNode&lt;T&gt; *targetNode = firstNode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (sourceNode != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 复制剩余元素</span></span><br><span class="line">        targetNode-&gt;next = next chainNode&lt;T&gt;(sourceNode-&gt;element);</span><br><span class="line">        targetNode = targetNode-&gt;next;</span><br><span class="line">        sourceNode = sourceNode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    targetNode-&gt;next = <span class="literal">NULL</span>; <span class="comment">// 链表结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逻辑分为两部分：链表为空，链表不为空。下面详细讲述一下：</p><h3 id="链表为空"><a class="markdownIt-Anchor" href="#链表为空"></a> 链表为空</h3><p>当链表为空时，即 <code>listSize</code> 的值为 <code>0</code>。我们只需要将 <code>firstNode</code> 置为 <code>NULL</code> 即可。</p><h3 id="链表不为空"><a class="markdownIt-Anchor" href="#链表不为空"></a> 链表不为空</h3><p>当链表不为空时，我们需要迭代的创建 <code>chainNode</code>，然后将其复制进新链表中。</p><ol><li><p>在上面的代码中，我们创建了 <code>sourceNode</code> 来保存旧节点。而基于链表的特性，我们只需要将 <code>theList.firstNode</code> 赋值过去就行了。<br /><img src="https://bebopfzj.oss-cn-hangzhou.aliyuncs.com/uPic/2020-05-18-6WoTTG.png" alt="存储旧节点" /></p></li><li><p>接着，我们需要使用旧节点保存的元素来创建一个新的 <code>chainNode</code> 节点。<br /><img src="https://bebopfzj.oss-cn-hangzhou.aliyuncs.com/uPic/2020-05-18-YMeox6.png" alt="创建新节点" /></p></li><li><p>然后，我们就可以将 <code>sourceNode</code> 指针向后移动，指向线性表中的下一个元素了。<br /><img src="https://bebopfzj.oss-cn-hangzhou.aliyuncs.com/uPic/2020-05-18-YezzP5.png" alt="找到下一个节点" /></p></li><li><p>同时，我们创建一个<code>targetNode</code>来存储新的线性表。<br /><img src="https://bebopfzj.oss-cn-hangzhou.aliyuncs.com/uPic/2020-05-18-j2qXrD.png" alt="存储新的线性表" /></p></li><li><p>最后，我们需要一个循环，来遍历旧的线性表，同时更新新的线性表即可。在遍历的时候，使用旧表中的元素创建 <code>chainNode</code>，然后将此节点加入新表。</p></li></ol><h2 id="析构函数"><a class="markdownIt-Anchor" href="#析构函数"></a> 析构函数</h2><p>析构函数的逻辑很简单，遍历整个线性表，然后将所有节点的内存释放即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">chain</span>&lt;T&gt;:</span>:~chain()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 链表析构函数</span></span><br><span class="line">    <span class="keyword">while</span> (firstNode != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 存储下一个节点的指针，以便于下一次循环找到下一个节点</span></span><br><span class="line">        chainNode&lt;T&gt; *nextNode = firstNode-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> firstNode;</span><br><span class="line">        firstNode = nextNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法"><a class="markdownIt-Anchor" href="#方法"></a> 方法</h2><p>因为链表本身的特性，想要找到 <code>theIndex</code> 的元素，就必须从 <code>firstNode</code> 开始迭代。不像数组实现时，因为 <code>theIndex</code> 和元素的索引对应关系是可以使用函数计算出来的。这也就意味着前者可能在搜索链表前端的元素较快，但搜索后面的元素时就会变得特别慢，其时间复杂度为<code>O(theIndex)</code>。而数组的实现时间复杂度则为<code>O(1)</code>。<br /><s>我也替你们捉急啊！</s></p><h3 id="get"><a class="markdownIt-Anchor" href="#get"></a> get</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span>&amp; <span class="title">chain</span>&lt;T&gt;:</span>:<span class="built_in">get</span>(<span class="keyword">int</span> theIndex) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 返回索引为 theIndex 的元素</span></span><br><span class="line">    <span class="comment">// 若元素不存在则抛出异常</span></span><br><span class="line"></span><br><span class="line">    checkIndex(theIndex);</span><br><span class="line"></span><br><span class="line">    chainNode&lt;T&gt;* currentNode = firstNode;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;theIndex; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        currentNode = currentNode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> currentNode-&gt;element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="indexof"><a class="markdownIt-Anchor" href="#indexof"></a> indexOf</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">int</span> <span class="title">chain</span>&lt;T&gt;:</span>:indexOf(<span class="keyword">const</span> T&amp; theElement) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 返回元素 theElement 首次出现时的索引</span></span><br><span class="line">    <span class="comment">// 若不存在则返回 -1</span></span><br><span class="line"></span><br><span class="line">    chainNode&lt;T&gt;* currentNode = firstNode;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (currentNode != <span class="literal">NULL</span> &amp;&amp; currentNode-&gt;element != theElement)</span><br><span class="line">    &#123;</span><br><span class="line">        currentNode = currentNode-&gt;next;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确认寻找结果</span></span><br><span class="line">    <span class="keyword">if</span> (currentNode == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="erase"><a class="markdownIt-Anchor" href="#erase"></a> erase</h3><ol><li><p>如果你要删除链表头的一个元素，那么只需要将 <code>firstNode</code> 指向第二个元素即可。<br /><img src="https://bebopfzj.oss-cn-hangzhou.aliyuncs.com/uPic/2020-05-19-73hXet.png" alt="链表删除头元素" /></p></li><li><p>如果你要删除链表中的一个元素，那么只需要将目标元素的前一个元素的 <code>next</code> 指向目标元素的后一个元素就行了。<br /><img src="https://bebopfzj.oss-cn-hangzhou.aliyuncs.com/uPic/2020-05-18-zVimzU.png" alt="链表删除中元素" /></p></li><li><p>当然，最后不要忘了释放无用元素的内存空间。</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">chain</span>&lt;T&gt;:</span>:erase (<span class="keyword">int</span> theIndex)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 删除索引为 theIndex 的元素</span></span><br><span class="line">    <span class="comment">// 若该元素不存在，则抛出异常</span></span><br><span class="line"></span><br><span class="line">    checkIndex(theIndex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 索引有效</span></span><br><span class="line">    chainNode&lt;T&gt;* deleteNode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (theIndex == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 删除链表头节点</span></span><br><span class="line">        deleteNode = firstNode;</span><br><span class="line">        firstNode = firstNode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 创建一个指针，开始迭代</span></span><br><span class="line">        <span class="comment">// 找到要删除节点的前一个节点，你可以参考前面的示意图来理解</span></span><br><span class="line">        chainNode&lt;T&gt;* p = firstNode;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;theIndex<span class="number">-1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        deleteNode = p-&gt;next;</span><br><span class="line">        p-&gt;next = p-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    listSize--;</span><br><span class="line">    <span class="keyword">delete</span> deleteNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="insert"><a class="markdownIt-Anchor" href="#insert"></a> insert</h3><p>其实插入和删除互为反操作。你需要注意的就是处理好指针域的指向。<br /><img src="https://bebopfzj.oss-cn-hangzhou.aliyuncs.com/uPic/2020-05-19-rrIRqa.png" alt="链表插入" /></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">chain</span>&lt;T&gt;:</span>:insert(<span class="keyword">int</span> theIndex, <span class="keyword">const</span> T&amp; theElement)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 在索引为 theIndex 的位置上插入元素 theElement</span></span><br><span class="line">    <span class="keyword">if</span> (theIndex&lt;<span class="number">0</span> || theIndex&gt;listSize)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 无效索引</span></span><br><span class="line">        <span class="built_in">ostringstream</span> s;</span><br><span class="line">        s &lt;&lt; <span class="string">"index = "</span> &lt;&lt; theIndex &lt;&lt; <span class="string">" size = "</span> &lt;&lt; listSize;</span><br><span class="line">        <span class="keyword">throw</span> illegalIndex(s.str());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (theIndex == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 在链表头插入</span></span><br><span class="line">        firstNode = <span class="keyword">new</span> chainNode&lt;T&gt;(theElement, firstNode);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 迭代链表，找到要插入位置的前一个元素</span></span><br><span class="line">        chainNode&lt;T&gt;* p = firstNode;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;theIndex<span class="number">-1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;next = <span class="keyword">new</span> chainNode&lt;T&gt;(theElement, p-&gt;next);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    listSize++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="输出链表"><a class="markdownIt-Anchor" href="#输出链表"></a> 输出链表</h2><p>和数组实现一样，依然是实现一个 <code>output</code> 方法，然后重载 <code>&lt;&lt;</code> 运算符。<br />另外因为链表本身的特性，想要遍历就只能使用指针来迭代。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">chain</span>&lt;T&gt;:</span>:output(ostream&amp; out) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 将链表放入输出流</span></span><br><span class="line">    <span class="keyword">for</span> (chainNode&lt;T&gt;* currentNode = firstNode;</span><br><span class="line">                        currentNode != <span class="literal">NULL</span>;</span><br><span class="line">                        currentNode = currentNode-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        out &lt;&lt; currentNode-&gt;element &lt;&lt; <span class="string">"   "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">ostream</span>&amp; <span class="title">operator</span>&lt;&lt;(ostream&amp; out, const chain&lt;T&gt;&amp; x)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class">    x.output(out);</span></span><br><span class="line"><span class="class">    return out;</span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure><h1 id="测试"><a class="markdownIt-Anchor" href="#测试"></a> 测试</h1><p>下面是作者提供的测试代码，你可以用来检验你的实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// test constructor</span></span><br><span class="line">   linearList&lt;<span class="keyword">double</span>&gt; *x = <span class="keyword">new</span> chain&lt;<span class="keyword">double</span>&gt;;</span><br><span class="line">   chain&lt;<span class="keyword">int</span>&gt; y, z;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// test size</span></span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">"Initial size of x, y, and z = "</span></span><br><span class="line">        &lt;&lt; x-&gt;<span class="built_in">size</span>() &lt;&lt; <span class="string">", "</span></span><br><span class="line">        &lt;&lt; y.<span class="built_in">size</span>() &lt;&lt; <span class="string">", "</span></span><br><span class="line">        &lt;&lt; z.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// test empty</span></span><br><span class="line">   <span class="keyword">if</span> (x-&gt;empty()) <span class="built_in">cout</span> &lt;&lt; <span class="string">"x is empty"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"x is not empty"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   <span class="keyword">if</span> (y.empty()) <span class="built_in">cout</span> &lt;&lt; <span class="string">"y is empty"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"y is not empty"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// test insert</span></span><br><span class="line">   y.insert(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">   y.insert(<span class="number">1</span>, <span class="number">6</span>);</span><br><span class="line">   y.insert(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">   y.insert(<span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">   y.insert(<span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">   y.insert(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">"Inserted 6 integers, list y should be 1 2 3 4 5 6"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">"Size of y = "</span> &lt;&lt; y.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   <span class="keyword">if</span> (y.empty()) <span class="built_in">cout</span> &lt;&lt; <span class="string">"y is empty"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"y is not empty"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   y.output(<span class="built_in">cout</span>);</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">"Testing overloaded &lt;&lt;"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; y &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// test indexOf</span></span><br><span class="line">   <span class="keyword">int</span> index = y.indexOf(<span class="number">4</span>);</span><br><span class="line">   <span class="keyword">if</span> (index &lt; <span class="number">0</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">"4 not found"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"The index of 4 is "</span> &lt;&lt; index &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">   index = y.indexOf(<span class="number">7</span>);</span><br><span class="line">   <span class="keyword">if</span> (index &lt; <span class="number">0</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">"7 not found"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"The index of 7 is "</span> &lt;&lt; index &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// test get</span></span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">"Element with index 0 is "</span> &lt;&lt; y.<span class="built_in">get</span>(<span class="number">0</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">"Element with index 3 is "</span> &lt;&lt; y.<span class="built_in">get</span>(<span class="number">3</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// test erase</span></span><br><span class="line">   y.erase(<span class="number">1</span>);</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">"Element 1 erased"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">"The list is "</span>  &lt;&lt; y &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   y.erase(<span class="number">2</span>);</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">"Element 2 erased"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">"The list is "</span>  &lt;&lt; y &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   y.erase(<span class="number">0</span>);</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">"Element 0 erased"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">"The list is "</span>  &lt;&lt; y &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">"Size of y = "</span> &lt;&lt; y.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   <span class="keyword">if</span> (y.empty()) <span class="built_in">cout</span> &lt;&lt; <span class="string">"y is empty"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"y is not empty"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">try</span> &#123;y.insert(<span class="number">-3</span>, <span class="number">0</span>);&#125;</span><br><span class="line">   <span class="keyword">catch</span> (illegalIndex e)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"Illegal index exception"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"Insert index must be between 0 and list size"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">      e.outputMessage();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// test copy constructor</span></span><br><span class="line">   <span class="function">chain&lt;<span class="keyword">int</span>&gt; <span class="title">w</span><span class="params">(y)</span></span>;</span><br><span class="line">   y.erase(<span class="number">0</span>);</span><br><span class="line">   y.erase(<span class="number">0</span>);</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">"w should be old y, new y has first 2 elements removed"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">"w is "</span> &lt;&lt; w &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">"y is "</span> &lt;&lt; y &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// a few more inserts, just for fun</span></span><br><span class="line">   y.insert(<span class="number">0</span>,<span class="number">4</span>);</span><br><span class="line">   y.insert(<span class="number">0</span>,<span class="number">5</span>);</span><br><span class="line">   y.insert(<span class="number">0</span>,<span class="number">6</span>);</span><br><span class="line">   y.insert(<span class="number">0</span>,<span class="number">7</span>);</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">"y is "</span> &lt;&lt; y &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
            <tag> C++ </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 线性表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性表——数组描述</title>
      <link href="/2020/05/17/linearListArrayList/"/>
      <url>/2020/05/17/linearListArrayList/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文基于 《数据结构、算法与应用：C++ 语言描述》 第 5 章的内容。</p></blockquote><h1 id="关于线性表"><a class="markdownIt-Anchor" href="#关于线性表"></a> 关于线性表</h1><p>线性表与数组有点像，都是存储了一组确定类型的元素。这些元素在线性表中按照线性 <code>顺序排列</code>。<br />线性表是有限的，其中的元素仅具有先后关系。另外的，线性表可以为空。</p><p>我们可以给出一个线性表的抽象类，以描述线性表可以进行的操作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">linearList</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">virtual</span> ~linearList() &#123;&#125;;</span><br><span class="line">        <span class="comment">// 当且仅当线性表为空时返回 true， 否则返回 false</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 返回线性表的大小</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 返回索引为 theIndex 的元素</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> T&amp; <span class="title">get</span><span class="params">(<span class="keyword">int</span> theIndex)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 返回元素 theElement 在线性表中第一次出现时的索引</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(<span class="keyword">const</span> T&amp; theElement)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 删除索引为 theIndex 的元素</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">erase</span><span class="params">(<span class="keyword">int</span> theIndex)</span> </span>= <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 把 theElement 插入到线性表中索引为 theIndex 的位置上</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> theIndex, <span class="keyword">const</span> T&amp; theElement)</span> </span>= <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 将线性表插入到输出流 out</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">output</span><span class="params">(ostream&amp; out)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="实现线性表的要点"><a class="markdownIt-Anchor" href="#实现线性表的要点"></a> 实现线性表的要点</h1><h2 id="线性表的顺序性"><a class="markdownIt-Anchor" href="#线性表的顺序性"></a> 线性表的顺序性</h2><p>线性表可以通过数组或链表来描述。但不管使用哪种基础数据类型实现，重要的是要关注到线性表中各元素是存在线性关系的。<br />例如给定如下线性表：</p><p><img src="https://bebopfzj.oss-cn-hangzhou.aliyuncs.com/uPic/2020-05-17-By43W1.png" alt="线性表" /></p><p>如果在 <code>index</code> 为 2 的地方插入元素 <code>E</code>，那么 <code>D</code> 元素需要向后移动一位：<br /><img src="https://bebopfzj.oss-cn-hangzhou.aliyuncs.com/uPic/2020-05-17-Mbg8bj.png" alt="线性表插入元素" /></p><p>事实上，这种顺序性就是线性表的核心。链表自带了这种特性，而使用数组实现的时候需要注意。</p><h2 id="模板类"><a class="markdownIt-Anchor" href="#模板类"></a> 模板类</h2><p>为了实现抽象数据类型 linearList，我们需要确认数组 element 的类型和数组长度。<br />在 C++ 中，一个模板类就像这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">person</span> &#123;</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="动态数组"><a class="markdownIt-Anchor" href="#动态数组"></a> 动态数组</h2><p>在 C++ 中，想要声明一个数组，你需要这样写：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type arrName[arrLength];</span><br></pre></td></tr></table></figure><p>换句话说，你得在一开始就指定数组的长度。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> myArr[<span class="number">20</span>];</span><br></pre></td></tr></table></figure><p>为了在运行时才确定数组的大小，我们可以像这样定义一个 <code>动态数组</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">size</span> = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span>* myArr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="built_in">size</span>];</span><br></pre></td></tr></table></figure><p>读一下代码，你会发现我们实际上是使用 <code>new</code> 操作符申请了一段内存，然后返回了一个指针。这个指针指向的是数组的第一个元素。<br />换句话说，动态数组可以不包含任何元素，因为空指针是允许的。</p><p>另外的，你可以像这样初始化一个动态数组：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认初始化</span></span><br><span class="line"><span class="comment">// 将所有元素初始化为 0</span></span><br><span class="line"><span class="keyword">int</span>* myArr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="built_in">size</span>]();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显式初始化</span></span><br><span class="line"><span class="keyword">int</span>* myArr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="built_in">size</span>] &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;;</span><br></pre></td></tr></table></figure><p>当你不需要这个数组之后，你需要释放它所占用的内存：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> [] myArr;</span><br></pre></td></tr></table></figure><p>更多有关动态数组，特别是多维数组的内容，你可以参考<a href="https://blog.csdn.net/u013921430/article/details/79601429" target="_blank" rel="noopener">这篇文章</a></p><h2 id="修改一维数组的长度"><a class="markdownIt-Anchor" href="#修改一维数组的长度"></a> 修改一维数组的长度</h2><p>这个算法的逻辑很简单。先使用新长度（可能是增加也可能是缩小）创建一个新数组，然后将旧数组的元素复制到这个新数组中，然后让旧变量名引用这个新数组。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">changeLength1D</span>(<span class="title">T</span>*&amp; <span class="title">a</span>, <span class="title">int</span> <span class="title">oldLength</span>, <span class="title">int</span> <span class="title">newLength</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">if</span> (newLength &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> illegalParameterValue(<span class="string">"new length must be &gt;= 0"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T* temp = <span class="keyword">new</span> T[newLength];</span><br><span class="line">    <span class="keyword">int</span> number = <span class="built_in">min</span>(oldLength, newLength);     <span class="comment">// 需要复制的元素个数</span></span><br><span class="line">    copy(a, a + number, temp);</span><br><span class="line">    <span class="keyword">delete</span> [] a;</span><br><span class="line">    a = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意其中 <code>copy()</code> 函数的定义是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">copy(inputIter_first, inputIter_last, outIter_result);</span><br></pre></td></tr></table></figure><h2 id="错误类"><a class="markdownIt-Anchor" href="#错误类"></a> 错误类</h2><p>这两个类是为了使线性表的实现抛出正确的错误。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">illegalParameterValue</span> :</span> <span class="keyword">public</span> exception</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 异常类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    illegalParameterValue() : message(<span class="string">"Illegal parameter value"</span>) &#123;&#125;</span><br><span class="line">    illegalParameterValue(<span class="built_in">string</span> str) : message(<span class="string">"Error : "</span> + str) &#123;&#125;</span><br><span class="line">    ~illegalParameterValue() <span class="keyword">throw</span>() &#123;&#125;</span><br><span class="line">    <span class="keyword">void</span> outputMessage()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; message &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> message;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">illegalIndex</span> :</span> <span class="keyword">public</span> exception</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    illegalIndex() : message(<span class="string">"Illegal index"</span>) &#123;&#125;</span><br><span class="line">    illegalIndex(<span class="built_in">string</span> str) : message(<span class="string">"Error: "</span> + str) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    ~illegalIndex() <span class="keyword">throw</span>() &#123;&#125;</span><br><span class="line">    <span class="keyword">void</span> outputMessage()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; message &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> message;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">illegalParameterValue() : message(<span class="string">"Illegal parameter value"</span>) &#123;&#125;</span><br></pre></td></tr></table></figure><p>的语法是初始化表达式。它等同为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">illegalParameterValue()</span><br><span class="line">&#123;</span><br><span class="line">    message = <span class="string">"Illegal parameter value"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="线性表的数组实现"><a class="markdownIt-Anchor" href="#线性表的数组实现"></a> 线性表的数组实现</h1><p>我们使用 <code>arrayList</code> 继承抽象类 <code>linearList</code> 。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">arrayList</span> :</span> <span class="keyword">public</span> linearList&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="comment">// constructor, copy constructor and destructor</span></span><br><span class="line">      arrayList(<span class="keyword">int</span> initialCapacity = <span class="number">10</span>);</span><br><span class="line">      arrayList(<span class="keyword">const</span> arrayList&lt;T&gt;&amp;);</span><br><span class="line">      ~arrayList() &#123;<span class="keyword">delete</span> [] element;&#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// ADT methods</span></span><br><span class="line">      <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> listSize == <span class="number">0</span>;&#125;</span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> listSize;&#125;</span><br><span class="line">      <span class="function">T&amp; <span class="title">get</span><span class="params">(<span class="keyword">int</span> theIndex)</span> <span class="keyword">const</span></span>;</span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(<span class="keyword">const</span> T&amp; theElement)</span> <span class="keyword">const</span></span>;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">erase</span><span class="params">(<span class="keyword">int</span> theIndex)</span></span>;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> theIndex, <span class="keyword">const</span> T&amp; theElement)</span></span>;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(ostream&amp; out)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">capacity</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> arrayLength;&#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">protected</span>:</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">checkIndex</span><span class="params">(<span class="keyword">int</span> theIndex)</span> <span class="keyword">const</span></span>;</span><br><span class="line">      T* element;            <span class="comment">// 实现线性表的一维数组</span></span><br><span class="line">      <span class="keyword">int</span> arrayLength;       <span class="comment">// 一维数组的容量</span></span><br><span class="line">      <span class="keyword">int</span> listSize;          <span class="comment">// 线性表的元素个数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中，增加了两个方法。<br /><code>capacity()</code> 方法返回了实现线性表的数组当前的长度。<br /><code>checkIndex()</code> 方法检查给出的索引是否在 <code>0 ~ listSize-1</code> 的范围内。</p><h2 id="构造函数"><a class="markdownIt-Anchor" href="#构造函数"></a> 构造函数</h2><p>我们在 <code>arrayList</code> 的定义中给出了构造函数的参数默认值，即 <code>initialCapacity = 10</code>。也就是说，实现这个线性表的数组的大小默认为 10 。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">arrayList</span>&lt;T&gt;:</span>:arrayList(<span class="keyword">int</span> initialCapacity)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 构造函数</span></span><br><span class="line">   <span class="keyword">if</span> (initialCapacity &lt; <span class="number">1</span>)</span><br><span class="line">   &#123;<span class="built_in">ostringstream</span> s;</span><br><span class="line">    s &lt;&lt; <span class="string">"Initial capacity = "</span> &lt;&lt; initialCapacity &lt;&lt; <span class="string">" Must be &gt; 0"</span>;</span><br><span class="line">    <span class="keyword">throw</span> illegalParameterValue(s.str());</span><br><span class="line">   &#125;</span><br><span class="line">   arrayLength = initialCapacity;</span><br><span class="line">   element = <span class="keyword">new</span> T[arrayLength];</span><br><span class="line">   <span class="comment">// 指线性表的元素个数</span></span><br><span class="line">   listSize = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时我们还需要定义 <code>复制构造函数</code>。它的作用是复制一个对象，当一个对象传值给一个函数，或者函数值返回一个对象时，都需要调用它。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">arrayList</span>&lt;T&gt;:</span>:arrayList(<span class="keyword">const</span> arrayList&lt;T&gt;&amp; theList)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 复制构造函数</span></span><br><span class="line">    arrayLength = theList.arrayLength;</span><br><span class="line">    listSize = theList.listSize;</span><br><span class="line">    element = <span class="keyword">new</span> T[arrayLength];</span><br><span class="line">    copy(theList.element, theList.element + listSize, element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="基本方法"><a class="markdownIt-Anchor" href="#基本方法"></a> 基本方法</h2><p>接下来的代码实现了 <code>arrayList</code> 的 <code>checkIndex</code>，<code>get</code>，<code>indexOf</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">arrayList</span>&lt;T&gt;:</span>:checkIndex(<span class="keyword">int</span> theIndex) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 确认索引的合法性</span></span><br><span class="line">    <span class="keyword">if</span> (theIndex &lt; <span class="number">0</span> || theIndex &gt;= listSize)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">std</span>::<span class="built_in">ostringstream</span> s;</span><br><span class="line">       s &lt;&lt; <span class="string">"index = "</span> &lt;&lt; theIndex &lt;&lt; <span class="string">" size = "</span> &lt;&lt; listSize;</span><br><span class="line">       <span class="keyword">throw</span> illegalIndex(s.str());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span>&amp; <span class="title">arrayList</span>&lt;T&gt;:</span>:<span class="built_in">get</span>(<span class="keyword">int</span> theIndex) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 检查索引合法性</span></span><br><span class="line">    checkIndex(theIndex);</span><br><span class="line">    <span class="keyword">return</span> element[theIndex];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">int</span> <span class="title">arrayList</span>&lt;T&gt;:</span>:indexOf(<span class="keyword">const</span> T&amp; theElement) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 返回 theElement 第一次出现时的索引</span></span><br><span class="line">    <span class="comment">// 若不存在则返回 -1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> theIndex = (<span class="keyword">int</span>) (<span class="built_in">find</span>(element, element + listSize, theElement) - element);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (theIndex == listSize)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 找到最后一个元素了都还妹找到</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> theIndex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除元素"><a class="markdownIt-Anchor" href="#删除元素"></a> 删除元素</h2><p>删除元素的方法是按照索引删除的，所以在操作之前需要确认索引的合法性。<br />另外删除操作本质上就是将后面的元素向前移动一位。这么操作的原因是线性表各元素之间是具有前后顺序关系的。这一点在 <code>线性表的顺序性</code> 一节已经阐述过了，不再赘述。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">arrayList</span>&lt;T&gt;:</span>:erase(<span class="keyword">int</span> theIndex)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 删除索引为 theIndex 的元素</span></span><br><span class="line">    checkIndex(theIndex);</span><br><span class="line">    copy(element + theIndex + <span class="number">1</span>, element + listSize, element + theIndex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除原来的引用</span></span><br><span class="line">    element[--listSize].~T();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入元素"><a class="markdownIt-Anchor" href="#插入元素"></a> 插入元素</h2><p>同样的，插入元素也是按照索引插入的，所以你需要在操作前校验索引的合法性。<br />其次，你可以再次参考 <code>线性表的顺序性</code> 一节的图，来理解插入行为。简单来说，就是需要将目标索引及之后的所有元素都后移一位。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">arrayList</span>&lt;T&gt;:</span>:insert(<span class="keyword">int</span> theIndex, <span class="keyword">const</span> T&amp; theElement)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 在索引 theIndex 处插入元素 theElement</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 校验索引合法性</span></span><br><span class="line">    <span class="keyword">if</span> (theIndex &lt; <span class="number">0</span> || theIndex &gt; listSize)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ostringstream</span> s;</span><br><span class="line">        s &lt;&lt; <span class="string">"index = "</span> &lt;&lt; theIndex &lt;&lt; <span class="string">" size = "</span> &lt;&lt; listSize;</span><br><span class="line">        <span class="keyword">throw</span> illegalIndex(s.str());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 索引有效，确认数组容量</span></span><br><span class="line">    <span class="keyword">if</span> (listSize == arrayLength)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 数组空间已满，则扩容</span></span><br><span class="line">        <span class="comment">// 这里默认将数组长度倍增</span></span><br><span class="line">        changeLength1D(element, arrayLength, <span class="number">2</span> * arrayLength);</span><br><span class="line">        arrayLength *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将目标索引及之后的所有元素向右移动一位，空出插入处</span></span><br><span class="line">    copy_backward(element + theIndex, element + listSize, element + theIndex + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将目标元素插入相应的位置</span></span><br><span class="line">    element[theIndex] = theElement;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修正线性表容量</span></span><br><span class="line">    listSize++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="输出"><a class="markdownIt-Anchor" href="#输出"></a> 输出</h2><p>为了格式化输出线性表，我们需要将线性表插入进输出流中。另外的，还需要重载 <code>&lt;&lt;</code> 运算符。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">arrayList</span>&lt;T&gt;:</span>:output(ostream&amp; out) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 将线性表插入输出流</span></span><br><span class="line">    copy(element, element + listSize, ostream_iterator&lt;T&gt;(<span class="built_in">cout</span>, <span class="string">"   "</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">ostream</span>&amp; <span class="title">operator</span>&lt;&lt; (ostream&amp; out, const arrayList&lt;T&gt;&amp; x)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class">    x.output(out);</span></span><br><span class="line"><span class="class">    return out;</span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure><h1 id="线性表的测试"><a class="markdownIt-Anchor" href="#线性表的测试"></a> 线性表的测试</h1><p>下面是本书给出的线性表测试代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// test constructor</span></span><br><span class="line">   linearList&lt;<span class="keyword">double</span>&gt; *x = <span class="keyword">new</span> arrayList&lt;<span class="keyword">double</span>&gt;(<span class="number">20</span>);</span><br><span class="line">   arrayList&lt;int&gt; y(2), z;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// test capacity</span></span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">"Capacity of x, y and z = "</span></span><br><span class="line">        &lt;&lt; ((arrayList&lt;<span class="keyword">double</span>&gt;*) x)-&gt;capacity() &lt;&lt; <span class="string">", "</span></span><br><span class="line">        &lt;&lt; y.capacity() &lt;&lt; <span class="string">", "</span></span><br><span class="line">        &lt;&lt; z.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">// test size</span></span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">"Initial size of x, y, and z = "</span></span><br><span class="line">        &lt;&lt; x-&gt;<span class="built_in">size</span>() &lt;&lt; <span class="string">", "</span></span><br><span class="line">        &lt;&lt; y.<span class="built_in">size</span>() &lt;&lt; <span class="string">", "</span></span><br><span class="line">        &lt;&lt; z.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// test empty</span></span><br><span class="line">   <span class="keyword">if</span> (x-&gt;empty()) <span class="built_in">cout</span> &lt;&lt; <span class="string">"x is empty"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"x is not empty"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   <span class="keyword">if</span> (y.empty()) <span class="built_in">cout</span> &lt;&lt; <span class="string">"y is empty"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"y is not empty"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// test insert</span></span><br><span class="line">   y.insert(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">   y.insert(<span class="number">1</span>, <span class="number">6</span>);</span><br><span class="line">   y.insert(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">   y.insert(<span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">   y.insert(<span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">   y.insert(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">"Inserted 6 integers, list y should be 1 2 3 4 5 6"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">"Size of y = "</span> &lt;&lt; y.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">"Capacity of y = "</span> &lt;&lt; y.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   <span class="keyword">if</span> (y.empty()) <span class="built_in">cout</span> &lt;&lt; <span class="string">"y is empty"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"y is not empty"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   y.output(<span class="built_in">cout</span>);</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">"Testing overloaded &lt;&lt;"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; y &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// test indexOf</span></span><br><span class="line">   <span class="keyword">int</span> index = y.indexOf(<span class="number">4</span>);</span><br><span class="line">   <span class="keyword">if</span> (index &lt; <span class="number">0</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">"4 not found"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"The index of 4 is "</span> &lt;&lt; index &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">   index = y.indexOf(<span class="number">7</span>);</span><br><span class="line">   <span class="keyword">if</span> (index &lt; <span class="number">0</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">"7 not found"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"The index of 7 is "</span> &lt;&lt; index &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// test get</span></span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">"Element with index 0 is "</span> &lt;&lt; y.<span class="built_in">get</span>(<span class="number">0</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">"Element with index 3 is "</span> &lt;&lt; y.<span class="built_in">get</span>(<span class="number">3</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// test erase</span></span><br><span class="line">   y.erase(<span class="number">1</span>);</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">"Element 1 erased"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">"The list is "</span>  &lt;&lt; y &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   y.erase(<span class="number">2</span>);</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">"Element 2 erased"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">"The list is "</span>  &lt;&lt; y &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">"Size of y = "</span> &lt;&lt; y.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">"Capacity of y = "</span> &lt;&lt; y.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   <span class="keyword">if</span> (y.empty()) <span class="built_in">cout</span> &lt;&lt; <span class="string">"y is empty"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"y is not empty"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">try</span> &#123;y.insert(<span class="number">-3</span>, <span class="number">0</span>);&#125;</span><br><span class="line">   <span class="keyword">catch</span> (illegalIndex e)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"Illegal index exception"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"Insert index must be between 0 and list size"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">      e.outputMessage();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// test copy constructor</span></span><br><span class="line">   <span class="function">arrayList&lt;<span class="keyword">int</span>&gt; <span class="title">w</span><span class="params">(y)</span></span>;</span><br><span class="line">   y.erase(<span class="number">0</span>);</span><br><span class="line">   y.erase(<span class="number">0</span>);</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">"w should be old y, new y has first 2 elements removed"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">"w is "</span> &lt;&lt; w &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">"y is "</span> &lt;&lt; y &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// a few more inserts, just for fun</span></span><br><span class="line">   y.insert(<span class="number">0</span>,<span class="number">4</span>);</span><br><span class="line">   y.insert(<span class="number">0</span>,<span class="number">5</span>);</span><br><span class="line">   y.insert(<span class="number">0</span>,<span class="number">6</span>);</span><br><span class="line">   y.insert(<span class="number">0</span>,<span class="number">7</span>);</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">"y is "</span> &lt;&lt; y &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 线性表 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++基础</title>
      <link href="/2020/05/15/C-%E5%9F%BA%E7%A1%80/"/>
      <url>/2020/05/15/C-%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文的例子来源于 《数据结构、算法与应用：C++ 语言描述》 第一章第 5 节。你可查看原文以获取更详尽的描述。由于本文旨在梳理清楚写算法时 C++ 的一些关键特性，所以不会过多地从工程角度描述代码</p></blockquote><h1 id="声明-currency-类"><a class="markdownIt-Anchor" href="#声明-currency-类"></a> 声明 currency 类</h1><p>在类的成员声明中，成员将会被分为两个部分：<code>public</code>, <code>private</code>。聪明的做法是正确的安排成员，以将类的实现细节对用户隐藏起来，仅暴露那些需要让用户看到的部分。这样做的好处是，可能在一段时间后，你对类的实现有了一个新的灵感，那么你可以轻易地改动代码，而不会影响到用户部分的代码。</p><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> signType</span><br><span class="line">&#123;</span><br><span class="line">    pluss,</span><br><span class="line">    minuss</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">currency</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数 constructor</span></span><br><span class="line">    currency(signType theSign = pluss,</span><br><span class="line">             <span class="keyword">unsigned</span> <span class="keyword">long</span> theDollars = <span class="number">0</span>,</span><br><span class="line">             <span class="keyword">unsigned</span> <span class="keyword">int</span> theCents = <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 析构函数 destructor</span></span><br><span class="line">    ~currency()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 赋值函数</span></span><br><span class="line">    <span class="comment">// 重载</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setValue</span><span class="params">(signType, <span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setValue</span><span class="params">(<span class="keyword">double</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">signType <span class="title">getSign</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sign;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">getDollars</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dollars;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">getCents</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cents;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">currency <span class="title">add</span><span class="params">(<span class="keyword">const</span> currency &amp;)</span> <span class="keyword">const</span></span>;  <span class="comment">// 返回对象的值</span></span><br><span class="line">    <span class="function">currency &amp;<span class="title">increment</span><span class="params">(<span class="keyword">const</span> currency &amp;)</span></span>; <span class="comment">// 返回对象的引用</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    signType sign;         <span class="comment">// 对象符号</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> dollars; <span class="comment">// 美元的数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> cents;    <span class="comment">// 美分的数量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意，<code>signType</code> 枚举中，我将 <code>plus</code> 写成了 <code>pluss</code>，<code>minus</code> 也同理。这并不是一个拼写错误。因为在文件开始使用了 <code>std</code>，这会导致命名冲突。</p><p>如果你不愿意这样写，你也可以改成：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> signType</span><br><span class="line">&#123;</span><br><span class="line">    plus</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">currency</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        currency(signType theSign = ::signType::plus)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="分别实现成员函数"><a class="markdownIt-Anchor" href="#分别实现成员函数"></a> 分别实现成员函数</h1><h2 id="构造函数"><a class="markdownIt-Anchor" href="#构造函数"></a> 构造函数</h2><p>为了简洁，所以省略了上面的代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">currency::currency(signType theSign, <span class="keyword">unsigned</span> <span class="keyword">long</span> theDollars, <span class="keyword">unsigned</span> <span class="keyword">int</span> theCents)</span><br><span class="line">&#123;</span><br><span class="line">    setValue(theSign, theDollars, theCents);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里在类的外部实现了构造函数。这样做的好处是使类的声明较为简洁，可以一眼看出声明了哪些成员。<br />因为在类外部实现，所以需要使用<code>作用域说明符 scope resolution operator</code>。即 <code>::</code>。</p><h2 id="setvalue"><a class="markdownIt-Anchor" href="#setvalue"></a> setValue</h2><p>在实现 <code>setValue</code> 函数时，我们首先校验了参数的合法性。这样做的好处是保证数据成员的有效性，可以让其他成员函数在操作数据前不必校验数据。<br />这样既能简化代码，也能提高运行速度</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">currency::setValue</span><span class="params">(signType theSign, <span class="keyword">unsigned</span> <span class="keyword">long</span> theDollars, <span class="keyword">unsigned</span> <span class="keyword">int</span> theCents)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (theCents &gt; <span class="number">99</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Cents should be &lt; 100"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sign = theSign;</span><br><span class="line">    dollars = theDollars;</span><br><span class="line">    cents = theCents;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">currency::setValue</span><span class="params">(<span class="keyword">double</span> theAmount)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (theAmount &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="comment">// 处理符号</span></span><br><span class="line">    &#123;</span><br><span class="line">        sign = minuss;</span><br><span class="line">        theAmount = -theAmount;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        sign = pluss;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dollars = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)theAmount;                          <span class="comment">// 提取整数部分</span></span><br><span class="line">    cents = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)((theAmount + <span class="number">0.001</span> - dollars) * <span class="number">100</span>); <span class="comment">// 提取小数部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意在提取小数部分的时候，我们将 <code>theAmount</code> 的值增加了 <code>0.001</code>。这样做的理由是，对于小数，计算机在保存时可能是不精确的。所以将值增加一点点，以保证处理后的值用计算机表示后与实际值相比不小于 0.001 或不多于 0.009 即可。这样在提取时就不会出错了。</p><h2 id="add"><a class="markdownIt-Anchor" href="#add"></a> add</h2><p>首先，你需要理解 <code>dollars</code> 与 <code>x.dollars</code> 的区别。前者指的是引用调用对象的数据成员，而后者则是引用参数对象 x 的数据成员。换句话说，前者指的是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">currencyIns.add(currencyIncc)</span><br></pre></td></tr></table></figure><p>在这段代码中，引用的的是 <code>currencyInc</code> 的数据成员。</p><p>其次，这个函数的返回值是值返回。这是因为 <code>result</code> 是 <code>add</code> 的局部对象。当方法终止时，所有的局部变量将会被析构函数删除，从而释放它们的空间。所以为了得到计算结果，必须将作为调用的返回值的结果复制到调用环境中。这也就是为什么使用值返回。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">currency <span class="title">currency::add</span><span class="params">(<span class="keyword">const</span> currency &amp;x)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 把 x 和 *this 相加</span></span><br><span class="line">    <span class="keyword">long</span> a1, a2, a3;</span><br><span class="line">    currency result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将调用对象转化为无符号整数</span></span><br><span class="line">    a1 = dollars * <span class="number">100</span> + cents;</span><br><span class="line">    <span class="keyword">if</span> (x.sign == minuss)</span><br><span class="line">    &#123;</span><br><span class="line">        a1 = -a1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把 x 转化为符号整数</span></span><br><span class="line">    a2 = x.dollars * <span class="number">100</span> + x.cents;</span><br><span class="line">    <span class="keyword">if</span> (x.sign == minuss)</span><br><span class="line">    &#123;</span><br><span class="line">        a2 = -a2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    a3 = a1 + a2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转换为 currency 对象的表达形式</span></span><br><span class="line">    <span class="comment">// 当然你也可以将这种转换封装为 setValue 函数</span></span><br><span class="line">    <span class="keyword">if</span> (a3 &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        result.sign = minuss;</span><br><span class="line">        a3 = -a3;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        result.sign = pluss;</span><br><span class="line">    &#125;</span><br><span class="line">    result.dollars = a3 / <span class="number">100</span>;</span><br><span class="line">    result.cents = a3 - result.dollars * <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="increment"><a class="markdownIt-Anchor" href="#increment"></a> increment</h2><p>在 <code>C++</code> 中，保留关键字 <code>this</code> 是指向调用对象的指针，所以理所当然的，<code>*this</code> 就是调用对象本身。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">currency &amp;<span class="title">currency::increment</span><span class="params">(<span class="keyword">const</span> currency &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *<span class="keyword">this</span> = add(x);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，<code>add</code>方法指的是<code>increment</code>方法调用者的<code>add</code>。这与上面 <code>add()</code> 方法的 <code>dollars</code> 是一样的。</p><p>对于 <code>add()</code> 方法的调用，你还可以写成如下两种形式，它们是等效的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*<span class="keyword">this</span> = (*<span class="keyword">this</span>).add(x);</span><br><span class="line">*<span class="keyword">this</span> = <span class="keyword">this</span>-&gt;add(x);</span><br></pre></td></tr></table></figure><h2 id="output"><a class="markdownIt-Anchor" href="#output"></a> output</h2><p>这个函数仅仅是做了一个标准输出。<br />说句题外话，就这个功能来说，<code>Python</code> 的 <code>__str__</code> 方法实现的更优雅啊。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">currency::output</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sign == minuss)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">'-'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">'$'</span> &lt;&lt; dollars &lt;&lt; <span class="string">'.'</span>;</span><br><span class="line">    <span class="keyword">if</span> (cents &lt; <span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">'0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; cents;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="使用-currency-类"><a class="markdownIt-Anchor" href="#使用-currency-类"></a> 使用 currency 类</h1><p>依然是为了避免重复，所以省略了之前的代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    currency g, h(pluss, <span class="number">3</span>, <span class="number">5</span>), i, j;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用两种形式的 setValue 来赋值</span></span><br><span class="line">    g.setValue(minuss, <span class="number">2</span>, <span class="number">25</span>);</span><br><span class="line">    i.setValue(<span class="number">-6.45</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用成员函数 add 和 output</span></span><br><span class="line">    j = h.add(g);</span><br><span class="line">    h.output();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">" + "</span>;</span><br><span class="line">    g.output();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">" = "</span>;</span><br><span class="line">    j.output();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连续调用两次成员函数 add</span></span><br><span class="line">    j = i.add(g).add(h);</span><br><span class="line">    j.output();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用成员函数 increment 和 add</span></span><br><span class="line">    j = i.increment(g).add(h);</span><br><span class="line">    j.output();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$3.05 + -$2.25 &#x3D; -$5.30</span><br><span class="line">$11.75</span><br><span class="line">$11.75</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 语言特性 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 类 </tag>
            
            <tag> 重载 </tag>
            
            <tag> 引用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6 类与继承</title>
      <link href="/2020/03/19/ES6%E7%B1%BB%E4%B8%8E%E7%BB%A7%E6%89%BF/"/>
      <url>/2020/03/19/ES6%E7%B1%BB%E4%B8%8E%E7%BB%A7%E6%89%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="对-js-生成实例传统方法的控诉"><a class="markdownIt-Anchor" href="#对-js-生成实例传统方法的控诉"></a> 对 JS 生成实例传统方法的控诉</h1><hr /><p>你可能已经知道了，一个 <code>JavaScript</code> 开发者想要创建一个实例，需要组合使用 <code>构造函数模式</code> 和 <code>原型模式</code>。比如这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>._name = name;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"My name is "</span> + <span class="keyword">this</span>._name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"Spike"</span>);</span><br></pre></td></tr></table></figure><p>你可能在各种书籍或者文章里看到了这种写法的好处。比如避免引用类型被到处修改，比如所有实例共享方法。但有一说一，这种写法和传统的面向对象语言的写法实在是相差太大了。</p><p>所以，<code>ES6</code> 妥协了。</p><p>虽然只是语法糖。你在 <code>ES6</code> 下做的事情，<code>ES5</code> 同样可以做到。但架不住 <code>ES6</code> 好读啊。</p><a id="more"></a><h1 id="es6-的类的概述"><a class="markdownIt-Anchor" href="#es6-的类的概述"></a> ES6 的类的概述</h1><hr /><p>我们可以将上面的代码改写为 <code>ES6</code> 的写法。你要注意，这种写法不存在变量提升。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 构造方法</span></span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>._name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  sayName() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"My name is "</span> + <span class="keyword">this</span>._name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> Person(<span class="string">"Spike"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person1.sayName());</span><br></pre></td></tr></table></figure><p>你要注意，除非属性都定义在 <code>this</code> 对象，也就是实例本身上，否则他们都将被定义在原型上。</p><h2 id="getter-与-setter"><a class="markdownIt-Anchor" href="#getter-与-setter"></a> <code>Getter</code> 与 <code>Setter</code></h2><p>你还可以设置 <code>getter</code> 和 <code>setter</code> 函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>._name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> name() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"My name is "</span> + <span class="keyword">this</span>._name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> name(newName) &#123;</span><br><span class="line">    <span class="keyword">this</span>._name = <span class="string">"Mr."</span> + newName;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> Person(<span class="string">"Spike"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person1.name); <span class="comment">// My name is Spike</span></span><br><span class="line">person1.name = <span class="string">"Hesea"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person1.name); <span class="comment">// My name is Mr.Hesea</span></span><br></pre></td></tr></table></figure><h2 id="静态方法"><a class="markdownIt-Anchor" href="#静态方法"></a> 静态方法</h2><p>另外的，你也可以设置静态方法。所谓静态方法，就是不会被实例继承，而是直接通过类来调用。父类的静态方法是可以被子类继承的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> sayHello() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello World"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Person.sayHello()); <span class="comment">// Hello World</span></span><br></pre></td></tr></table></figure><h2 id="静态属性"><a class="markdownIt-Anchor" href="#静态属性"></a> 静态属性</h2><p>在 <code>ES6</code> 中，<code>Class</code> 内部只有静态方法，没有静态属性。但是你可以这样定义一个静态属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;&#125;</span><br><span class="line">Person.name = <span class="string">"Spike"</span>;</span><br></pre></td></tr></table></figure><h2 id="判断-new-调用的函数"><a class="markdownIt-Anchor" href="#判断-new-调用的函数"></a> 判断 <code>new</code> 调用的函数</h2><p>在 <code>ES6</code> 中，引入了一个 <code>new.target</code> 属性。该属性一般用于构造函数中，返回 <code>new</code> 命令作用的函数。如果构造函数不是通过 <code>new</code> 命令或 <code>Reflect.construct()</code> 调用的，那么就会返回 <code>undefined</code> 。</p><p>你可以基于这个属性来提示用户正确的创建实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">new</span>.target === Person) &#123;</span><br><span class="line">      <span class="keyword">this</span>._name = name;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"必须使用 new 命令生成实例"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="类的继承"><a class="markdownIt-Anchor" href="#类的继承"></a> 类的继承</h1><hr /><p>在 <code>ES6</code> 中，我们可以通过 <code>extends</code> 关键字来实现继承。这比以前使用 <code>ES5</code> 修改原型链实现继承要容易多了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>._name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Me</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name, age) &#123;</span><br><span class="line">    <span class="keyword">super</span>(name);</span><br><span class="line">    <span class="keyword">this</span>._age = age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  sayHi() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`My name is <span class="subst">$&#123;<span class="keyword">this</span>._name&#125;</span>, and i am <span class="subst">$&#123;<span class="keyword">this</span>._age&#125;</span> years old`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> me = <span class="keyword">new</span> Me(<span class="string">"Spike"</span>, <span class="number">24</span>);</span><br><span class="line">me.sayHi(); <span class="comment">// My name is Spike, and i am 24 years old</span></span><br></pre></td></tr></table></figure><p>你要注意的是，必须在子类的 <code>constructor</code> 方法中调用 <code>super</code> 方法，才能使用 <code>this</code> 对象。这是因为子类自己的 <code>this</code> 对象必须先通过父类的构造函数完成塑造，得到与父类相同的实例属性和方法，然后才能再加上子类自己的实例属性和方法。</p><p>你可以从判断子类继承了哪一个父类</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getPrototypeOf(Person) === Me;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 语言特性 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
            <tag> 类 </tag>
            
            <tag> 继承 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript的面向对象（三）——谈谈对象的继承</title>
      <link href="/2020/03/18/JavaScript%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BB%A7%E6%89%BF/"/>
      <url>/2020/03/18/JavaScript%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BB%A7%E6%89%BF/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在阅读这篇文章之前，你应该非常熟悉原型与原型链了。如果不是的话，推荐你阅读 <a href="https://github.com/mqyqingfeng/Blog/issues/2" target="_blank" rel="noopener">这篇文章</a></p></blockquote><h1 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h1><hr /><p>很多面向对象语言都支持两种继承方式：</p><ul><li>接口继承：继承方法签名</li><li>实现继承：继承实际的方法</li></ul><p>在 <code>JavaScript</code> 中，函数没有签名，所以只支持实现继承。很自然的，继承主要依靠的就是原型链来继承的。</p><a id="more"></a><h1 id="原型链"><a class="markdownIt-Anchor" href="#原型链"></a> 原型链</h1><hr /><p>总的来说，这种模式的基本思想是：<strong>利用原型让一个引用类型继承另一个引用类型的属性和方法</strong>。</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.prototype = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.prototype;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.subprototype = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 继承</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line">SubType.prototype.getSubValue = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.subproperty;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType();</span><br><span class="line"><span class="built_in">console</span>.log(instance.getSuperValue()); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>你可以看到，我们实际上是让一个构造函数的 <code>prototype</code> 指向了父原型的实例。</p><p>为了理解这样做的原因，你可以回忆一下原型、构造函数和实例之间的关系。众所周知的是，一个构造函数的 <code>prototype</code> 指向了它的原型。使用这个构造函数创建出来的实例也有一个 <code>__proto__</code> 属性指向了那个原型。</p><p>所以，我们使用父级原型的构造函数创建一个实例。这个实例将会有一个 <code>__proto__</code> 属性指向父级原型。</p><p>当我们将子构造函数的 <code>prototype</code> 指向了父级构造函数创建出来的实例之后，你会发现。子实例有一个 <code>__proto__</code> 指向了父实例，而父实例又有一个 <code>__proto__</code> 指向了父级原型。</p><p>这就是所谓的原型链。</p><p>总的来说，我们并没有使用 <code>SubType</code> 默认提供的原型，而是将其替换成了 <code>SuperType</code> 的实例。于是，新原型不仅具有作为一个 <code>SuperType</code> 的实例所拥有的的所有属性和方法。其内部还有一个指针 <code>__proto__</code> ，指向了 <code>SuperType</code> 的原型。事实上，我们通过这个写法，扩大了原型搜索范围。</p><h2 id="默认原型"><a class="markdownIt-Anchor" href="#默认原型"></a> 默认原型</h2><p>你要记得，所有函数的默认原型都是 <code>Object</code> 的实例。因此默认原型也将有一个内部指针，指向 <code>Object.prototype</code> 。所以你会发现自定义的类型也能使用 <code>toString()</code> 或 <code>valueOf()</code> 等方法。</p><h2 id="确认实例的原型"><a class="markdownIt-Anchor" href="#确认实例的原型"></a> 确认实例的原型</h2><p>是可以使用 <code>instanceof</code> 或是 <code>isPrototypeOf()</code> 方法来确定原型和实例之间的关系。使用方法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 因为原型链的关系，所以都会返回 true</span></span><br><span class="line">instance <span class="keyword">instanceof</span> <span class="built_in">Object</span><span class="comment">// true</span></span><br><span class="line">instance <span class="keyword">instanceof</span> SuperType<span class="comment">// true</span></span><br><span class="line">instance <span class="keyword">instanceof</span> SubType<span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 只要是原型中出现的原型，都可以说是该原型链所派生的实例的原型</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.isPrototypeOf(instance)<span class="literal">true</span></span><br><span class="line">SuperType.prototype.isPrototypeOf(instance)<span class="comment">// true</span></span><br><span class="line">SubType.prototype.isPrototypeOf(instance)<span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="注意点和原型链的缺陷"><a class="markdownIt-Anchor" href="#注意点和原型链的缺陷"></a> 注意点和原型链的缺陷</h2><p>你得先改写子类的原型，再在子类型中添加方法，或是覆写超类型中的方法。同时注意不要使用字面量写法来添加或覆写方法，这样做的话会重写原型链。这在 <code>JavaScript</code> 的面向对象系列的第二部分中已经多次强调了。</p><p>原型链的缺陷实际上还是由引用类型造成的。因为我们实际上是使用超类型的实例来充当子类型的原型的，所以这一堆实例中的引用对象是共享的。这就会导致一处改动处处变化的问题。</p><p>另外的，你在创建子类型的实例时，也不能在不影响所有对象实例的情况下，给超类型的构造函数传递参数。</p><p>基于这些问题，事实上 <code>原型链</code> 的继承模式也就图一乐。</p><h1 id="借用构造函数"><a class="markdownIt-Anchor" href="#借用构造函数"></a> 借用构造函数</h1><hr /><p>这种方式说白了就是在子类型的构造函数内部调用超类型的构造函数，借助<code>.call</code> 或是 <code>.apply</code> 来修改作用域为子类型构造函数的作用域。同时因为使用了这俩方法来调用函数，所以我们可以往超类型的构造函数中传递参数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  SuperType.call(<span class="keyword">this</span>, <span class="string">"Spike"</span>);</span><br><span class="line">  <span class="keyword">this</span>.age = <span class="number">24</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType();</span><br><span class="line"><span class="built_in">console</span>.log(instance.name); <span class="comment">// Spike</span></span><br><span class="line"><span class="built_in">console</span>.log(instance.age); <span class="comment">// 24</span></span><br></pre></td></tr></table></figure><p>这种方法的好处你也看到了，可以向父类型构造函数中传递参数。</p><p>当然缺陷也很明显，构造函数的一大问题就是不共享对象的方法，每个方法实际上都生成了一个 <code>function</code> 实例。所以其实这种方法也就是图一乐。</p><h1 id="组合继承"><a class="markdownIt-Anchor" href="#组合继承"></a> 组合继承</h1><hr /><p>既然原型链会导致引用类型数据的共享问题，既然借用构造函数会导致方法不可复用的问题。那么将他俩组合起来就 <code>vans</code> 了。</p><p>这里有一个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"My name is "</span> + <span class="keyword">this</span>.name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承属性</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  SuperType.call(<span class="keyword">this</span>, name);</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 继承方法</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line">SubType.prototype.constructor = SubType;</span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"My age is "</span> + <span class="keyword">this</span>.age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType(<span class="string">"Spike"</span>, <span class="number">24</span>);</span><br><span class="line">instance.sayName();</span><br><span class="line">instance.sayAge();</span><br></pre></td></tr></table></figure><h1 id="原型式继承"><a class="markdownIt-Anchor" href="#原型式继承"></a> 原型式继承</h1><hr /><p>就代码写法上来说，其实是封装了一下原型链的思路。借助原型我们可以基于已有的对象创建新对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  F.prototype = o;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以看到，<code>F.prototype = o</code> 这句代码，实际上就是对 <code>o</code> 进行了一次浅复制。</p><p>在 <code>ES5</code> 中，给出了一个规范化的方法来实现原型式继承：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Person = &#123;</span><br><span class="line">  name: <span class="string">"Spike"</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> anotherPerson = <span class="built_in">Object</span>.create(person, &#123;</span><br><span class="line">  name: &#123;</span><br><span class="line">    value: <span class="string">"Hesea"</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(anotherPerson.name); <span class="comment">// Hesea</span></span><br></pre></td></tr></table></figure><h1 id="寄生式继承"><a class="markdownIt-Anchor" href="#寄生式继承"></a> 寄生式继承</h1><hr /><p>实际上就是增强一些对象的。思路上和寄生构造函数一样。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnother</span>(<span class="params">original</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> clone = object(original);</span><br><span class="line">  clone.sayHi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hi"</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> clone;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">"Spike"</span>,</span><br><span class="line">  age: <span class="number">24</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> anotherPerson = createAnother(person);</span><br><span class="line">anotherPerson.sayHi(); <span class="comment">// Hi</span></span><br></pre></td></tr></table></figure><p>当然你并不一定要使用 <code>object</code> 来创建对象。只要函数能返回新对象就。这本质上还是对原有对象的重新封装。</p><h1 id="寄生组合式继承"><a class="markdownIt-Anchor" href="#寄生组合式继承"></a> 寄生组合式继承</h1><hr /><p>尽管大家偏爱使用 <code>组合继承</code>。但你不得不承认，在为子类型绑定原型以及子类型的构造函数中，都分别调用了一次超类型的构造函数。这就意味着实际上子类型虽然的确拥有超类型的属性，但我们重复的覆写了它们。这根本没这个必要。</p><p>在为子类型指定原型的时候，根本就没必要调用构造函数。我们完全可以使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">subType, superType</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> clone = object(superType.prototype);</span><br><span class="line">  clone.constructor = subType;</span><br><span class="line">  subType.prototype = clone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，你就可以这样使用 <code>寄生组合式继承</code> 了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line">Super.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'My name is '</span> + <span class="keyword">this</span>.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  SuperType.call(<span class="keyword">this</span>, name)</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inheritPrototype(SubType, SuperType)</span><br><span class="line"><span class="comment">// 为子类型添加新方法</span></span><br><span class="line">SubType.prototype.sayAge = fucntion() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'My age is '</span> + <span class="keyword">this</span>.age</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 语言特性 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 继承 </tag>
            
            <tag> 面向对象 </tag>
            
            <tag> 对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript的面向对象（二）——谈谈对象的创建</title>
      <link href="/2020/03/17/JavaScript%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA/"/>
      <url>/2020/03/17/JavaScript%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<blockquote><p>如果你对 <code>JavaScript</code> 那奇特的对象还不甚了解的话，推荐你读一下 <a href="%5Bhttps://www.bebopser.com/2020/03/17/JavaScript%E7%9A%84%E5%AF%B9%E8%B1%A1/%5D(https://www.bebopser.com/2020/03/17/JavaScript%E7%9A%84%E5%AF%B9%E8%B1%A1/)">这篇文章</a>。</p></blockquote><p>事实上，在第一部分里的字面量写法就是一种创建单个对象的方式。但这种写法意味着你无法封装创建对象的逻辑，会有很多的重复代码出现。为了解决这个问题，我们提出了 <code>工厂模式</code> 来创建对象。</p><h1 id="工厂模式"><a class="markdownIt-Anchor" href="#工厂模式"></a> 工厂模式</h1><hr /><p>简单来说，就是使用函数来封装创建对象的细节，比如有以下 <code>工厂函数</code> ：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">  p.name = name;</span><br><span class="line">  o.age = age;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = createPerson(<span class="string">"Spike"</span>, <span class="number">24</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = createPerson(<span class="string">"Hesea"</span>, <span class="number">26</span>);</span><br></pre></td></tr></table></figure><p>尽管这个模式可以解决重复创建对象所带来的的重复代码的问题，但你并不能知道由此创建出来的对象类型。所以我们就得借助一种常用的模式——<code>构造函数模式</code></p><a id="more"></a><h1 id="构造函数模式"><a class="markdownIt-Anchor" href="#构造函数模式"></a> 构造函数模式</h1><hr /><p>其实就像是 <code>Obejct</code> 或是 <code>Array</code> 的构造函数一样，不过这里的是自定义的。比如将上面的工厂模式改写为以下 <code>构造函数模式</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">  <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"My name is "</span> + <span class="keyword">this</span>.name || <span class="literal">undefined</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"Spike"</span>, <span class="number">24</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"Hesea"</span>, <span class="number">26</span>);</span><br></pre></td></tr></table></figure><p>使用大写字母开头的单词来做函数签名是约定俗成的。另外的，你必须使用 <code>new</code> 操作符来调用构造函数。在创建对象期间，将会经历以下几个步骤：</p><ul><li>创建一个空的新对象</li><li>将构造函数的作用域赋给此对象</li><li>执行构造函数中的代码</li><li>返回新对象</li></ul><p>事实上，这在 <a href="%5Bhttps://www.bebopser.com/2020/03/11/JavaScript%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84-this%5D(https://www.bebopser.com/2020/03/11/JavaScript%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84-this)">构造函数执行上下文</a> 中相关的章节就分析过了，不过那篇文章是从 <code>this</code> 的角度分析的。</p><p>使用这个模式构造对象，意味着你可以检测对象类型了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">person1.constructor == Person; <span class="comment">// true</span></span><br><span class="line">person1.__proto__ == Person.prototype; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">person1 <span class="keyword">instanceof</span> Person; <span class="comment">// true</span></span><br><span class="line">person1 <span class="keyword">instanceof</span> Project; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="构造函数模式的问题"><a class="markdownIt-Anchor" href="#构造函数模式的问题"></a> 构造函数模式的问题</h2><p>事实上，通过这种方式创建的对象之间，是不共享对象中的方法的。换句话说，不同实例上的同名方法是不相同的。它们使用不同的作用域链和标识符解析。你尽可以将方法的定义移动到构造函数之外进行，但这样就毫无封装性可言了。</p><h1 id="原型模式"><a class="markdownIt-Anchor" href="#原型模式"></a> 原型模式</h1><hr /><blockquote><p>在阅读这一部分前，你应当已经完全理解了 <code>JavaScript</code> 的原型链相关的内容。如果不是的话，请阅读 <a href="https://github.com/mqyqingfeng/Blog/issues/2" target="_blank" rel="noopener">这篇文章</a>。</p></blockquote><p>我们知道，构造函数拥有 <code>prototype</code> 属性，指向通过此构造函数创建的对象实例的原型对象。而这个原型对象中包含的属性和方法可以被所有实例所共享。这就给了我们一个思路，我们可以将实例和方法定义到原型对象中。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">  <span class="keyword">constructor</span>: Person,</span><br><span class="line">  name: "Spike",</span><br><span class="line">  age: 24,</span><br><span class="line">  sayName: function () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"My name is "</span> + <span class="keyword">this</span>.name || <span class="literal">undefined</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line">person1.sayName(); <span class="comment">// My name is Spike</span></span><br></pre></td></tr></table></figure><p>这种写法实际上是重写了 <code>prototype</code> 对象。这意味着，<code>constructor</code> 对象将会变成新对象的 <code>constructor</code> 。你可以使用 <code>constructor</code> 属性来重新绑定。或者是将其写开：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.name = <span class="string">"Spike"</span>;</span><br><span class="line">Person.prototype.age = <span class="number">24</span>;</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"My name is "</span> + <span class="keyword">this</span>.name || <span class="literal">undefined</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>不过你不能重写原型中的属性值，你只能在实例上重新定义，从而覆写原型中的属性值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">person1.name = <span class="string">"Hesea"</span>;</span><br></pre></td></tr></table></figure><p>如果你后悔了，可以使用 <code>delete</code> 方法来删除实例属性，这样就又可以访问原型中的值了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> person1.name;</span><br></pre></td></tr></table></figure><p>另外还有两个方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回实例的 [[Prototype]]，即 __proto__</span></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeof(person1) == Person.prototype;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检测对象中是否含有某属性</span></span><br><span class="line"><span class="comment">// 这个可以用来鉴定属性是否存在于实例中的</span></span><br><span class="line"><span class="comment">// 从原型中继承下来的属性将会返回 false</span></span><br><span class="line">person1.hasOwnProperty(<span class="string">"name"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面的方法可以配合 in 操作符</span></span><br><span class="line"><span class="comment">// 只要能访问到某个属性， in 操作符就会返回 true</span></span><br><span class="line"><span class="comment">// 如果上面返回 false，而 in 返回 true。那么属性一定存在于原型中</span></span><br><span class="line">name <span class="keyword">in</span> Person;</span><br></pre></td></tr></table></figure><h2 id="原型的动态性"><a class="markdownIt-Anchor" href="#原型的动态性"></a> 原型的动态性</h2><p>事实上，基于原型的动态性，你可以随时修改原型中的属性。即使是在创建了实例之后。因为实例的 <code>__proto__</code> 属性不过是一个指针，而非副本。所以 <code>JavaScript</code> 就可以顺着原型链来寻找某个方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line">Person.name = <span class="string">"Hesea"</span>;</span><br></pre></td></tr></table></figure><p>但是你需要注意的是，千万不要使用 <code>Person.prototype = {}</code> 这样的语法来重写原型。因为这会切断实例与原型的联系。</p><p>换句话说，实例的 <code>__proto__</code> 指向的还是原先的原型。而由于你重新定义了整个 <code>Person.prototype</code> 属性，所以实际上 <code>Person</code> 构造函数的 <code>prototype</code> 已经指向了新的对象。者会造成标识符解析错误。</p><h2 id="原型模式的问题和解决方法"><a class="markdownIt-Anchor" href="#原型模式的问题和解决方法"></a> 原型模式的问题和解决方法</h2><p>事实上，这样的做法下，实例们会共享一组属性。但如果共享的是引用类型值的话，那么就会导致引用类型的值被导出修改。如果要理解这个结果，你应该想起 <code>JavaScript</code> 的引用类型实际上是指针指向了一组数据。</p><p>事实上，组合使用 <code>构造函数模式</code> 和 <code>原型模式</code> 就行了。</p><p>构造函数模式用来产出实例的属性，然后将方法定义在原型上，以便于所有的实例共享。这样就即节省了内存，害避免了两种模式的缺陷：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name || <span class="string">"Spike"</span>;</span><br><span class="line">  <span class="keyword">this</span>.age = age || <span class="number">24</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">  <span class="keyword">constructor</span>: Person,</span><br><span class="line">  sayName: function () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"My name is "</span> + <span class="keyword">this</span>.name;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>事实上，这种方法也是被广为接受的。</p><h1 id="动态原型模式"><a class="markdownIt-Anchor" href="#动态原型模式"></a> 动态原型模式</h1><hr /><p>事实上，这是对上面组合使用 <code>构造函数模式</code> 和 <code>原型模式</code> 的一种补充。简而言之就是将对原型的修改封装到构造函数之中了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name || <span class="string">"Spike"</span>;</span><br><span class="line">  <span class="keyword">this</span>.age = age || <span class="number">24</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>.sayName != <span class="string">"function"</span>) &#123;</span><br><span class="line">    Person.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"My name is "</span> + <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然了，从理论上来说，这实际上其实还是组合的使用了 <code>构造函数模式</code> 和 <code>原型模式</code>。所以你不能使用字面量写法来重写 <code>Person.prototype</code> 。原因和上面是一样的。</p><h1 id="寄生构造函数模式"><a class="markdownIt-Anchor" href="#寄生构造函数模式"></a> 寄生构造函数模式</h1><hr /><p>其基本思想是封装创建对象时的代码。主要作用其实还是重写一些原生对象，为其赋予新的能力。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SpecialArray</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> values = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"></span><br><span class="line">  values.push.apply(values, <span class="built_in">arguments</span>);</span><br><span class="line">  values.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.join(<span class="string">"~"</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> values;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> SpecialArray(<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(colors.toString()); <span class="comment">// red~blue~green</span></span><br></pre></td></tr></table></figure><p>不过在这种模式下，返回的对象与构造函数或者是构造函数的原型没啥关系，所以其实你也不能使用 <code>instanceof</code> 来确定对象类型。不过如果只是修改一下原生对象的话，其实也没什么大不了的。</p><blockquote><p>这里就体现出了 Python 里鸭子协议的好处了……</p></blockquote><h1 id="稳妥构造模式"><a class="markdownIt-Anchor" href="#稳妥构造模式"></a> 稳妥构造模式</h1><hr /><p>所谓稳妥对象，指的是没有公共属性，其方法也不引用 <code>this</code> 对象。这可以在一些安全环境中使用，因为在那里禁用 <code>new</code> 和 <code>this</code> 。（虽然我还没实际使用过）</p><p>例如你可以将前面的函数改写如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">  o.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"My name is "</span> + name;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">person1 = Person(<span class="string">"Spike"</span>, <span class="number">24</span>);</span><br><span class="line">person1.sayName(); <span class="comment">// My name is Spike</span></span><br></pre></td></tr></table></figure><p>不过这种模式也有和 <code>寄生构造函数模式</code> 相同的问题。所以就不重复了。</p><p>在某些安全环境，诸如 <code>ADsafe</code> 和 <code>Caja</code> 等下，会有用处。这些环境可以防止恶意代码的破坏</p>]]></content>
      
      
      <categories>
          
          <category> 语言特性 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面向对象 </tag>
            
            <tag> 对象 </tag>
            
            <tag> 创建对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript的面向对象（一）——先说说对象</title>
      <link href="/2020/03/17/JavaScript%E7%9A%84%E5%AF%B9%E8%B1%A1/"/>
      <url>/2020/03/17/JavaScript%E7%9A%84%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h1><hr /><p>对于面向对象的语言来说，定义一个类，并且基于这个类创建一个实例。这种做法对于 <code>Python</code> 程序员来说已经是司空见惯的事情了。但是在 <code>ES6</code> 之前，<code>JavaScript</code> 是没有类这个概念的。也因为这个关系，<code>JavaScript</code> 中对象的概念也和其他语言中的不太像。</p><p>根据 <code>ECMA-262</code> 的定义，对象是：<strong>无序属性的集合，其属性可以包含基本值、对象或者函数</strong>。</p><p>事实上，你可以将其理解为散列表。</p><p>另一方面，也由于 <code>类</code> 这个概念的缺失，所以如果一个 <code>JavaScript</code> 程序员需要创建一个实例对象，那么他就不得不求助于构造函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Point</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.x = x;</span><br><span class="line">  <span class="keyword">this</span>.y = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Point(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// Point &#123; x: 1, y: 2&#125;</span></span><br></pre></td></tr></table></figure><p>这种写法会让其他传统面向对象语言的程序员感到困惑。幸运的是，这个问题在 <code>ES6</code> 中已经解决了，不过这部分内容放在新的文章中介绍。</p><a id="more"></a><h1 id="对象与对象的属性"><a class="markdownIt-Anchor" href="#对象与对象的属性"></a> 对象与对象的属性</h1><hr /><p>在 <code>JavaScript</code> 中，我们经常使用 <code>对象字面量</code> 来创建对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Person = &#123;</span><br><span class="line">  name: <span class="string">"Spike"</span>,</span><br><span class="line">  age: <span class="number">24</span>,</span><br><span class="line">  job: <span class="string">"Web Engineer"</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>JavaScript</code> 为这些属性设计了一组特征值，用来定义它们的行为。这些特征值属于 <code>JavaScript</code> 内部的特性，所以你无法访问它们。但是你可以使用 <code>Object.defineProperty()</code> 方法来设定它们。为了表示它们是内部值，所以将用方括号来包裹它们。</p><p>关于特征值，其实你也可以理解为低配版的 <code>Python</code> 中的魔术方法所扮演的角色。尽管后者的功能要强大许多。（我没有黑 <code>JavaScript</code></p><p>在 <code>JavaScript</code> 中，有两种属性：<strong>数据属性</strong>和<strong>访问器属性</strong>。</p><h2 id="数据属性"><a class="markdownIt-Anchor" href="#数据属性"></a> 数据属性</h2><p>数据属性包含一个数据值的位置，你可以在这个位置读取或者写入值。在 <code>JavaScript</code> 内部，为数据属性定义了 4 个特征值，用于描述 <code>数据属性</code> 的行为：</p><ul><li><code>[[Configurable]]</code>：表示能否通过 <code>delete</code> 删除属性，能否修改属性的特性，能否将属性修改为 <code>访问器属性</code> 。默认值为 <code>true</code></li><li><code>[[Enumerable]]</code>：表示能否通过 <code>for-in</code> 循环遍历属性。默认值为 <code>true</code></li><li><code>[[Writable]]</code>：表示能否修改属性的值。默认值为 <code>true</code></li><li><code>[[Value]]</code>：存储该属性的数据值。默认值为 <code>undefined</code></li></ul><p>如果你想要修改这些默认的属性特性，那么你就得借助于 <code>Object.defineProperty()</code> 方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// obj 需要定义属性的当前对象</span></span><br><span class="line"><span class="comment">// prop 当前需要定义的属性名</span></span><br><span class="line"><span class="comment">// desc 属性描述符</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.definedProperty(obj, prop, desc);</span><br></pre></td></tr></table></figure><p>例如，我们定义一个不可改写的属性：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Person = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(Person, <span class="string">"name"</span>, &#123;</span><br><span class="line">  value: <span class="string">"Spike"</span>,</span><br><span class="line">  writable: <span class="literal">false</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Person.name = <span class="string">"Hesea"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(Person.name); <span class="comment">// Spike</span></span><br></pre></td></tr></table></figure><p>你要注意的是，对 <code>[[Configurable]]</code> 属性的修改是一次性的。比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Person = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(Person, <span class="string">"name"</span>, &#123;</span><br><span class="line">  value: <span class="string">"Spike"</span>,</span><br><span class="line">  configurable: <span class="literal">false</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(Person, <span class="string">"name"</span>, &#123;</span><br><span class="line">  value: <span class="string">"Spike"</span>,</span><br><span class="line">  configurable: <span class="literal">true</span>,</span><br><span class="line">&#125;); <span class="comment">// TypeError: Cannot redefine property: name</span></span><br></pre></td></tr></table></figure><h2 id="访问器属性"><a class="markdownIt-Anchor" href="#访问器属性"></a> 访问器属性</h2><p>访问器属性不包含数据值，而是包含一对 <code>getter</code> 和 <code>setter</code> 函数。尽管这不是必须的：</p><ul><li><code>[[Configurable]]</code>：表示能否通过 <code>delete</code> 删除属性，能否修改属性的特性，能否将属性修改为 <code>数据属性</code> 。默认值为 <code>true</code></li><li><code>[[Enumerable]]</code>：表示能否通过 <code>for-in</code> 遍历属性。默认值为 <code>true</code></li><li><code>[[Get]]</code>：在读取属性时调用的函数。默认值为 <code>undefined</code></li><li><code>[[Set]]</code>：在写入属性时调用的函数。默认值为 <code>undefined</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  _name: <span class="string">"Spike"</span>,</span><br><span class="line">  _age: <span class="number">24</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">"name"</span>, &#123;</span><br><span class="line">  <span class="keyword">get</span>: function () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"My name is "</span> + <span class="keyword">this</span>._name;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span>: function (newName) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"The name has changed."</span>);</span><br><span class="line">    <span class="keyword">this</span>._name = newName;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">// My name is Spike</span></span><br><span class="line">person.name = <span class="string">"Hesea"</span>; <span class="comment">// The name has changed.</span></span><br><span class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">// My name is Hesea</span></span><br></pre></td></tr></table></figure><h1 id="定义属性与读取属性特性"><a class="markdownIt-Anchor" href="#定义属性与读取属性特性"></a> 定义属性与读取属性特性</h1><hr /><h2 id="定义多个属性"><a class="markdownIt-Anchor" href="#定义多个属性"></a> 定义多个属性</h2><p>你可以看到，前面我们使用了 <code>Object.defineProperty()</code> 函数来单一的定义属性。实际开发中，我们可能一次性的定义许多值，为了方便，所以 <code>ES5</code> 定义了一个新的函数来定义多组值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// obj 需要定义属性的当前对象</span></span><br><span class="line"><span class="comment">// prop 当前需要定义的属性名</span></span><br><span class="line"><span class="comment">// desc 属性描述符</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperties(obj, &#123; <span class="attr">prop</span>: desc &#125;);</span><br></pre></td></tr></table></figure><p>你可以这样使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperties(person, &#123;</span><br><span class="line">  _name: &#123;</span><br><span class="line">    value: <span class="string">"Spike"</span>,</span><br><span class="line">    writable: <span class="literal">false</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  age: &#123;</span><br><span class="line">    value: <span class="number">24</span>,</span><br><span class="line">    writable: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  name: &#123;</span><br><span class="line">    <span class="keyword">set</span>: function (newName) &#123;</span><br><span class="line">      <span class="keyword">this</span>._name = newName;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">get</span>: function () &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"My name is "</span> + <span class="keyword">this</span>._name;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">// My name is Spike</span></span><br></pre></td></tr></table></figure><h2 id="读取属性的特性"><a class="markdownIt-Anchor" href="#读取属性的特性"></a> 读取属性的特性</h2><p>你可以使用 <code>Object.getOwnPropertyDescriptor()</code> 函数来读取一个属性的描述符。比如你可以这样来使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(person, <span class="string">"name"</span>));</span><br><span class="line"><span class="comment">// &#123; get: [Function: get],</span></span><br><span class="line"><span class="comment">//   set: [Function: set],</span></span><br><span class="line"><span class="comment">//   enumerable: false,</span></span><br><span class="line"><span class="comment">//   configurable: false &#125;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 语言特性 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面向对象 </tag>
            
            <tag> 对象 </tag>
            
            <tag> 属性 </tag>
            
            <tag> 访问器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分析我网站遭受的攻击（翻译）</title>
      <link href="/2020/03/15/%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB%E5%88%86%E6%9E%90/"/>
      <url>/2020/03/15/%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<blockquote><p>原文：<a href="https://dev.to/pluralsight/analyzing-the-attacks-on-my-website-30jf" target="_blank" rel="noopener">https://dev.to/pluralsight/analyzing-the-attacks-on-my-website-30jf</a></p></blockquote><p>我最近很偶然的对我的 blog 做了一次安全审计，并决定深入的查看一下安全日志。通过一些 Linux 命令行指令，一些 <code>Golang</code> ，还有谷歌表格，我可以很清楚的知道攻击都来自哪里。</p><p>首先，我使用 <code>CentOS</code> 运行我的网站，所以我检查了 <code>/var/log/secure</code> 目录。这个日志存储的是我服务器上的身份验证日志。</p><p>这是日志文件的样子：</p><p><img src="https://bebopfzj.oss-cn-hangzhou.aliyuncs.com/uPic/2020-03-15-efyVKT.jpg" alt="身份验证日志文件" /></p><p>有 <strong>301,327</strong> 行，我不可能逐行手动查看。所以让我们自动化处理一下。</p><h1 id="获得攻击者的-ip-地址"><a class="markdownIt-Anchor" href="#获得攻击者的-ip-地址"></a> 获得攻击者的 IP 地址</h1><hr /><p>我想要从这个文件里提取出攻击者的 <code>IP</code> 地址。这样我就能屏蔽他们。</p><p>我开始胡乱的使用 <code>Linux</code> 指令，直到我折腾出了<a href="https://gist.github.com/JeremyMorgan/94af88899785ea725a55a382f3fd209b" target="_blank" rel="noopener">这个脚本</a>。</p><p>脚本做的事情很简单，就是去寻找这些字符串：</p><a id="more"></a><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">declare</span> -a badstring = (<span class="string">"Failed password for invalid user"</span></span><br><span class="line"><span class="string">"input_userauth_request: invalid user"</span></span><br><span class="line"><span class="string">"pam_unix(sshd:auth): check pass; user unknown"</span></span><br><span class="line"><span class="string">"input_userauth_request: invalid user"</span></span><br><span class="line"><span class="string">"does not map back to the adress"</span></span><br><span class="line"><span class="string">"pam_unix(sshd:auth): authentication failure"</span></span><br><span class="line"><span class="string">"input_userauth_request: invalid user"</span></span><br><span class="line"><span class="string">"reverse mapping checking getaddrinfo for"</span></span><br><span class="line"><span class="string">"input_userauth_request: invalid user"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>日志里的这些字符串标识出了失败的攻击。如果他们输入了错误的用户名或尝试了其他的种类的攻击，就会有这些字符串中的一条。</p><p>所以我们遍历列表，然后寻找这些字符串，然后从存在这些字符串的行中提取出 <code>IP</code> 地址。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /var/<span class="built_in">log</span>/secure | grep <span class="string">"<span class="variable">$i</span>"</span> | grep -E -o <span class="string">"([0-9]&#123;1,3&#125;[\.])&#123;3&#125;[0-9]&#123;1,3&#125;"</span> | awk <span class="string">'&#123;print $0&#125;'</span> | sort | uniq &gt;&gt; <span class="string">"temp.txt"</span></span><br></pre></td></tr></table></figure><p>然后将 <code>IP</code> 写入 <code>temp.txt</code> 文件。这将会处理所有含有我写在 <code>badstring</code> 列表里字符串的消息。</p><p>这个文本文件里有很多重复的 <code>IP</code> ，所以我移除了重复的 <code>IP</code> ，仅将不同的 <code>IP</code> 地址写入其中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># grap unique ips from temp and put the in a file</span></span><br><span class="line">cat <span class="string">"temp.txt"</span> | sort | uniq &gt; <span class="string">"badguyips.txt"</span></span><br><span class="line"><span class="comment"># remove the temp file</span></span><br><span class="line">rm <span class="string">"temp.txt"</span></span><br></pre></td></tr></table></figure><p>牛逼啊，现在我已经有了将要处理的 <code>IP</code> 地址。</p><p><img src="https://bebopfzj.oss-cn-hangzhou.aliyuncs.com/uPic/2020-03-15-kXOTq1.jpg" alt="提取出的ip地址" /></p><p>呀，这里有 <strong>1,141</strong> 个 <code>ip</code> 地址。</p><h1 id="屏蔽它们"><a class="markdownIt-Anchor" href="#屏蔽它们"></a> 屏蔽它们</h1><hr /><p>现在我打算屏蔽这些 <code>IP</code> 地址。因为我运行了 <code>iptables</code> ，所以我只需要使用这个简单的脚本就能处理它们了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">input=<span class="string">"badguyips.txt"</span></span><br><span class="line">white IFS= <span class="built_in">read</span> -r line</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">iptables -A INPUT -s <span class="variable">$line</span> -j DROP</span><br><span class="line"><span class="keyword">done</span> &lt; <span class="string">"<span class="variable">$input</span>"</span></span><br><span class="line"></span><br><span class="line">service iptables save</span><br></pre></td></tr></table></figure><p>牛逼，现在我的服务器已经屏蔽了这些攻击者了。</p><p>然后我有点好奇，这些攻击者都是哪的人呢？</p><h1 id="获取他们的位置数据"><a class="markdownIt-Anchor" href="#获取他们的位置数据"></a> 获取他们的位置数据</h1><hr /><p>因为我已经有了 <code>IP</code> 地址的清单，我想我应该在 <code>Maxmind</code> 这样的数据库上运行它们，以找到一些位置信息。所以我这样做了。</p><p>我写了这个 <code>Golang</code> 程序，叫 <code>find the bad guys</code> 。可以遍历 <code>IP</code> 地址的文本文件，并且寻找他们的位置信息，然后将其写入一系列文本文件。</p><p>地址基于以下几个元素：</p><ul><li>洲</li><li>国家</li><li>城市</li><li>区</li></ul><p>我想要看看这些攻击都来自哪里，并且将信息分享出来。所以我运行了我写的程序，现在我拥有了一些很有用的位置信息清单。</p><p><img src="https://bebopfzj.oss-cn-hangzhou.aliyuncs.com/uPic/2020-03-15-6rhYyg.jpg" alt="位置信息清单" /></p><h1 id="洲"><a class="markdownIt-Anchor" href="#洲"></a> 洲</h1><hr /><p>我以我现在想要看一看 <code>continents.txt</code> 文件。</p><p><img src="https://bebopfzj.oss-cn-hangzhou.aliyuncs.com/uPic/2020-03-15-zCdIP5.jpg" alt="大洲" /></p><p>呃，有个问题，这里有一些重复数据。</p><p>我可以运行一个快速的命令，然后得到一些有用的数据。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat continents | sort | uniq</span><br></pre></td></tr></table></figure><p>如果你之前看过地球仪，那么你就不会对这个结果感到惊讶：</p><p><img src="https://bebopfzj.oss-cn-hangzhou.aliyuncs.com/uPic/2020-03-15-OYj7an.jpg" alt="洲结果" /></p><p>但是我想要知道来自每个大洲的攻击各有多少。所以我找了我的老朋友 <code>uniq</code> 命令去做：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk -F <span class="string">'\n'</span> `&#123;<span class="built_in">print</span> <span class="variable">$0</span>&#125;` continents.txt | sort | uniq -c</span><br></pre></td></tr></table></figure><p><img src="https://bebopfzj.oss-cn-hangzhou.aliyuncs.com/uPic/2020-03-15-MS6X5v.jpg" alt="统计" /></p><p>很有用，对吧？所以我移除了行首的空格，在数字后面插入逗号，并且将其写入一个文本文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk -F `\n` `&#123;<span class="built_in">print</span> <span class="variable">$0</span>&#125;` continents.txt | sort | uniq -c | awk `&#123;<span class="variable">$1</span>=<span class="variable">$1</span>&#125;;1` | sed -r `s/\s+/,/` &gt; contintent-totals.txt</span><br></pre></td></tr></table></figure><p><img src="https://bebopfzj.oss-cn-hangzhou.aliyuncs.com/uPic/2020-03-15-icJtOa.jpg" alt="处理后的文本" /></p><p>所以我可以将其导入到谷歌表格里。</p><p><img src="https://bebopfzj.oss-cn-hangzhou.aliyuncs.com/uPic/2020-03-15-QXSaEz.jpg" alt="谷歌表格" /></p><p>然后就得到了这个漂亮的表格：</p><p><img src="https://bebopfzj.oss-cn-hangzhou.aliyuncs.com/uPic/2020-03-15-xvPzvo.jpg" alt="结果统计" /></p><p>其他的地址信息我也重复了这个过程，所以我不在这里重复了。现在这是我得到的结果：</p><h1 id="国家"><a class="markdownIt-Anchor" href="#国家"></a> 国家</h1><hr /><p><img src="https://bebopfzj.oss-cn-hangzhou.aliyuncs.com/uPic/2020-03-15-Qqk0mM.jpg" alt="国家统计" /></p><p>下面是攻击来源地的前十：</p><ul><li>中国（304）</li><li>美国（138）</li><li>法国（95）</li><li>印度（46）</li><li>新加坡（43）</li><li>韩国（38）</li><li>德国（37）</li><li>俄罗斯（37）</li><li>巴西（35）</li><li>英国（29）</li></ul><h1 id="城市"><a class="markdownIt-Anchor" href="#城市"></a> 城市</h1><hr /><p><img src="https://bebopfzj.oss-cn-hangzhou.aliyuncs.com/uPic/2020-03-15-X8aXBM.jpg" alt="城市统计" /></p><p>每个城市的攻击次数会稍微多一些</p><ul><li>北京（57）</li><li>上海（53）</li><li>合肥（25）</li><li>阿姆斯特丹（21）</li><li>班加罗尔（16）</li><li>伦敦（14）</li><li>新浦（14）</li><li>克里夫顿（10）</li><li>北婆罗洲（9）</li></ul><p>不过会有趣一些。</p><h1 id="区"><a class="markdownIt-Anchor" href="#区"></a> 区</h1><hr /><p><img src="https://bebopfzj.oss-cn-hangzhou.aliyuncs.com/uPic/2020-03-15-s5FxFM.jpg" alt="区分析" /></p><p>这个聚合的更多，不过会更深入一些。以下是排名前十的攻击者：</p><ul><li>北京（145）</li><li>上海（61）</li><li>安徽（26）</li><li>英格兰（22）</li><li>江苏（22）</li><li>新泽西（22）</li><li>北荷兰（22）</li><li>加利福尼亚（18）</li><li>圣保罗（18）</li><li>卡纳塔克邦（16）</li></ul><h1 id="结论"><a class="markdownIt-Anchor" href="#结论"></a> 结论</h1><hr /><p>有趣的发现往往来自于好奇心。我还很好奇我还能从中提取出其他类型的信息，所以我将继续研究和实验它。</p><p>如果你决定为你的网站做这样的分析，可以试试这些步骤，如果你需要帮助，可以 <a href="https://twitter.com/JeremyCMorgan" target="_blank" rel="noopener">联系我</a> （联系原作者！</p><blockquote><p>一个来自于评论区的建议：可以使用 <a href="https://github.com/fail2ban/fail2ban" target="_blank" rel="noopener">fail2ban</a> 来加固你的服务器</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript 闭包行状录——从一道面试题开始说起</title>
      <link href="/2020/03/12/Javascript%E7%9A%84%E9%97%AD%E5%8C%85/"/>
      <url>/2020/03/12/Javascript%E7%9A%84%E9%97%AD%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<p><strong>注意，在阅读这篇文章之前，你应该已经理解了 JavaScript 的 <code>执行上下文</code>、<code>变量对象</code>、<code>作用域链</code> 等概念。如果还有疑问的话，你可以阅读 <a href="%5Bhttps://www.bebopser.com/2020/03/11/JavaScript%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/%5D(https://www.bebopser.com/2020/03/11/JavaScript%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/)">这篇文章</a> 的前三节。另外的，你也应该知道 JavaScript 是词法作用域。</strong></p><blockquote><p>本文的例子来源于 <a href="https://github.com/mqyqingfeng/Blog/issues/8" target="_blank" rel="noopener">这篇文章</a>，而他参考了 <a href="https://github.com/kuitos/kuitos.github.io/issues/18" target="_blank" rel="noopener">这篇文章</a> 。你可以对比着看。</p></blockquote><h1 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h1><hr /><p>总的来说，<code>闭包</code> 是 <code>词法作用域</code> 的体现。你可以通过 <a href="%5Bhttps://www.bebopser.com/2020/03/07/%E9%97%AD%E5%8C%85%E4%B8%8E%E8%A3%85%E9%A5%B0%E5%99%A8/#%E9%97%AD%E5%8C%85%5D(https://www.bebopser.com/2020/03/07/%E9%97%AD%E5%8C%85%E4%B8%8E%E8%A3%85%E9%A5%B0%E5%99%A8/#%E9%97%AD%E5%8C%85)">这篇文章</a> 的第二节来了解其基本用法。在这篇文章章，我们将通过几个例子，来详细分析闭包。</p><p>在阅读完本文章后，你应该能发现，<code>闭包</code> 实际上不是什么新概念，它指的就是函数的 <code>[[scope]]</code> ，即作用域链。**作用域链并不会随着执行上下文从栈从弹出而被销毁。**这就是 <code>闭包</code> 的全部解释了。</p><p>接下来，我们通过一个例子来详细分析一下。</p><a id="more"></a><h1 id="一道面试题"><a class="markdownIt-Anchor" href="#一道面试题"></a> 一道面试题</h1><hr /><p>有以下两个函数，请说出返回值，并简述它们的不同。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> scope = <span class="string">"global scope"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkscope1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> scope = <span class="string">"local scope"</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> scope;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> f();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkscope2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> scope = <span class="string">"local scope"</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> scope;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">checkscope1(); <span class="comment">// local scope</span></span><br><span class="line">checkscope2()(); <span class="comment">// local scope</span></span><br></pre></td></tr></table></figure><p>一言以蔽之：<code>checkscope1</code> 返回的是 <code>f</code> 函数的执行结果，而 <code>checkscope2</code> 返回的是 <code>f</code> 函数的引用。<code>f</code> 函数的 <code>[[scope]]</code> 即作用域链中保存着 <code>checkscope*</code> 函数的活动对象。当 <code>f</code> 函数执行完后，这个作用域链就会被销毁。</p><p>下面我们详细分析一下第二段代码，即 <code>checkscope2()</code> 函数。关于 <code>checkscope1()</code> 函数的分析，你可以在原文中找到。执行过程如下：</p><ol><li><code>JS</code> 引擎执行全局代码，创建全局执行上下文，并将其压入执行上下文栈。然后初始化全局上下文。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ECStack = [</span><br><span class="line">  globalContext</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">globalContext = &#123;</span><br><span class="line">  VO: [global],</span><br><span class="line">  Scope: [globalContext.VO],</span><br><span class="line">  <span class="keyword">this</span>: globalContext.VO</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>创建 <code>checkscope2</code> 函数，并将作用域链保存到函数的 <code>[[scope]]</code> 属性上。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">checkscope2[[scope]] = [globalContext.VO];</span><br></pre></td></tr></table></figure><ol start="3"><li>读到 <code>checkscope2()()</code> 这句代码，开始执行函数。创建函数执行上下文，将其压入执行上下文栈。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ECStack = [checkscope2Context, globalContext];</span><br></pre></td></tr></table></figure><ol start="4"><li>初始化 <code>checkscope2</code> 函数执行上下文。一共包含以下几个步骤<ol><li><strong>复制函数 <code>[[scope]]</code> 属性创建作用域链</strong></li><li>使用 <code>arguments</code> 创建活动对象</li><li>初始化活动对象，即加入形参、函数声明、变量声明等</li><li><strong>将活动对象压入 <code>checkscope2</code> 作用域链顶端</strong></li></ol></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">checkscope2Context = &#123;</span><br><span class="line">  AO: &#123;</span><br><span class="line">    <span class="built_in">arguments</span>: &#123;</span><br><span class="line">      length: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    scope: <span class="literal">undefined</span>,</span><br><span class="line">    f: reference to <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  Scope: [AO, globalContext.VO],</span><br><span class="line">  <span class="keyword">this</span>: <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>创建 <code>f</code> 函数，将作用域链保存到函数的 <code>[[scope]]</code> 属性上。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f.[[scope]] = &#123;</span><br><span class="line">  checkscope2Context.AO,</span><br><span class="line">  globalContext.VO</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li>函数 <code>checkscope2</code> 函数执行完成，其函数执行上下文从执行上下文栈中弹出。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ECStack = [globalContext];</span><br></pre></td></tr></table></figure><ol start="7"><li><p>执行函数 <code>f</code> 。创建函数 <code>f</code> 的执行上下文，将其压入执行上下文栈顶。同时初始化 <code>f</code> 函数的执行上下文。步骤与上面相同，故不细述。</p><p>你需要注意的是，<code>f</code> 函数的执行上下文在初始化时，是在复制自身的 <code>[[scope]]</code> 属性，即第 5 步中创建的内容。然后再将自身的 <code>AO</code> 压入作用域链。</p></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ECStack = [fContext, globalContext];</span><br><span class="line"></span><br><span class="line">fContext = &#123;</span><br><span class="line">  AO: &#123;</span><br><span class="line">    <span class="built_in">arguments</span>: &#123;</span><br><span class="line">      length: <span class="number">0</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  Scope: [AO, checkscope2Context.AO, globalContext.VO],</span><br><span class="line">  <span class="keyword">this</span>: <span class="literal">undefined</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="6"><li><code>f</code> 函数执行 <code>return scope</code> 这句代码。它首先在自身的 <code>AO</code> 中寻找，但并未找到。于是顺着作用域链向上寻找，来到了 <code>checkscope2Context.AO</code> ，找到了变量的值： <code>let scope = &quot;local scope&quot;</code>，即 <code>&quot;local scope&quot;</code>。于是返回。</li></ol><h1 id="结论"><a class="markdownIt-Anchor" href="#结论"></a> 结论</h1><hr /><p>事实上，闭包利用的是 <code>[[scope]]</code> 属性。</p><p><code>[[scope]]</code> 会在函数运行前创建。因为函数可能在各种情况下运行，从而导致 <code>AO</code> 有所不同。所以作用域链会直到函数运行时，才会先复制 <code>[[scope]]</code> 属性，然后再将自身初始化了的 <code>AO</code> 压入。</p><p>而为什么会有这两个阶段？如果你查看一下 <code>AO/VO</code> 的创建过程，就很好理解了。</p><p>对于这样一段代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">"Spike"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>会首先创建变量对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">VO = &#123;</span><br><span class="line">  name: <span class="literal">undefined</span>,</span><br><span class="line">  func: reference to <span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这也就是为什么要分两个阶段的原因了——函数在被定义时的词法作用域不一定与其被调用时的词法作用域相同。</p>]]></content>
      
      
      <categories>
          
          <category> 语言特性 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 变量对象 </tag>
            
            <tag> 作用域链 </tag>
            
            <tag> 闭包 </tag>
            
            <tag> 活动对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7 种你应该知道的 Javascript 原生错误（翻译）</title>
      <link href="/2020/03/11/Javascript%E5%8E%9F%E7%94%9F%E9%94%99%E8%AF%AF/"/>
      <url>/2020/03/11/Javascript%E5%8E%9F%E7%94%9F%E9%94%99%E8%AF%AF/</url>
      
        <content type="html"><![CDATA[<blockquote><p>原文：<a href="https://blog.bitsrc.io/types-of-native-errors-in-javascript-you-must-know-b8238d40e492" target="_blank" rel="noopener">https://blog.bitsrc.io/types-of-native-errors-in-javascript-you-must-know-b8238d40e492</a></p></blockquote><p>我们在各处都能看到错误，从浏览器控制台到运行着 <code>Node.js</code> 的设备终端。</p><p>这篇博客将主要列举一下我们在 <code>JS</code> 开发中可能邂逅的错误类型。</p><p><strong>Tip</strong>：更好的使用错误类型，可以让我们从缓慢而地狱般的开发体验中解放出来，享受快速而无痛的编程。当你编写可复用的代码时，请确保你编写的错误清晰而易懂。</p><a id="more"></a><h1 id="rangeerror"><a class="markdownIt-Anchor" href="#rangeerror"></a> RangeError</h1><hr /><p>当数字超过允许的数值范围时，就会抛出这个错误。</p><p>例如，</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> l = <span class="built_in">console</span>.log;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">90</span>, <span class="number">88</span>];</span><br><span class="line">arr.length = <span class="number">90</span> ** <span class="number">99</span>;</span><br></pre></td></tr></table></figure><p>我们有一个数组，数组里有两个元素。接着，我们试图让数组的元素数扩充到 <code>90**99 == 2.9512665430652753e+193</code> 。</p><p>这个数字远远超过了数组可以包含的元素数量。运行它将会抛出 <code>RangeError</code> ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ node errors</span><br><span class="line">errors.js:4</span><br><span class="line">arr.length = 90**99</span><br><span class="line"> ^</span><br><span class="line"></span><br><span class="line">RangeError: Invalid array length</span><br></pre></td></tr></table></figure><p>因为我们想要数组元素增加的数量已经超过了 <code>JS</code> 指定的范围。</p><h1 id="referenceerror"><a class="markdownIt-Anchor" href="#referenceerror"></a> ReferenceError</h1><hr /><p>当变量/项的引用被破坏时，将会抛出此错误。即变量/项不存在。</p><p>例如，</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> l = <span class="built_in">console</span>.log;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cat = <span class="string">"cat"</span>;</span><br><span class="line">cat;</span><br><span class="line">dog;</span><br></pre></td></tr></table></figure><p>我们有一个变量 <code>cat</code> 被初始化为 <code>&quot;cat&quot;</code>。接下来，我们引用了 <code>cat</code> 变量和 <code>dog</code> 变量。<code>cat</code> 变量存在，但是 <code>dog</code> 变量却不存在。</p><p>将可以返回 <code>&quot;cat&quot;</code>，而 <code>dog</code> 将会抛出引用错误，因为 <code>dog</code> 的变量名在环境记录中查找不到。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ node errors</span><br><span class="line">errors.js:3</span><br><span class="line">dog</span><br><span class="line">^</span><br><span class="line"></span><br><span class="line">ReferenceError: dog is not defined</span><br></pre></td></tr></table></figure><p>无论何时我们定义一个变量时，这个变量名都会被写入一个环境记录中。这个环境记录像是 <code>key-value</code> 的存储。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+-------------+</span><br><span class="line">| Key | Value |</span><br><span class="line">---------------</span><br><span class="line">| cat | &quot;cat&quot; |</span><br><span class="line">+-------------+</span><br></pre></td></tr></table></figure><p>其中存储了我们在程序中定义的变量。不论何时我们引用一个变量，变量名将会被作为 <code>key</code> ，在环境记录中寻找。当找到时，其 <code>value</code> 将会被提取并返回。</p><p>现在，当我们创建或定义一个未赋值的变量。这个变量将会被写入环境记录，其变量名将作为 <code>key</code>，而 <code>value</code> 保持 <code>undefined</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var cat</span><br><span class="line">env record</span><br><span class="line">+-----------------+</span><br><span class="line">| Key | Value     |</span><br><span class="line">-------------------</span><br><span class="line">| cat | undefined |</span><br><span class="line">+-----------------+</span><br></pre></td></tr></table></figure><p>当变量稍候被赋值后，将会在环境记录中寻找这个变量，当找到时，初始的 <code>undefined</code> 将会被覆写为分配的那个值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var cat</span><br><span class="line">cat &#x3D; &quot;cat&quot;</span><br><span class="line">env record</span><br><span class="line">+-------------+</span><br><span class="line">| Key | Value |</span><br><span class="line">---------------</span><br><span class="line">| cat | &quot;cat&quot; |</span><br><span class="line">+-------------+</span><br></pre></td></tr></table></figure><p>所以，当环境记录中找不到变量名时，<code>JS</code> 引擎将会抛出 <code>ReferenceError</code> 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+-------------+</span><br><span class="line">| Key | Value |</span><br><span class="line">---------------</span><br><span class="line">| cat | &quot;cat&quot; |</span><br><span class="line">+-------------+</span><br><span class="line">cat &#x2F;&#x2F; &quot;cat&quot;, 是的, :) 它在这里</span><br><span class="line">dog &#x2F;&#x2F; :( 这啥啊？找不到啊</span><br></pre></td></tr></table></figure><p>注意：一个变量值为 <code>undefined</code> 的变量将不会排除将不会抛出 <code>ReferenceError</code> ，因为它存在于环境记录中，只是还没有设定变量值罢了。</p><h1 id="syntaxerror"><a class="markdownIt-Anchor" href="#syntaxerror"></a> SyntaxError</h1><hr /><p>这是我们遇见的最普通的错误了。当我们键入了 <code>JS</code> 引擎无法理解的代码时，将会抛出此错误。</p><p>当 <code>JS</code> 引擎在解析时，将会捕获此错误。代码通过，并将最终结果呈现在终端上之间，是有不同的阶段的。</p><ul><li><code>tokenization</code></li><li><code>parsing</code></li><li><code>interpreting</code></li></ul><p><code>tokenization</code> 将源码分隔成独立的单元。在这个阶段中，数字、关键词、字符、操作符将被解析并单独标记。</p><p>接下来，标记流生成后将进入解析阶段，这个阶段是解析器控制的。在这个阶段，将从标记流中生成 <code>AST</code> 。<code>AST</code> 是我们代码结构的抽象表示。</p><p>在 <code>tokenization</code> 和 <code>parsing</code> 这两个阶段中，如果我们代码的语法不符合 <code>JS</code> 语法，将会导致响应的阶段失败，并且抛出 <code>SyntaxError</code> 。例如，</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> l = <span class="built_in">console</span>.log</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cat h = <span class="string">"cat"</span></span><br></pre></td></tr></table></figure><p>单独的一个 <code>h</code> 是干啥的？这导致了语法错误。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ node errors</span><br><span class="line">errors.js:3</span><br><span class="line"><span class="built_in">let</span> cat h = <span class="string">"cat"</span></span><br><span class="line"> ^</span><br><span class="line"></span><br><span class="line">SyntaxError: Unexpected identifier</span><br></pre></td></tr></table></figure><p>看，<code>Node.js</code> 指出了错误。它说 <code>h</code> 是出乎意料的，这导致了声明 <code>cat</code> 变量的错误。</p><p>所以我们可以说，语法错误出现在解析/编译阶段。</p><h1 id="typeerror"><a class="markdownIt-Anchor" href="#typeerror"></a> TypeError</h1><hr /><p><code>TypeError</code> 被用来指示一个未成功的运算。当其他 <code>NativeError</code> 对象都不是错误的适当指示的时候。</p><p>当运算符被用于错误的数据类型时，将会出现 <code>TypeError</code> 。也许期望的是 <code>boolean</code> ，但找到的确是 <code>string</code>。</p><p>例如，</p><p>如果我们试着将一个数字转化为大写，像这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> num = <span class="number">123</span>;</span><br><span class="line">num.toUpperCase();</span><br></pre></td></tr></table></figure><p>这将会抛出一个 <code>TypeError</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ node errors</span><br><span class="line">errors.js:4</span><br><span class="line">num.toUpperCase()</span><br><span class="line"> ^</span><br><span class="line"></span><br><span class="line">TypeError: num.toUpperCase is not a <span class="keyword">function</span></span><br></pre></td></tr></table></figure><p>因为 <code>toUpperCase</code> 期望的是一个字符串类型的数据。<code>toUpperCase</code> 函数是故意通用的。它并不需要值是 <code>String</code> 对象。因此，他可以被转化为其他类型的对象，从而作为一个方法被调用。</p><p>只有字符可以转发微大写或小写。如果我们在 <code>Object</code> 、<code>Bollean</code> 、<code>Symbol</code> 、<code>null</code>、<code>undefined</code> 数据类型上调用 <code>toUpperCase</code> 函数，我们将会得到 <code>TypeError</code> 错误。因为这些数据类型不能这样运算。</p><h1 id="urierror"><a class="markdownIt-Anchor" href="#urierror"></a> URIError</h1><hr /><p>其表明了一个全局 <code>URI</code> 处理函数被以一种与其定义不兼容的方式调用。</p><p>URI（Uniform Resource Indicator）在 <code>JS</code> 中有一些处理函数：<code>decodeURI</code>，<code>decodeURIComponent</code> 等。</p><p>如果我们使用了错误的参数来调用他们，将会得到 <code>URIError</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">decodeURI(<span class="string">"%"</span>)</span><br><span class="line">^</span><br><span class="line"></span><br><span class="line">URIError: URI malformed</span><br></pre></td></tr></table></figure><p><code>decodeURI</code> ，参数是未编码的 <code>URI</code> 。而 <code>%</code> 并不是一个正确的 <code>URI</code> ，所以会抛出 <code>URIError</code></p><blockquote><p>当编码或解码 <code>URI</code> 错误时，将会抛出 <code>URIError</code></p></blockquote><h1 id="evalerror"><a class="markdownIt-Anchor" href="#evalerror"></a> EvalError</h1><hr /><p>这个错误被用来标识调用全局 <code>eval()</code> 函数错误时。</p><p>根据 EcmaSpec 2018 版：</p><p>这个异常并没有在当前版本使用，该错误对象任然与该规范的先前的版本兼容。</p><h1 id="internalerror"><a class="markdownIt-Anchor" href="#internalerror"></a> InternalError</h1><hr /><p>这个错误出现在 <code>JS</code> 引擎的内部。特别是当有太多的数据需要处理并且栈增长的超过了限制。</p><p>当 <code>JS</code> 引擎被太多的递归，切换用例所淹没时，就会出现这种情况：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(num) &#123;</span><br><span class="line"> <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line"> ...</span><br><span class="line"> <span class="keyword">break</span></span><br><span class="line"> <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line"> ...</span><br><span class="line"> <span class="keyword">break</span></span><br><span class="line"> <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line"> ...</span><br><span class="line"> <span class="keyword">break</span></span><br><span class="line"> <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line"> ...</span><br><span class="line"> <span class="keyword">break</span></span><br><span class="line"> <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line"> ...</span><br><span class="line"> <span class="keyword">break</span></span><br><span class="line"> <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line"> ...</span><br><span class="line"> <span class="keyword">break</span></span><br><span class="line"> <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line"> ...</span><br><span class="line"> <span class="keyword">break</span></span><br><span class="line"> ... up to <span class="number">1000</span> cases</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>太多的递归，一个简单的例子是这样的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  foo();</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><h1 id="结论"><a class="markdownIt-Anchor" href="#结论"></a> 结论</h1><hr /><p>正如我们所说的，没有人可以从错误中脱身。只要我们敲代码，就一定会出现。为了打败他们，我们得知道我们可以抛出的原生错误。我们在这篇文章中列出了他们，并且使用了几个简单的例子来向你展示它们是如何被触发的。</p><p>现在，不何时在终端或是浏览器抛出错误，你都可以轻松的知道他们是由哪段代码触发的了。这样你就可以写出更好的，更少出错的代码了。</p><p>如果你对这篇博客有任何问题或是希望我修改、添加或删除什么，欢迎评论或者是直接发邮件给我</p><blockquote><p>发给原作者！</p></blockquote><p>谢谢！！</p>]]></content>
      
      
      <categories>
          
          <category> 翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 错误 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>无比芜杂的 JavaScript 执行上下文——变量对象、作用域链和 this</title>
      <link href="/2020/03/11/JavaScript%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/"/>
      <url>/2020/03/11/JavaScript%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这篇文章是对<a href="https://github.com/mqyqingfeng/Blog/issues/7" target="_blank" rel="noopener">JavaScript 深入之从 ECMAScript 规范解读 this</a>的一个总结和补充。意在对 JavaScript 执行上下文的来龙去脉做一个基本的梳理。</p></blockquote><p>在开始谈论执行上下文之前，我们必须对 JavaScript 的作用域有一定的了解，才能清楚的理解执行上下文的设计思路。你可以阅读<a href="%5Bhttps://www.bebopser.com/2020/03/07/%E9%97%AD%E5%8C%85%E4%B8%8E%E8%A3%85%E9%A5%B0%E5%99%A8/%5D(https://www.bebopser.com/2020/03/07/%E9%97%AD%E5%8C%85%E4%B8%8E%E8%A3%85%E9%A5%B0%E5%99%A8/)">这篇文章</a>的第一部分<strong>变量与变量的作用域</strong>。</p><h1 id="执行上下文"><a class="markdownIt-Anchor" href="#执行上下文"></a> 执行上下文</h1><hr /><p>关于执行上下文的解释，我们采用 <a href="http://es5.github.io/#x10.3" target="_blank" rel="noopener">ECMAScript 5.1 规范</a> 的定义。你需要注意的是，在 ES6 开始，对执行上下文的内涵进行了延伸，但它们依旧包含 ES5 的定义。</p><h2 id="可执行代码"><a class="markdownIt-Anchor" href="#可执行代码"></a> 可执行代码</h2><p>在讲解执行上下文之前，我们需要了解一下 ES 对于可执行代码的定义。ECMAScript 的可执行代码有三种类型：<code>Global code</code>，<code>Eval code</code>，<code>Function code</code>。你可以通过 <a href="http://es5.github.io/#x10.1" target="_blank" rel="noopener">ECMAScript 5.1 规范</a> 来详细了解可执行代码。你需要注意的是规范中关于 <code>Function code</code> 的这句话：</p><blockquote><p>The <em>function code</em> of a paticular <strong>FunctionBody</strong> does not include any source text that is parsed as part of a nested <strong>FunctionBody</strong></p></blockquote><p>简单来说，就是一个函数和函数内的嵌套函数，并不属于同一个函数。</p><a id="more"></a><h2 id="执行上下文栈"><a class="markdownIt-Anchor" href="#执行上下文栈"></a> 执行上下文栈</h2><p><strong>下面的属性或方法并不真实的存在于 JavaScript 代码中，它们只是对语言逻辑的一种描述</strong></p><p>当解释器执行到一段可执行代码时，将会进入相应的 <code>执行上下文</code> 。</p><p>各个执行上下文在逻辑上形成堆栈的数据结构，这个堆栈的栈顶是当前正在运行的执行上下文。</p><p>当解释器运行到一段和之前的执行上下文不相关的可执行代码时，将会创建一个新的执行上下文，并将其推入堆栈的栈顶，从而使其变成当前正在运行的执行上下文。</p><p>而执行上下文中究竟包含些什么呢？其实就是当前代码执行的一些状态信息。事实上，你可以将其看做一个<strong>有限状态机</strong>。根据 ES5 规范的定义，执行上下文中包含了以下几个组件：</p><ul><li><code>LexicalEnvironment</code>：标识词法环境，解析此上下文中的标识符引用。也就是作用域链。</li><li><code>VariableEnvironment</code>：标识词法环境，保存由执行上下文中的 <em>variablestatement</em> 和 <em>functiondeclaration</em> 创建的绑定。也就是<strong>变量对象（Variable object，VO）</strong>。</li><li><code>ThisBinding</code>：与此上下文关联的 <strong>this</strong> 关键字的值</li></ul><p>一个执行上下文的生命周期可以分为两个阶段：</p><ul><li>创建阶段：创建变量对象、建立作用域链、确定 this 的指向</li><li>代码执行阶段：执行变量赋值，函数引用及其他代码逻辑</li></ul><p>注意，从 ES6 开始，官方对执行上下文的内涵进行了延伸，新的定义中，执行上下文包含了 <code>code evaluation state</code> ，<code>Function</code>，<code>Realm</code>，<code>ScriptOrModule</code>（ES8）。而 <code>LexicalEnvironment</code> 和 <code>VariableEnvironmen</code> 都被定义为执行上下文的附加状态组件。但这并不影响我们基于 ES5 规范来解释 JavaScript 的整体执行脉络。</p><h1 id="变量对象variable-objectvo"><a class="markdownIt-Anchor" href="#变量对象variable-objectvo"></a> 变量对象（Variable object，VO）</h1><hr /><p>变量对象中存储了在上下文中定义的变量和函数声明。而在全局上下文和函数上下文中，变量对象都将拥有不同的值。</p><h2 id="全局上下文"><a class="markdownIt-Anchor" href="#全局上下文"></a> 全局上下文</h2><p>全局上下文中的变量对象就是全局对象。</p><p>在浏览器中，全局对象就是 <code>window</code> 对象。是由 <code>Object</code> 构造函数实例化的。（这很好理解，因为原型链的第二级本身就是 <code>Object</code>）。它有一个 <code>window</code> 属性指向了自身。</p><p>另外的，如果你声明了全局变量，那么这个变量就将作为全局对象的一个属性。</p><p>进一步的，全局对象上还定义了一些内置函数和属性。</p><h2 id="函数上下文"><a class="markdownIt-Anchor" href="#函数上下文"></a> 函数上下文</h2><p>在函数中，我们使用活动对象（Activation object， AO）来描述 <code>variableEnvironment</code> 。<code>AO</code> 不仅包含了全局上下文的 <code>VO</code> ，还包含了函数的参数以及 arguments 对象。</p><h2 id="变量对象的执行过程"><a class="markdownIt-Anchor" href="#变量对象的执行过程"></a> 变量对象的执行过程</h2><p>变量对象将包含以下几个内容：</p><ul><li>函数的所有形参</li><li>函数声明<ul><li>如果变量对象已经存在相同名称的属性，则完全替换这个属性</li></ul></li><li>变量声明<ul><li>如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性</li></ul></li></ul><p>这里有一个例子，是根据原文改编的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> b = <span class="number">1</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  <span class="keyword">let</span> d = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">  b = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>在进入执行上下文后，此时的 <code>AO</code> 是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">AO = &#123;</span><br><span class="line">  <span class="built_in">arguments</span>: &#123;</span><br><span class="line">    <span class="number">0</span>: <span class="number">1</span>,</span><br><span class="line">    length: <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="literal">undefined</span>,</span><br><span class="line">  c: reference to <span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">  d: <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你会发现，变量 <code>b</code> 和 <code>d</code> 都被定义了，并且初始值为 <code>undefined</code> 。而函数 <code>c</code> 则是使用变量 <code>c</code> 引用了函数。这就是所谓的 <code>变量提升</code> 和 <code>函数提升</code>。</p><p>而参数已经被定义了并赋值了，所以你可以使用它。</p><p>在代码执行的时候，<code>AO</code> 将会被更新：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">AO = &#123;</span><br><span class="line">  <span class="built_in">arguments</span>: &#123;</span><br><span class="line">    <span class="number">0</span>: <span class="number">1</span>,</span><br><span class="line">    length: <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="number">3</span>,</span><br><span class="line">  c: reference to <span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">  d: reference to FunctionExpression <span class="string">"d"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="作用域链"><a class="markdownIt-Anchor" href="#作用域链"></a> 作用域链</h1><hr /><p>作用域链是为了解决变量查找的问题的。它实际上是一个链表，是由依次进入执行上下文时创建的变量对象组成的。</p><p>在查找变量时，将会先从当前上下文的变量对象中查找，如果没有找到，就会从父级执行上下文中查找，一直找到全局上下文为止。如果还未找到，则抛出错误。</p><p>函数中有一个内部属性 <code>[[scope]]</code> ，它存储的是所有父级变量对象的层级链。注意，这是针对于该函数而言的<strong>词法作用域链</strong>。</p><p>函数在定义和调用的上下文并不一定一致。而进入上下文指的是函数的调用而不是定义。</p><p>比如有以下代码：（我们在这里先略去关于 this 的解释）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">"global scope"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkscope</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> name2 = <span class="string">"local scope"</span>;</span><br><span class="line">  <span class="keyword">return</span> scope2;</span><br><span class="line">&#125;</span><br><span class="line">checkscope();</span><br></pre></td></tr></table></figure><ol><li>当进入函数 <code>checkscope</code> 的执行上下文时，会把全局上下文的变量对象存入函数的 <code>[[scope]]</code> 属性：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">checkscope[[scope]] = [globalContext.VO];</span><br></pre></td></tr></table></figure><ol start="2"><li>执行 <code>checkscope</code> 函数，创建函数执行上下文，并将该上下文压入执行上下文栈，处于栈顶：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ECStack = [checkscopeContext, globalContext];</span><br></pre></td></tr></table></figure><ol start="3"><li>复制函数的 <code>[[scope]]</code> 创建作用域链</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">checkscopeContext = &#123;</span><br><span class="line">  Scope: checkscope[[scope]],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="4"><li>使用 <code>arguments</code> 对象创建活动对象，然后进行初始化，创建形参，变量，函数声明。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">checkscopeContext = &#123;</span><br><span class="line">  AO: &#123;</span><br><span class="line">    <span class="built_in">arguments</span>: &#123;</span><br><span class="line">      length: <span class="number">0</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    name2: <span class="literal">undefined</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  Scope: checkscope[[scope]],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="5"><li>创建的活动对象将被压入 <code>checkscope</code> 作用域链顶：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">checkscopeContext = &#123;</span><br><span class="line">  AO: &#123;</span><br><span class="line">    <span class="built_in">arguments</span>: &#123;</span><br><span class="line">      length: <span class="number">0</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    name2: <span class="literal">undefined</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  Scope: [AO, [[Scope]]],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>随着函数的执行，<code>AO</code> 将会被相应的修改。当函数执行完毕后，<code>checkscope</code> 函数上下文从执行上下文栈弹出。</p><h1 id="this"><a class="markdownIt-Anchor" href="#this"></a> this</h1><h2 id="确认-this-的逻辑"><a class="markdownIt-Anchor" href="#确认-this-的逻辑"></a> 确认 <code>this</code> 的逻辑</h2><blockquote><p>如果你不想了解细节，那么你可以跳到 <strong>对一些总结的解释</strong> 这一节</p></blockquote><p>根据规范和原文章，可以将对 <code>this</code> 值的确认简化为以下逻辑：</p><ol><li>计算 <code>MemberExpression</code> 的值，赋给 <code>ref</code> 这个变量</li><li>如果 <code>ref</code> 是一个 <code>Reference</code> 类型：<ol><li>如果 <code>IsPropertyReference(ref)</code> 为 <code>true</code> ，那么 <code>this</code> 的值为 <code>GetBase(ref)</code></li><li>如果 <code>IspropertyReference(ref)</code> 为 <code>false</code> 而 <code>ref</code> 的 <code>base value</code> 值是 <code>Environment Record</code> ，那么 <code>this</code> 的值为 <code>ImplicitThisValue(ref)</code></li></ol></li><li>如果 <code>ref</code> 不是一个 <code>Reference</code> ，那么 <code>this</code> 的值为 <code>undefined</code></li></ol><p>详细的过程，你可以参考<a href="http://es5.github.io/#x11.2.3" target="_blank" rel="noopener">规范</a></p><p>下面解释一下算法中出现的一些关键词：</p><h3 id="memberexpression"><a class="markdownIt-Anchor" href="#memberexpression"></a> <code>MemberExpression</code></h3><p>对于一此典型的函数调用过程，可以有以下图：</p><p><img src="https://bebopfzj.oss-cn-hangzhou.aliyuncs.com/uPic/2020-03-11-VJ59ti.png" alt="函数调用" /></p><p>括号左边的这部分被称为 <code>MemberExpression</code> 。你可以参考<a href="http://es5.github.io/#x11.2" target="_blank" rel="noopener">规范</a>来详细了解，<code>MemberExpression</code> 包含：</p><ul><li><code>PrimaryExpression</code> 原始表达式</li><li><code>FunctionExpression</code> 函数定义表达式</li><li><code>MemberExpression[Expression]</code> 属性访问表达式</li><li><code>MemberExpression.IdentifierName</code> 属性访问表达式</li><li><code>new MemberExpression Arguments</code> 对象创建表达式</li></ul><p>总之，就是调用符号 <code>()</code> 左边的内容。</p><p>你需要注意的是，如果 <code>MemberExpression</code> 涉及到了诸如 <code>赋值操作符</code>，<code>逻辑操作符</code>，<code>逗号操作符</code> 等需要得到真正值才进行下一步计算的操作符时，将会调用 <code>GetValue(lref)</code> 函数，这将返回其真正的值，而不是一个 <code>Reference</code> 。</p><h3 id="reference"><a class="markdownIt-Anchor" href="#reference"></a> <code>Reference</code></h3><p>它是存在于规范中的抽象类型，并不存在于实际的 <code>js</code> 代码中，仅仅是为了描述语言的底层行为才存在的。</p><p><code>Reference</code> 由以下三个部分构成：</p><ul><li><code>base value</code>：属性所在的对象，值只可能是 <code>undefined</code> ，<code>an Object</code>，<code>a Bollean</code> ，<code>a String</code> ，<code>a Number</code> ，<code>an environment record</code> 中的一种。</li><li><code>referenced name</code></li><li><code>strict reference</code></li></ul><p>例如两个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对应的 Reference</span></span><br><span class="line"><span class="keyword">let</span> fooReference = &#123;</span><br><span class="line">  base: EnvironmentRecord,</span><br><span class="line">  name: <span class="string">"foo"</span>,</span><br><span class="line">  strict: <span class="literal">false</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> foo = &#123;</span><br><span class="line">  bar: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对应的 Reference</span></span><br><span class="line"><span class="keyword">let</span> barReference = &#123;</span><br><span class="line">  base: foo,</span><br><span class="line">  propertyName: <span class="string">"bar"</span>,</span><br><span class="line">  strict: <span class="literal">false</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="ispropertyreferenceref"><a class="markdownIt-Anchor" href="#ispropertyreferenceref"></a> <code>IsPropertyReference(ref)</code></h3><p>如果 <code>base value</code> 是一个对象，则该方法返回 <code>true</code> 。反之为 <code>false</code>。</p><h3 id="getbaseref"><a class="markdownIt-Anchor" href="#getbaseref"></a> <code>GetBase(ref)</code></h3><p>获取 <code>base value</code> 的值。</p><h3 id="implicitthisvalueref"><a class="markdownIt-Anchor" href="#implicitthisvalueref"></a> <code>ImplicitThisValue(ref)</code></h3><p>始终返回 <code>undefined</code></p><h2 id="对逻辑的简化"><a class="markdownIt-Anchor" href="#对逻辑的简化"></a> 对逻辑的简化</h2><p>根据上文的解释，我们可以提取出核心的逻辑：</p><ol><li>首先，确认函数的调用对象，并计算其值。如果在计算过程中取得了变量的真实值，那么 <code>this</code> 将为 <code>undefined</code></li><li>如果调用对象是一个非全局对象的对象，那么函数中的 <code>this</code> 值就是这个对象</li><li>如果调用对象是全局对象，那么函数中的 <code>this</code> 为 <code>undefined</code> 。</li></ol><p>在非严格模式下，<code>undefined</code> 会被修正为全局对象，例如 <code>window</code></p><p>你也可以参考<a href="https://zhuanlan.zhihu.com/p/23804247" target="_blank" rel="noopener">这篇文章</a>，里面是将所有函数调用转化成了 <code>.call(context, args)</code> 的方式来讲解，但实质和这里的是一样的。</p><h2 id="对一些总结的解释"><a class="markdownIt-Anchor" href="#对一些总结的解释"></a> 对一些总结的解释</h2><p>网上有很多 <code>this</code> 值的总结，通常是从调用方式方面出发总结的，下面我们就应用上面的理论，对这些总结做一下剖析：</p><p>有定义：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>有如下总结：</p><ul><li>作为对象调用时，指向该对象 <code>obj.b()</code><ul><li><code>Obj.b()</code> 的 <code>baseValue</code> 是 <code>obj</code>。首先，属性访问器的计算结果是一个 <code>reference</code> 类型，其次，<code>obj</code> 是一个对象。故而 <code>this</code> 的值就是 <code>baseValue</code> 的值，也就是 <code>obj</code></li></ul></li><li>在全局作为函数调用，指向全局对象 <code>window</code><ul><li>这种情况下，<code>base value</code> 为 <code>environment record</code>，<code>this</code> 恒为 <code>undefined</code>。非严格模式下会被修正为 <code>window</code></li></ul></li><li>作为 <code>call</code> 或 <code>apply</code> 调用，<code>this</code> 指向当前的 <code>object</code></li><li>作为构造函数调用，<code>this</code> 指向当前实例对象</li></ul><h3 id="构造函数的-this"><a class="markdownIt-Anchor" href="#构造函数的-this"></a> 构造函数的 <code>this</code></h3><p>详细解释一下作为构造函数调用时的情况。在使用 <code>new</code> 调用构造函数创建实例时，实际执行了以下几个步骤：</p><ul><li>创建一个空对象，作为<strong>将要返回的对象实例</strong></li><li>将空对象的原型指向构造函数的 <code>prototype</code> 属性</li><li>将空对象赋值给构造函数内部的 <code>this</code> 关键字</li><li>开始执行构造函数内部的代码</li></ul><h3 id="箭头函数的-this"><a class="markdownIt-Anchor" href="#箭头函数的-this"></a> 箭头函数的 <code>this</code></h3><p>箭头函数没有 <code>this</code> ，它的 <code>this</code> 就是外面词法作用域的 <code>this</code> 。</p><h3 id="对于嵌套函数的调用"><a class="markdownIt-Anchor" href="#对于嵌套函数的调用"></a> 对于嵌套函数的调用</h3><p>嵌套函数的调用一律指向 <code>undefined</code> ，在非严格模式下指向 <code>window</code> 对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">"windowsName"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> name = <span class="string">"Cherry"</span>;</span><br><span class="line">  innerFunction();</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">innerFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn(); <span class="comment">// windowsName</span></span><br></pre></td></tr></table></figure><p>或是这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"windowsName"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line">  name: <span class="string">"good"</span>,</span><br><span class="line">  n: <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">"Cherry"</span>;</span><br><span class="line">    innerFunction();</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">innerFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">o.n(); <span class="comment">// windowsName</span></span><br></pre></td></tr></table></figure><h3 id="apply-call-bind"><a class="markdownIt-Anchor" href="#apply-call-bind"></a> <code>apply</code>、<code>call</code>、<code>bind</code></h3><p>使用 <code>apply</code> 或 <code>call</code> 可以修改上下文的 <code>this</code> 值，它们的区别是调用方式不同。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.a + <span class="keyword">this</span>.b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">add.call(obj, <span class="number">2</span>, <span class="number">2</span>); <span class="comment">// 3</span></span><br><span class="line">add.apply(obj, [<span class="number">3</span>, <span class="number">3</span>]); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>使用 <code>bind</code> 方法可以忽略当前的 <code>this</code> 绑定，指向到我们提供的对象上：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  x: <span class="number">81</span>,</span><br><span class="line">  getX: <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.x + <span class="string">' '</span> + name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.getX(<span class="string">'good'</span>)<span class="comment">// 81 good</span></span><br><span class="line"><span class="keyword">let</span> f1 = obj.getX</span><br><span class="line"></span><br><span class="line">f1.apply(obj, [<span class="string">'Spike'</span>])<span class="comment">// 81 Spike</span></span><br><span class="line">f1.call(obj, <span class="string">'Spike'</span>)<span class="comment">// 81 Spike</span></span><br><span class="line">f1.bind(obj).(<span class="string">'Spike'</span>)<span class="comment">// 81 Spike</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 语言特性 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 执行上下文 </tag>
            
            <tag> 变量对象 </tag>
            
            <tag> 作用域链 </tag>
            
            <tag> this </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>宝刀般的抽象基类——从协议说起</title>
      <link href="/2020/03/10/%E6%8A%BD%E8%B1%A1%E5%9F%BA%E7%B1%BB/"/>
      <url>/2020/03/10/%E6%8A%BD%E8%B1%A1%E5%9F%BA%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="鸭子类型"><a class="markdownIt-Anchor" href="#鸭子类型"></a> 鸭子类型</h1><hr /><p>在 Python 中，创建功能完善的序列并不需要使用继承，而只需要实现符合序列协议的方法。</p><p>Python 中的协议是一种动态的，非正式的协议。它仅仅在文档中定义，因此也不能像真正的接口一样，对代码作出限制。这种约定可能会让使用惯了 <code>Java</code> 或是 <code>C#</code> 的程序员感到新奇。</p><p>Python 会尽可能的支持基本协议。例如如果你在类中实现了 <code>__getitem__</code> 方法，那么解释器就会将其当做一个序列来执行，尽管序列协议要求实现的是 <code>__iter__</code> 方法。</p><p>另外的，一个类也可以实现多个接口以扮演不同的角色。</p><p>进一步的，你甚至可以在运行时使用 <code>猴子补丁</code> 来事先协议。例如，你可以在运行时为一个类增加 <code>__setitem__</code> 方法，从而可以使用 <code>random.shuffle</code> 函数打乱序列：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_card</span><span class="params">(instance, position, card)</span>:</span></span><br><span class="line">  instance.__cards[position] = card</span><br><span class="line"></span><br><span class="line">&gt;&gt; FrenchDeck.__setitem__ = set_card</span><br><span class="line">&gt;&gt; shuffle(deck)</span><br></pre></td></tr></table></figure><p>总的来说，这也就是 <code>鸭子类型</code> 的代表特征——动态协议。</p><a id="more"></a><h1 id="使用标准库中的抽象基类"><a class="markdownIt-Anchor" href="#使用标准库中的抽象基类"></a> 使用标准库中的抽象基类</h1><hr /><p>抽象基类类似于 <code>Java</code> 中的接口。只定义各种方法，而不去实现。任何继承自抽象基类的类必须要实现这些方法。这种做法同时也能清楚的表达开发者的意图。</p><p>你可以使用 <code>isinstance</code> 和 <code>issubclass</code> 来测试抽象基类。这是很灵活的做法，因为如果某个组件没有继承抽象基类，你也可以为其注册虚拟子类，来让显式类型检查通过。</p><p>但是尽管这样，你也不能在代码里滥用 <code>isinstance</code> 检查，而仅仅是为了根据对象类型来执行不同的操作。如果你有这种需求，那么更好的选择是使用多态，让解释器来承担分派的任务。</p><p>它常用来在框架中封装引入的一般性概念和抽象。在大多数时候，你并不需要去自己实现一个抽象基类。为了生活愉快，直接使用标准库中的抽象基类即比较好的选择。</p><h2 id="collectionsabc-模块中的抽象基类"><a class="markdownIt-Anchor" href="#collectionsabc-模块中的抽象基类"></a> <code>collections.abc</code> 模块中的抽象基类</h2><blockquote><p>在 Python 中，还有一个 <code>abc.ABC</code> 类。每一个抽象基类都依赖这个类。你不必导入它，除非要自定义新类</p></blockquote><p>你可以参考<a href="https://docs.python.org/zh-cn/3.7/library/collections.abc.html" target="_blank" rel="noopener">官方文档</a>来查阅这个抽象基类的各项细节。我们在这里使用 <code>collections.MutableSequence</code> 基类来定义一个子类。这个例子来源于《流畅的 Python》</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line">Card = collections.namedtuple(<span class="string">'Card'</span>, [<span class="string">'rank'</span>, <span class="string">'suit'</span>])</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FrenchDeck2</span><span class="params">(collections.MutableSequence)</span>:</span></span><br><span class="line">  ranks = [str(n) <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">2</span>, <span class="number">11</span>)] + list(<span class="string">'JQKA'</span>)</span><br><span class="line">  suits = <span class="string">'spades diamonds clubs heart'</span>.split()</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">    self._cards = [Card(rank, suit) <span class="keyword">for</span> suit <span class="keyword">in</span> self.suits</span><br><span class="line">                   <span class="keyword">for</span> rank <span class="keyword">in</span> self.ranks]</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> len(self._cards)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, position)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> self._cards[position]</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__setitem__</span><span class="params">(self, position, value)</span>:</span></span><br><span class="line">    self._cards[position] = value</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__delitem__</span><span class="params">(self, position)</span>:</span></span><br><span class="line">    <span class="keyword">del</span> self._cards[position]</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, position, value)</span>:</span></span><br><span class="line">    self._cards.insert(position, value)</span><br></pre></td></tr></table></figure><p>Python 并不会检查抽象方法的实现，在运行时实例化这个类的时候才会检查。如果没有实现某个方法，解释器就会抛出 <code>TypeError</code> 异常。所以如果你继承了一个抽象基类，那么即使不使用全部的方法，也要依次实现。</p><h2 id="numbers"><a class="markdownIt-Anchor" href="#numbers"></a> numbers</h2><p>这个模块定义了数字抽象基类的层次结构，你可以在<a href="https://docs.python.org/zh-cn/3.7/library/numbers.html" target="_blank" rel="noopener">官方文档</a>中查阅到更详细的信息。这些抽象基类的层级结构是线性的：</p><ul><li>Number</li><li>Complex</li><li>Real</li><li>Rational</li><li>Integral</li></ul><p>因为存在这种金字塔形的线性结构，所以在类型检查时，你可以通过检查上层类型，来兼容所有下层类型。</p><p>例如，你可以使用 <code>isinstance(x, numbers.Real)</code> 来检查一个值是否是浮点数类型，这样代码就能接受 <code>bool</code>、<code>int</code>、<code>float</code>、<code>fractions.Fraction</code> 。</p><p>另外的，为了满足检查的需要，你或者 API 用户可以将兼容的类型也注册为 <code>numbers.Real</code> 的虚拟子类。</p><h1 id="定义并使用一个抽象基类"><a class="markdownIt-Anchor" href="#定义并使用一个抽象基类"></a> 定义并使用一个抽象基类</h1><hr /><blockquote><p><strong>注意，除非你在写一个新的框架，不然在绝大多数情况下都不需要自己重头实现一个抽象基类。这里只是为了明确抽象基类的用法和执行细节。</strong></p></blockquote><p>我们将定义一个抽象基类，它的职责是，指导并支持用户提供随机挑选的无重复类。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这是 Python 3.4 新增的类</span></span><br><span class="line"><span class="comment"># 如果你执意在旧版中使用，那么你应该将语句写成</span></span><br><span class="line"><span class="comment"># class Tombola(metaclass=abc.ABCMeta)</span></span><br><span class="line"><span class="keyword">import</span> abc</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tombola</span><span class="params">(abc.ABC)</span>:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 抽象方法使用 @abstractmethod 装饰器标记</span></span><br><span class="line">  <span class="comment"># 定义体中仅有文档字符串</span></span><br><span class="line"><span class="meta">  @abc.abstractmethod</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">load</span><span class="params">(self, iterable)</span>:</span></span><br><span class="line">    <span class="string">"""从可迭代对象中添加元素"""</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 因为装饰器可以堆叠</span></span><br><span class="line">  <span class="comment"># 所以你可以这样声明一个抽象类方法</span></span><br><span class="line">  <span class="comment"># @classmethod</span></span><br><span class="line">  <span class="comment"># @abc.abstractmethod</span></span><br><span class="line">  <span class="comment"># def func():</span></span><br><span class="line">  <span class="comment"># ...</span></span><br><span class="line"><span class="meta">  @abc.abstractmethod</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">pick</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""随机删除元素，并将其返回</span></span><br><span class="line"><span class="string">    如果实例为空，则应抛出 LookupError</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">loaded</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""如果至少有一个元素，则返回 'True'，否则返回'Flase'"""</span></span><br><span class="line">    <span class="keyword">return</span> bool(self.inspect())</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">inspect</span><span class="params">(slef)</span>:</span></span><br><span class="line">    <span class="string">"""返回一个有序元组，由当前元素构成"""</span></span><br><span class="line">    items = []</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">      <span class="keyword">try</span>:</span><br><span class="line">        items.append(self.pick())</span><br><span class="line">      <span class="keyword">except</span> LookupError:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    self.load(items)</span><br><span class="line">    <span class="keyword">return</span> tuple(sorted(items))</span><br></pre></td></tr></table></figure><p>接着，我们将继承这个抽象基类，定义一个子类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LotteryBlower</span><span class="params">(Tombola)</span>:</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, iterable)</span>:</span></span><br><span class="line">    <span class="comment"># 这里没有直接赋值来保存引用，而是构建了新的副本</span></span><br><span class="line">    <span class="comment"># 这样即使我们在方法中删除 iterable 的某些元素，也不会影响用户的数据</span></span><br><span class="line">    self._balls = list(iterable)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">load</span><span class="params">(self, iterable)</span>:</span></span><br><span class="line">    self._balls.extend(iterable)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">pick</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">      position = random.randrange(len(self._balls))</span><br><span class="line">    <span class="keyword">except</span> ValueError:</span><br><span class="line">      <span class="keyword">raise</span> LookupError(<span class="string">'pick from empty LotteryBlower'</span>)</span><br><span class="line">    <span class="keyword">return</span> self._balls.pop(position)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 在这里覆写了继承下来的 loaded 和 inspect 方法</span></span><br><span class="line">  <span class="comment"># 当然我们也可以偷懒，直接继承抽象基类中的方法</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">loaded</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> bool(self._balls)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">inspect</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> tuple(sorted(self._balls))</span><br></pre></td></tr></table></figure><p>另外的，我们还可以将一个兼容的类注册为 <code>Tombola</code> 的虚拟子类。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randrange</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用类装饰器，注册为 Tombola 的虚拟子类</span></span><br><span class="line"><span class="meta">@Tombola.register</span></span><br><span class="line"><span class="comment"># 这个类扩展了 list</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TomboList</span><span class="params">(list)</span>:</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">pick</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> self:</span><br><span class="line">      position = randrange(len(self))</span><br><span class="line">      <span class="keyword">return</span> self.pop(position)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      <span class="keyword">raise</span> LookupError(<span class="string">'pop from empty TomboList'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 将 load 方法直接覆写为 list.extend</span></span><br><span class="line">  load = list.extend</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 将 loaded 方法委托给 bool 函数</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">loaded</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> bool(self)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">inspect</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> tuple(sorted(self))</span><br></pre></td></tr></table></figure><p>这里使用了类装饰器来注册虚拟子类。不过在 Python 3.3 之前的版本中，你都不能这么做。你应当像调用普通函数那样来注册。另外的，社区也偏向使用这种方法来注册。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Sequence.register(tuple)</span><br><span class="line">Sequence.register(str)</span><br></pre></td></tr></table></figure><p>上面的这段代码将内置类型 <code>tuple</code> 和 <code>str</code> 都注册成了 <code>Sequence</code> 的虚拟子类。</p>]]></content>
      
      
      <categories>
          
          <category> 语言特性 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 鸭子类型 </tag>
            
            <tag> 抽象基类 </tag>
            
            <tag> 虚拟子类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4个编写高质量 JavaScript 模块的最佳实践（翻译）</title>
      <link href="/2020/03/10/4%E4%B8%AA%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8Fjavascript%E6%A8%A1%E5%9D%97%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
      <url>/2020/03/10/4%E4%B8%AA%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8Fjavascript%E6%A8%A1%E5%9D%97%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<blockquote><p>原文：<a href="https://dmitripavlutin.com/javascript-modules-best-practices/" target="_blank" rel="noopener">https://dmitripavlutin.com/javascript-modules-best-practices/</a></p></blockquote><p>借助 ES2015 的模块化方案，你可以将应用拆分为可复用的，封装的，仅专注于单一功能的模块。</p><p>这确实是个好想法，但随之而来的问题是，你究竟该如何组织这些模块呢？一个模块中应该包含多少个类或函数呢？</p><p>这篇文章展示了 4 种如何更好地组织你的 JavaScript 模块的最佳实践。</p><a id="more"></a><h1 id="1-使用具名导出"><a class="markdownIt-Anchor" href="#1-使用具名导出"></a> 1. 使用具名导出</h1><hr /><p>当我一开始使用 JavaScript 的模块时，我用过 <code>default</code> 关键字去导出一个单独的片段。它可能是模块中的一段定义，一个类，或是一个函数。</p><p>例如，这里有一个 <code>greeter</code> 模块，模块使用 <code>default</code> 关键字导出了 <code>Greeter</code> 类：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// greeter.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Greeter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  greet() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`Hello, <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>!`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而当我打算重构这个模块时，麻烦事来了。当原模块中的类被重命名之后，调用者的模块中类的名字并没有发生改变。</p><p>更糟糕的是，编辑器也不会提供被导入类名的自动补全。</p><p>我的结论是，默认导出并不能带来清晰易读的好处。所以我转向使用具名导出。</p><p>让我们先将 <code>Greeter</code> 类重构为具名的导出，然后再看看这样做带来的好处。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// greeter.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Greeter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  greet() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`Hello, <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用了具名导出后，编辑器可以很好地完成重命名工作：每当你修改了原类的名字后，所有调用者的模块中的类名都将被统一修改。</p><p>同时，自动补全也将提供导入的类名的建议。</p><p><img src="https://bebopfzj.oss-cn-hangzhou.aliyuncs.com/uPic/2020-03-10-YLOdBN.png" alt="编辑器的自动补全" /></p><p>所以，我的建议是：</p><blockquote><p><strong>优先使用具名模块导出，这样你可以在重构中受益，同时也能得到代码自动补全工呢的支持</strong></p></blockquote><p>_注意：当使用第三方的模块，比如 React、Lodash 等，通常情况下默认导入也能用。默认导入的名称会是一个常量，并且不会发生改变。例如：<code>React</code> 、__</p><h1 id="2-不要在导入时执行其他逻辑"><a class="markdownIt-Anchor" href="#2-不要在导入时执行其他逻辑"></a> 2. 不要在导入时执行其他逻辑</h1><hr /><p>在模块级别的定义域内定义函数、类、轻量对象和变量。模块可以导出其中的一部分，这就是全部了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Module-levle scope</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// myFunction Scope</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在模块级别的定义域内，不应该去做一些消耗资源的计算，例如解析 JSON，发起 HTTP 请求，读取本地存储等。</p><p>例如，下面的 <code>configuration</code> 模块从全局变量 <code>bigJsonString</code> 中解析了配置信息：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// configuration.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> configuration = &#123;</span><br><span class="line">  <span class="comment">// Bad</span></span><br><span class="line">  data: <span class="built_in">JSON</span>.parse(bigJsonString),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在模块级别的定义域中完成 <code>bigJsonString</code> 的解析是一个麻烦。当用户导入 <code>configuration</code> 时，对 <code>bigJsonString</code> 的解析将会立即开始：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bad: parsing happens when the module is imported</span></span><br><span class="line"><span class="keyword">import</span> &#123; configuration &#125; <span class="keyword">from</span> <span class="string">"configuration"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">AboutUs</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"&lt;p&gt;&#123;configuration.data.siteName&#125;&lt;/p&gt;"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从更高的层次来看，模块级别定义域的角色是去定义模块组件，导入依赖，并且导出公用组件：也就是所谓的<em>依赖项解析</em>。这应该和<em>运行时</em>的工作区分开，例如：解析 JSON，发起 request，处理事件。</p><p>让我们重构一下 <code>configuration</code> ，以便于可以延迟解析：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// configuration.js</span></span><br><span class="line"><span class="keyword">let</span> parsedData = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> configuration = &#123;</span><br><span class="line">  <span class="comment">// Good</span></span><br><span class="line">  <span class="keyword">get</span> data() &#123;</span><br><span class="line">    <span class="keyword">if</span> (parsedData === <span class="literal">null</span>) &#123;</span><br><span class="line">      parsedData = <span class="built_in">JSON</span>.parse(bigJsonString);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> parsedData;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>因为 <code>data</code> 属性已经被定义成了 <code>getter</code> ，所以直到用户访问 <code>configuration.data</code> 时，<code>bigJsonString</code> 才会被解析。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Good: JSON parsing doesn't happen when the module is imported</span></span><br><span class="line"><span class="keyword">import</span> &#123; configuration &#125; <span class="keyword">from</span> <span class="string">"configuration"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">AboutUs</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// JSON parsing happens now</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">"&lt;p&gt;&#123;confuguration.data.companyDescription&#125;&lt;/p&gt;"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用户会更清楚该在什么时候执行消耗资源的工作。用户也许决定在浏览器空闲时执行它们，也可能仅仅导入模块，但却因为一些原因而不去使用。</p><p>这可以使用户有机会进一步的优化浏览器性能：你可以参考 <a href="https://developers.google.com/web/tools/lighthouse/audits/time-to-interactive" target="_blank" rel="noopener">time to interactive</a>，<a href="https://web.dev/mainthread-work-breakdown/" target="_blank" rel="noopener">minimize main thread work</a>。</p><blockquote><p><strong>在导入模块时不应该自动执行消耗很多资源的工作，而是让用户去决定何时执行它们。</strong></p></blockquote><h1 id="3-支持高内聚的模块"><a class="markdownIt-Anchor" href="#3-支持高内聚的模块"></a> 3. 支持高内聚的模块</h1><hr /><p>内聚性描述了模块中的组件关联程度的高低。</p><p>在一个高内聚的模块中，函数、类、变量都有很紧密的关联性。它们组合起来，专注于完成一项任务。</p><p>下面的 <code>formatData</code> 就是高内聚的。因为其中的函数有很强的关联性，并且只专注于日期格式化这项功能：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// formatData.js</span></span><br><span class="line"><span class="keyword">const</span> MONTHS = &#123;</span><br><span class="line">  <span class="string">'January'</span>, <span class="string">'February'</span>, <span class="string">'March'</span>, <span class="string">'April'</span>, <span class="string">'May'</span>, <span class="string">'June'</span>, <span class="string">'July'</span>, <span class="string">'August'</span>, <span class="string">'September'</span>, <span class="string">'October'</span>, <span class="string">'November'</span>, <span class="string">'December'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ensureDataInstance</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> data === <span class="string">'string'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(date);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> date;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">formatDate</span>(<span class="params">date</span>) </span>&#123;</span><br><span class="line">  date = ensureDateInstance(date);</span><br><span class="line">  <span class="keyword">const</span> monthName = MONTHS[date.getMonth()];</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;monthName&#125;</span> <span class="subst">$&#123;date.getDate()&#125;</span>, <span class="subst">$&#123;date.getFullYear()&#125;</span>`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>formatDate()</code> ，<code>ensuerDateInstance()</code>，<code>MONTHS</code> 之间都关联的非常紧密。</p><p>删除 <code>MONTHS</code> ，或是 <code>ensureDateInstance()</code> 都将导致 <code>formatDate()</code> 函数的不可用：这就是高内聚的一个标志。</p><h2 id="低内聚模块的麻烦"><a class="markdownIt-Anchor" href="#低内聚模块的麻烦"></a> 低内聚模块的麻烦</h2><p>与之相对的，是低内聚模块。它包含了一些相互之间没啥关联的组件。</p><p>下面的 <code>utils</code> 米快包含了三个函数，它们分别执行不同的任务：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// utils.js</span></span><br><span class="line"><span class="keyword">import</span> cookies <span class="keyword">from</span> <span class="string">"cookies"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getRandomInRange</span>(<span class="params">start, end</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> start + <span class="built_in">Math</span>.floor((end - start) * <span class="built_in">Math</span>.random());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">pluralize</span>(<span class="params">itemName, count</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> count &gt; <span class="number">1</span> ? <span class="string">`<span class="subst">$&#123;itemName&#125;</span>s`</span> : itemName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">cookieExists</span>(<span class="params">cookieName</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> cookiesObject = cookie.parse(<span class="built_in">document</span>.cookie);</span><br><span class="line">  <span class="keyword">return</span> cookieName <span class="keyword">in</span> cookiesObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>getRandomInRange()</code> ，<code>pluralize()</code> ， <code>cookieExists()</code> 都执行了不同的任务：生成一个随机数，格式化字符串，检查 cookie 是否存在。</p><p>删除其中任何一个函数，都不会影响剩余函数的功能性：这就是低内聚的一个标志。</p><p>另外的，低内聚模块会迫使用户依赖于一些并不总是需要的模块，这会导致不必要的传递性依赖。</p><p>例如，<code>ShppingCartCount</code> 组件从 <code>utils</code> 模块导入了 <code>pluralize()</code> 函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ShoppingCartCount.jsx</span></span><br><span class="line"><span class="keyword">import</span> &#123; pluralize &#125; <span class="keyword">from</span> <span class="string">"utils"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">ShoppingCartCount</span>(<span class="params">&#123; count &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      Shopping cart has &#123;count&#125; &#123;pluralize(<span class="string">"product"</span>, count)&#125;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>当 <code>ShoppingCartCount</code> 模块仅仅只是需要使用 <code>utils</code> 模块中的 <code>pluralize()</code> 函数时，却会得到传递性的，对 <code>cookies</code> 模块的依赖。（ <code>cookie</code> 模块在 <code>utils</code> 模块中被导入了）</p><p>一个好的解决办法是，将低内聚的 <code>utils</code> 模块切分成多个高内聚模块：<code>utils/random</code>，<code>utils/stringFromat</code> ，<code>utils/cookies</code> 。</p><p>现在，如果 <code>ShoppingCard</code> 模块导入了 <code>utils/stringFormat</code> ，它将不会再会有对 <code>cookies</code> 模块的传递性依赖：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ShoppingCartCount.jsx</span></span><br><span class="line"><span class="keyword">import</span> &#123; pluralize &#125; <span class="keyword">from</span> <span class="string">"utils/stringFormat"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">ShoppingCartCount</span>(<span class="params">&#123; count &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Node</code> 的内建模块，例如 <code>fs</code>，<code>path</code>， <code>assert</code>，是最好的高内聚模块示例。</p><blockquote><p><strong>你应该写高内聚模块，这种模块中的函数、类、变量都关联紧密，并且执行着相同的任务。你可以通过将低内聚模块切分成多个高内聚模块来重构它。</strong></p></blockquote><h1 id="4-避免嵌套过深的依赖路径"><a class="markdownIt-Anchor" href="#4-避免嵌套过深的依赖路径"></a> 4. 避免嵌套过深的依赖路径</h1><hr /><p>我发现如果一个模块路径包含了一个，甚至多个相对父级路径时，就会变得难以理解：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; compareDates &#125; <span class="keyword">from</span> <span class="string">"../../date/compare"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; formatDate &#125; <span class="keyword">from</span> <span class="string">"../../date/format"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Use compareDates and formatDate</span></span><br></pre></td></tr></table></figure><p>通常情况下，含有一个相对父级路径并不会导致什么问题，但如果含有两个甚至多个的时候，就变得难以把握了。</p><p>这就是为什么我建议避免使用相对父级路径，而是使用绝对路径：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; compareDates &#125; <span class="keyword">from</span> <span class="string">"utils/date/compare"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; formatDate &#125; <span class="keyword">from</span> <span class="string">"utils/date/format"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Use compareDates and formatDate</span></span><br></pre></td></tr></table></figure><p>尽管有时候绝对路径写起来很长，但使用绝对路径可以让被导入的模块路径更加清晰。</p><p>为了缩短过长的绝对路径，你可以声明新的根目录。你可以使用诸如 <a href="https://github.com/tleunen/babel-plugin-module-resolver#readme" target="_blank" rel="noopener">babel-plugin-module-resolver</a> 这样的插件。</p><blockquote><p><strong>使用绝对路径，而不是长相对路径。</strong></p></blockquote><h1 id="结论"><a class="markdownIt-Anchor" href="#结论"></a> 结论</h1><hr /><p>JavaScript 可以很好地将你的应用分割成较小的、独立的块。</p><ul><li><p>通过使用具名导入而不是默认导入，当你导入具名组件后，你可以更轻松的重命名重构，并且编辑器也提供自动补全的建议。</p></li><li><p><code>import { myFunc } from 'myModule'</code> 的唯一作用应该只是导入 <code>myFunc</code> 模块。在 <code>myFunc</code> 模块的定义域中，应该只定义了内容较少的类、函数或是变量。</p></li><li><p>一个组件中应该包含多少个函数？这些组件间应该怎样相互关联？你应该编写高内聚模块：这些组件应该相互紧密关联，并肩完成共同的任务。</p></li><li><p>那种包含了过多父级目录 <code>../</code> 的路径是很难理解的，将其重构为绝对路径。</p></li></ul><p><em>你使用 JavaScript 模块的最佳实践是什么呢？</em></p>]]></content>
      
      
      <categories>
          
          <category> 翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模块 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>构建大厦的基础——模块化</title>
      <link href="/2020/03/09/%E6%A8%A1%E5%9D%97/"/>
      <url>/2020/03/09/%E6%A8%A1%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h1><hr /><p>模块化是构建大型应用的基础手段，它可以让代码变得更加易读，易于调试。很多框架作者鼓励用户编写插件来扩展框架功能，这些工作所依赖的，就是一个语言的模块化功能。</p><p>相较于 Python 清晰的模块化方案，JavaScript 则显得较为混乱。这主要是由于 JavaScript 早期“浏览器脚本”的定位导致的。社区等不及官方的解决方案，所以自己折腾了几套模块化方案。不过这个问题在 <code>ES6</code> 版本已经改善了很多。</p><h2 id="javascript"><a class="markdownIt-Anchor" href="#javascript"></a> JavaScript</h2><p>在 ES6 之前，JS 社区为了解决这个问题，提出了很多的模块加载方案。主要有 <code>CommonJS</code> 和 <code>AMD</code> 两种，前者使用与服务器，后者则用于浏览器。另外的，这两种模块都是 <code>运行时加载</code> 的，是非静态的。例如，一个典型的 <code>CommonJS</code> 标准的模块引入是这样写的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; hello, goodbye &#125; = <span class="built_in">require</span>(<span class="string">"base"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> _base = <span class="built_in">require</span>(<span class="string">"base"</span>);</span><br><span class="line"><span class="keyword">let</span> hello = _base.hello;</span><br><span class="line"><span class="keyword">let</span> goodbye = _base.goodbye;</span><br></pre></td></tr></table></figure><p>从运行的逻辑上来说，这实际上是先整体加载了一个 <code>base</code> 模块，生成一个对象，然后再从这个对象上读取 2 个方法，赋值给 <code>hello</code> 和 <code>goodbye</code> 。</p><p>这样做其实就是先把所有东西都拿过来，再挑出来有用的。与之相对的，<code>ES6</code> 提出的模块实现则是静态的。也就是说，你可以按需加载。一个典型的 <code>ES6</code> 加载是这样写的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; hello, goodbye &#125; <span class="keyword">from</span> <span class="string">"base"</span>;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="python"><a class="markdownIt-Anchor" href="#python"></a> Python</h2><p>Python 的模块化方案就没这么麻烦了。例如有如下的文件结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">myproject&#x2F;</span><br><span class="line">app.py</span><br><span class="line">tools&#x2F;</span><br><span class="line">__init__.py</span><br><span class="line">view.py</span><br><span class="line">db.py</span><br></pre></td></tr></table></figure><p>如果我们想在 <code>app.py</code> 文件下引入 <code>tools</code> 文件夹下的模块，我们可以这样写：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tools.view <span class="keyword">import</span> View</span><br><span class="line"><span class="keyword">from</span> tools.db <span class="keyword">import</span> db</span><br></pre></td></tr></table></figure><h1 id="javascript-模块"><a class="markdownIt-Anchor" href="#javascript-模块"></a> JavaScript 模块</h1><hr /><p>JS 的模块化方案主要分为 Node.js 采用的 <code>CommonJS</code> 和 ES6 提出的新方案。下面具体分析这两种方案</p><h2 id="commonjs-模块化方案"><a class="markdownIt-Anchor" href="#commonjs-模块化方案"></a> CommonJS 模块化方案</h2><p>Node 应用采用 <code>CommonJS</code> 的模块规范来构建。</p><p>这个规范主要有三个核心概念：</p><ul><li>每一个文件就是一个模块。模块内部的类、函数和变量都是私有的。</li><li>定义 <code>module</code> 变量，指代当前模块</li><li><code>module</code> 变量的 <code>exports</code> 属性指定导出的数据</li><li>使用 <code>require</code> 来<strong>整体</strong>载入模块</li></ul><p>事实上，在加载某个模块时，其实就是在加载那个模块的 <code>module.exports</code> 属性定义的数据。</p><p>如果我们有以下文件结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">myproject&#x2F;</span><br><span class="line">  app.js</span><br><span class="line">  tools&#x2F;</span><br><span class="line">  view.js</span><br><span class="line">  db.js</span><br></pre></td></tr></table></figure><p>我们在 <code>db.js</code> 文件内可能这样定义：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserDB</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  save(obj) &#123;</span><br><span class="line">    <span class="comment">// some code</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出前已经实例化了</span></span><br><span class="line"><span class="comment">// 当前你也可以在导入的文件中实例化，但是代码会麻烦一些</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="keyword">new</span> UserDB();</span><br></pre></td></tr></table></figure><p>那么，我们就需要在 <code>app.js</code> 文件中这样引入：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> User = <span class="built_in">require</span>(<span class="string">"./tools/db"</span>);</span><br></pre></td></tr></table></figure><p>另外的，为了简化写法，Node 中模块都有 <code>exports</code> 变量，指向 <code>module.exports</code> 。即：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> exports = <span class="built_in">module</span>.exports;</span><br></pre></td></tr></table></figure><p>这样你可以少写点单词，直接在 <code>exports</code> 上添加方法。不过需要注意的是，不要将 <code>exprots</code> 指向一个值，这样做会让它重新被赋值。</p><p>当然了，实际中用哪个还是由你自己决定的。</p><h2 id="es6-模块化方案"><a class="markdownIt-Anchor" href="#es6-模块化方案"></a> ES6 模块化方案</h2><p>ES6 使用 <code>export</code> 和 <code>import</code> 来导出、导入模块。</p><p>例如在上一节相同的文件结构下，我们在 <code>db.js</code> 文件内可能这样定义：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> hello = <span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Hello!"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> name = <span class="string">"Spike"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; hello, name &#125;;</span><br></pre></td></tr></table></figure><p>那么，我们就需要在 <code>app.js</code> 文件中这样引入：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; hello &#125; <span class="keyword">from</span> <span class="string">"./tools/db"</span>;</span><br></pre></td></tr></table></figure><p>不过这样做的话，意味着模块的使用者必须得知道要导入的方法名。所以你也可以使用 <code>export default</code> 来导出。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> hello = <span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Hello!"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> name = <span class="string">"Spike"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  hello,</span><br><span class="line">  name,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样，模块的使用者就可以自定义导入模块的名字了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sayHello <span class="keyword">from</span> <span class="string">"./tools/db"</span>;</span><br></pre></td></tr></table></figure><blockquote><p>注意，你可能无法运行 ES6 的例子。这是因为 Node 较旧的版本无法支持 ES6 语法。你可以使用 <code>Babel</code> 来解决这个问题。你可以参考这篇<a href="https://github.com/babel/example-node-server" target="_blank" rel="noopener">官方教程</a></p></blockquote><h1 id="python-模块"><a class="markdownIt-Anchor" href="#python-模块"></a> Python 模块</h1><hr /><h2 id="导入模块"><a class="markdownIt-Anchor" href="#导入模块"></a> 导入模块</h2><p>总的来说，模块封装了一组类或方法，以便于调用。在 Python 中，除了 <code>.py</code> 结尾的文件，还有 <code>.pyo .pyc .pyd .so .dll</code>等文件类型，都可以视为模块。</p><p>例如有如下目录结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">myprojecy&#x2F;</span><br><span class="line">app.py</span><br><span class="line">db.py</span><br><span class="line">tools&#x2F;</span><br><span class="line">view.py</span><br></pre></td></tr></table></figure><p>假如在 <code>db.py</code> 文件中有如下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Goodbye</span>:</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Goodbye'</span></span><br></pre></td></tr></table></figure><p>而在 <a href="http://view.py" target="_blank" rel="noopener">view.py</a> 中有如下代码：</p><p>假如在 <code>view.py</code> 中有如下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hello</span>:</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Hello World'</span></span><br></pre></td></tr></table></figure><p>那么如果你在 <code>app.py</code> 中需要导入<code>db.py</code> 和 <code>view.py</code> 时，那你就需要这样写：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 也可以写成 import Goodbye</span></span><br><span class="line"><span class="keyword">from</span> db <span class="keyword">import</span> Goodbye</span><br><span class="line"><span class="keyword">from</span> tools.view <span class="keyword">import</span> Hello</span><br></pre></td></tr></table></figure><h2 id="包package"><a class="markdownIt-Anchor" href="#包package"></a> 包（package）</h2><p>Python 有包这个概念。包中的多个模块构成了一个整体，这些模块都可以通过一个包来导入到其他代码中。简单来说，包是用来管理模块命名空间的，这可以避免模块名冲突。</p><p>一个文件夹如果想被 Python 解释器视作包的话，需要满足以下两个条件：</p><ul><li>文件夹中存在 <code>__init__.py</code> ，可为空</li><li>不能作为顶层模块来执行其中的文件</li></ul><p>如果你将你的项目组织成各种包，那么一个典型目录结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">myproject&#x2F;</span><br><span class="line">app.py</span><br><span class="line">tools&#x2F;</span><br><span class="line">__init__.py</span><br><span class="line">libs&#x2F;</span><br><span class="line">view.py</span><br><span class="line">db.py</span><br><span class="line">tools&#x2F;</span><br><span class="line">controller.py</span><br></pre></td></tr></table></figure><p>那么在导入这个包中的特定模块时，你需要这样做：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tools.libs.view <span class="keyword">as</span> view</span><br></pre></td></tr></table></figure><p>你可能需要在包中的模块导入兄弟模块中的代码，那么你就需要使用相对路径来导入。假如 <code>view.py</code> 文件中定义一个函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def hello() &#123;</span><br><span class="line">  print(<span class="string">'Hello World'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么在 <code>controller.py</code> 文件中，就需要这样导入。这被称为 <code>相对导入</code> ：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ..libs <span class="keyword">import</span> view</span><br><span class="line"></span><br><span class="line">view.hello()</span><br></pre></td></tr></table></figure><p>尽管你也可以使用绝对路径导入，但这样做不利于包的分发，所以不做介绍。</p><h2 id="细节概念"><a class="markdownIt-Anchor" href="#细节概念"></a> 细节概念</h2><h3 id="__init__py-文件"><a class="markdownIt-Anchor" href="#__init__py-文件"></a> __init__.py 文件</h3><p>这个文件用于组织包，它在模块加载时最先运行。</p><p>你可以在文件中做如下定义：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__all__ = [<span class="string">'view'</span>, <span class="string">'db'</span>]</span><br></pre></td></tr></table></figure><p>那么，当使用 <code>from module import *</code> 语句时，将会导入 <code>__all__</code> 中的所有模块。</p><p>另外的，你也可以使用这个文件，将分割成多个文件的模块粘合起来。例如有如下目录结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mymodule&#x2F;</span><br><span class="line">__init__.py</span><br><span class="line">a.py</span><br><span class="line">b.py</span><br></pre></td></tr></table></figure><p>那么，你可以在 <code>__init__.py</code> 文件中做如下定义：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> .a <span class="keyword">import</span> A</span><br><span class="line"><span class="keyword">from</span> .b <span class="keyword">import</span> B</span><br></pre></td></tr></table></figure><p>这样，这个包将变成一个单独的模块，你可以这样使用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> mymodule</span><br></pre></td></tr></table></figure><h3 id="sysmodules"><a class="markdownIt-Anchor" href="#sysmodules"></a> sys.modules</h3><p>这是一个字典。它将模块名称映射到已加载的模块上。在第一次导入时，<code>sys.modules</code> 将记录该模块，待第二次导入时，解释器会直接在字典中查找模块并导入，以加快运行速度。</p><h3 id="入口程序"><a class="markdownIt-Anchor" href="#入口程序"></a> 入口程序</h3><p>简单来说，Python 是一个脚本语言。解释器在运行它时，是从脚本第一行开始运行的，并没有严格的入口。</p><p>而文件有一个内置变量 <code>__name__</code> ，它保存着包的结构。例如有如下文件结构的包：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">libs&#x2F;</span><br><span class="line">tools&#x2F;</span><br><span class="line">view.py</span><br></pre></td></tr></table></figure><p>那么，<code>view.py</code> 文件的 <code>__name__</code> 就是 <code>libs.tools.view</code> 。</p><p>而当直接运行 <code>view.py</code> 文件时，它的 <code>__name__</code> 为 <code>__main__</code> ，即所谓的入口程序。</p>]]></content>
      
      
      <categories>
          
          <category> 语言特性 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模块 </tag>
            
            <tag> ES6 </tag>
            
            <tag> CommonJS </tag>
            
            <tag> Node.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从生成器进化为协程——以列表推导为引子</title>
      <link href="/2020/03/08/%E5%8D%8F%E7%A8%8B/"/>
      <url>/2020/03/08/%E5%8D%8F%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="从列表推导开始"><a class="markdownIt-Anchor" href="#从列表推导开始"></a> 从列表推导开始</h1><hr /><p>Python 有一种被称为 <code>列表推导</code> 的特性，它可以用来快速的构建列表（list）。下面是一个简单的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">l = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">[str(i) <span class="keyword">for</span> i <span class="keyword">in</span> l]<span class="comment"># ['1', '2', '3']</span></span><br></pre></td></tr></table></figure><p>这个概念叫做<code>推导式</code>。它的作用是以一个数据序列为基础，来构建另一个新的数据序列。</p><p>在 Python 中，除了列表推导，你还可以使用 <code>字典（dict）推导</code> 和 <code>集合（set）推导</code> 。下面是一些示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">names = [<span class="string">'Dutch'</span>, <span class="string">'Hosea'</span>, <span class="string">'Arthur'</span>, <span class="string">'John'</span>]</span><br><span class="line">suits = [<span class="string">'Spade'</span>, <span class="string">'Heart'</span>, <span class="string">'Diamond'</span>, <span class="string">'Club'</span>]</span><br><span class="line"></span><br><span class="line">[(name, suit) <span class="keyword">for</span> name <span class="keyword">in</span> names <span class="keyword">for</span> suit <span class="keyword">in</span> suits]</span><br><span class="line"></span><br><span class="line">[(name, suit) <span class="keyword">for</span> name, suit <span class="keyword">in</span> zip(names, suits)]</span><br><span class="line"><span class="comment"># [('Dutch', 'Spade'), ('Hosea', 'Heart'), ('Arthur', 'Diamond'), ('John', 'Club')]</span></span><br></pre></td></tr></table></figure><p>第一种列表推导，会使用 <code>names</code> 中的每一个元素去依次和 <code>suits</code> 中的每一个元素相对应。因为产出元素过多，所以就不详细写出了。</p><p>第二种列表推导使用了 <code>zip</code> 函数。这个函数接收可迭代对象为参数，将对象中对应的元素打包成元组。如果你期望从多个数据序列中一一对应的构造新数据序列时，你将会经常的用到这个函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[(name, suit) <span class="keyword">for</span> name <span class="keyword">in</span> names <span class="keyword">for</span> suit <span class="keyword">in</span> suits <span class="keyword">if</span> name == <span class="string">'Arthur'</span>]</span><br><span class="line"><span class="comment"># [('Arthur', 'Spade'), ('Arthur', 'Heart'), ('Arthur', 'Diamond'), ('Arthur', 'Club')]</span></span><br></pre></td></tr></table></figure><p>上面这个例子是在列表推导中使用了 <code>if</code> 语句。这样可以在构建列表前根据需要，剔除部分数据。</p><p>你也可以将这个例子改写为使用高阶函数来实现，但可读性绝壁比不上列表推导。</p><a id="more"></a><h2 id="字典推导"><a class="markdownIt-Anchor" href="#字典推导"></a> 字典推导</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;name: suit <span class="keyword">for</span> name, suit <span class="keyword">in</span> zip(names, suits)&#125;</span><br><span class="line"><span class="comment"># &#123;'Dutch': 'Spade', 'Hosea': 'Heart', 'Arthur': 'Diamond', 'John': 'Club'&#125;</span></span><br></pre></td></tr></table></figure><p>上面的这个例子是字典推导，被迭代对象必须是以键值对为元素的可迭代对象。</p><h2 id="集合推导"><a class="markdownIt-Anchor" href="#集合推导"></a> 集合推导</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> unicodedata <span class="keyword">import</span> name</span><br><span class="line"></span><br><span class="line">&#123;chr(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">32</span>, <span class="number">256</span>) <span class="keyword">if</span> <span class="string">'SIGN'</span> <span class="keyword">in</span> name(chr(i), <span class="string">''</span>)&#125;</span><br><span class="line"><span class="comment"># &#123;'#', '$', '%', '+', '&lt;', '=', '&gt;', '¢', '£', '¤', '¥', '§', '©', '¬', '®', '°', '±', 'µ', '¶', '×', '÷'&#125;</span></span><br></pre></td></tr></table></figure><p>这个例子来源于《流畅的 Python》。将可迭代对象构建为集合后，你将可以方便的使用集合的各种运算来实现你的逻辑。</p><h1 id="可迭代对象与迭代器"><a class="markdownIt-Anchor" href="#可迭代对象与迭代器"></a> 可迭代对象与迭代器</h1><hr /><p>为什么要花这么大的篇幅来讲 <code>推导式</code> ？一方面是因为这东西实在是太好用了，另一方面就是为了要引出这个核心概念：<code>可迭代对象</code>。</p><p>从使用上来说，这种对象可以被 <code>for</code> 循环来使用。从实现上简单来说，<code>可迭代对象</code> 实现了 <code>__iter__</code> 方法，用来返回一个迭代器。</p><h2 id="iter-函数"><a class="markdownIt-Anchor" href="#iter-函数"></a> iter 函数</h2><p>序列就是一种 <code>可迭代对象</code>。解释器在调用可迭代对象 x 时，实际上是调用了 <code>iter(x)</code>。这个函数的逻辑可大致分析如下：</p><ul><li>检查对象是否实现了 <code>__iter__</code> 方法。如果实现了，则调用，从而获取一个迭代器。</li><li>如果第一步失败，那么就检查对象是否实现了 <code>__gititem__</code> 方法，如果实现了，解释器将创建一个迭代器，尝试从索引为 0 的元素开始迭代。</li><li>如果第二步失败，那么抛出 <code>TypeError</code> 异常。</li></ul><p>进一步的，<code>iter</code> 函数还有一个用法，就是传入两个参数。第一个参数是函数或可调用对象（实现了 <code>__call__</code> 方法的），且不可有参数，用于不断调用来产出值。第二个参数是哨符，当可调用对象返回这个值时，迭代器将抛出 <code>StopIteration</code> 异常，但不产出哨符值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">  <span class="keyword">return</span> randint(<span class="number">1</span>, <span class="number">6</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> roll <span class="keyword">in</span> iter(func, <span class="number">3</span>):</span><br><span class="line">  print(roll)</span><br></pre></td></tr></table></figure><p>如果你需要检查一个不断产出值的函数的返回值时，你将很需要 <code>iter</code> 函数的这个用法。</p><h2 id="协议与鸭子类型"><a class="markdownIt-Anchor" href="#协议与鸭子类型"></a> 协议与鸭子类型</h2><p>事实上，<code>iter</code> 函数的行为暗示了 Python 中一个重要的概念：<code>鸭子类型</code> 。</p><p>在 Python 中，创建一种类型时，并不需要使用继承，只要实现符合那种类型的协议的方法就可以了。这就是所谓的鸭子类型。</p><blockquote><p>当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子。</p></blockquote><p>在面向对象编程中，协议是非正式的接口。它并不定义在代码中，而是定义在文档中。只要你实现了特定类型协议规定的方法，你就可以像使用原生类型一样的使用自定义类型。</p><p>例如上面所说的 <code>可迭代对象</code> 。如果实现了能返回迭代器的 <code>__iter__</code> ，那么它就是可迭代对象。</p><p>当然了，结合上面 <code>iter</code> 函数逻辑的分析，你会发现，这种协议非常宽松。换句话说，即时一个对象不实现 <code>__iter__</code> 方法，而是实现 <code>__getitem__</code> 方法，Python 也可以像调用一个可迭代对象一样的调用它。</p><p>总的来说，Python 给出了自定义类型的指导，但并不会阻止你干坏事，一切都得靠自觉。（划掉）</p><h2 id="可迭代对象与迭代器-2"><a class="markdownIt-Anchor" href="#可迭代对象与迭代器-2"></a> 可迭代对象与迭代器</h2><p>可迭代对象与迭代器并不是同一件东西，尽管他们在逻辑上非常相似。</p><p>可迭代对象指的是实现了 <code>__iter__</code> 方法。在调用这个方法时，将会产出一个迭代器。</p><p>迭代器指的是实现了 <code>__iter__</code> 和 <code>__next__</code> 两个方法。前面的方法用于返回迭代器本身，后面的方法用于返回单个元素。</p><blockquote><p>从使用上来说，你可以在可迭代对象中同时实现 <code>__next__</code> 方法，这样可迭代对象会变成自身的迭代器。但我们并不建议你这样做，因为这是常见的反模式。</p></blockquote><h1 id="生成器"><a class="markdownIt-Anchor" href="#生成器"></a> 生成器</h1><hr /><p>当一个函数中存在 <code>yield</code> 关键字时，它就是生成器函数。生成器函数在被调用时会产出一个生成器对象。这里的一个细节是，生成器对象会产出值，而非返回值。也就是说，生成器对象并非在一开始就将所有数据都写入了内存，而是在需要的时候才生成它们。</p><p>在定义生成器函数时，一个建议是在函数名称中加上 <code>gen</code> 前缀。当然你也可以不遵守。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_name</span><span class="params">()</span>:</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'Dutch'</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'Hosea'</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'Arthur'</span></span><br><span class="line"></span><br><span class="line">g = gen_name()</span><br><span class="line">next(g)<span class="comment"># 'Dutch'</span></span><br><span class="line">next(g)<span class="comment"># 'Hosea'</span></span><br><span class="line">next(g)<span class="comment"># 'Arthur'</span></span><br><span class="line">next(g) <span class="comment"># StopIteration</span></span><br></pre></td></tr></table></figure><p>生成器函数实际上是一种惰性求值。这在处理占用过多内存的数据时会非常有用，可以避免消耗大量内存来存储暂时还用不到的数据。</p><h2 id="生成器表达式"><a class="markdownIt-Anchor" href="#生成器表达式"></a> 生成器表达式</h2><p>就形式上来说，生成器表达式和列表推导很相似。不过前者产出的是生成器，而后者则产出列表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">res = (i*<span class="number">3</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>))</span><br><span class="line">res</span><br><span class="line"><span class="comment"># &lt;generator object &lt;genexpr&gt; at 0x7fec2010eed0&gt;</span></span><br><span class="line">next(res)<span class="comment"># 0</span></span><br><span class="line">next(res)<span class="comment"># 3</span></span><br><span class="line">next(res)<span class="comment"># 9</span></span><br><span class="line">next(res)<span class="comment"># 12</span></span><br><span class="line">next(res)<span class="comment"># StopIteration</span></span><br></pre></td></tr></table></figure><p>很明显，生成器表达式是生成器函数的简洁语法。为了简洁，一个很直观的缺点就是你无法写太复杂的逻辑，但优点是代码非常易读。所以在使用中，需要根据实际情况来取舍。</p><p>除了很多 Python 内置的生成器函数之外，<code>itertools</code> 模块也提供了许多异常实用的函数。你可以通过<a href="%5Bhttps://medium.com/@xiaoqinglin2018/%E6%A0%87%E5%87%86%E5%BA%93%E4%B8%AD%E7%9A%84%E7%94%9F%E6%88%90%E5%99%A8%E5%87%BD%E6%95%B0-itertools%E6%A8%A1%E5%9D%97%E8%AF%A6%E8%A7%A3-93d28d3aa272%5D(https://medium.com/@xiaoqinglin2018/%E6%A0%87%E5%87%86%E5%BA%93%E4%B8%AD%E7%9A%84%E7%94%9F%E6%88%90%E5%99%A8%E5%87%BD%E6%95%B0-itertools%E6%A8%A1%E5%9D%97%E8%AF%A6%E8%A7%A3-93d28d3aa272)">这篇文章</a>详细了解。</p><h1 id="协程"><a class="markdownIt-Anchor" href="#协程"></a> 协程</h1><hr /><h2 id="进程-线程"><a class="markdownIt-Anchor" href="#进程-线程"></a> 进程、线程</h2><p>关于进程和线程，一个比较好的理解是：</p><blockquote><p>进程和线程都是一个时间段的描述，是 CPU 工作时间段的描述</p></blockquote><p>CPU 的工作速度是很快的，而电脑中的其他设备速度却是很慢的。CPU 不可能依次的等待、执行这些设备发送的请求，所以 CPU 会轮流的执行这些任务。每当 CPU 从一个旧任务切换到新任务时，它会保存旧任务的上下文，然后加载新任务的上下文，进而执行新任务。</p><p>这样的一段加载，执行，保存行为的时间总和，就是 <code>进程</code> 。</p><p>而每个任务都是由一段程序定义的。程序中不可能是一句代码撸到底的，而是由众多的分支、段落等组合而成的。我们将这些分支、段落称为 <code>线程</code>。它们会共享上下文。</p><p>一个例子是，你启动了 QQ，那么这就是一个进程。你在聊天框内输入表情包并回车，QQ 就会起一个线程来发送这个表情包。另外的，用于接收他人发送的表情包也是一个线程。</p><h2 id="gil"><a class="markdownIt-Anchor" href="#gil"></a> GIL</h2><p>一个重要的事实是，CPython 解释器本身不是线程安全的，所以有全局解释器锁（GIL）。因此，同一时间内的一个进程内，只能有一个线程执行 Python 字节码。</p><p>不过，标准库中执行阻塞型 I/O 操作的函数，在等待操作系统返回时，都会释放 GIL。例如在等待网络返回时。在这个意义上，我们可以使用多线程。</p><h2 id="用作协程的生成器逻辑"><a class="markdownIt-Anchor" href="#用作协程的生成器逻辑"></a> 用作协程的生成器逻辑</h2><p>下面是一个简单的协程：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(a)</span>:</span></span><br><span class="line">  print(<span class="string">'协程激活，参数值 a 为：'</span>, a)</span><br><span class="line">  b = <span class="keyword">yield</span> a</span><br><span class="line">  print(<span class="string">'赋值完成，b 为：'</span>, b)</span><br><span class="line"></span><br><span class="line">f = func(<span class="number">10</span>)</span><br><span class="line">next(f)<span class="comment"># 协程激活，参数值 a 为：10</span></span><br><span class="line">next(f)<span class="comment"># 赋值完成，b 为：10</span></span><br><span class="line"><span class="comment"># StopIteration</span></span><br></pre></td></tr></table></figure><p>一个细节是，赋值语句 <code>b = yield a</code> 右边的语句将会先执行，输出一个 a 值。等到第二次调用 <code>next</code> 函数时，才会将值赋给 b ，并继续执行下面的代码。事实上，这种行为方式就是异步编程的基础。</p><p>协程激活的意思是，代码执行到第一个 <code>yield</code> 语句处。此时产出了第一个值，但并未将值赋给等号左边的变量。</p><p>下面是一个使用协程计算均值的例子。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">average</span><span class="params">()</span>:</span></span><br><span class="line">  total = <span class="number">0</span></span><br><span class="line">  count = <span class="number">0</span></span><br><span class="line">  average = <span class="literal">None</span></span><br><span class="line">  <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    total += <span class="keyword">yield</span> average</span><br><span class="line">    count += <span class="number">1</span></span><br><span class="line">    average = total / count</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用函数获得生成器对象</span></span><br><span class="line">avg = average()</span><br><span class="line">next(avg)</span><br><span class="line">avg.send(<span class="number">1</span>)<span class="comment"># 1.0</span></span><br><span class="line">avg.send(<span class="number">3</span>)<span class="comment"># 2.0</span></span><br><span class="line">avg.close()</span><br><span class="line">avg.send(<span class="number">4</span>)<span class="comment"># StopIteration</span></span><br></pre></td></tr></table></figure><p>获取到生成器对象后，调用 <code>next(avg)</code>，程序将执行 <code>yield average</code> 并在此处暂停（注意，值并未赋给 total）。而第一个产出值是 <code>None</code> ，所以不会出现在控制台。</p><p>接着，使用 <code>avg.send(1)</code> 发送数据后，<code>total</code> 将会被赋值为 1，进而执行下面的代码。当再次执行到 <code>yield average</code> 时，将会返回计算好的平均值。</p><p>总的来说，<code>yield</code> 一方面返回其右边的表达式的值，另一方面接收 <code>.send()</code> 函数传递进来的值。</p><p>另外的，你也可以使用 <code>generator.throw(exc_type, [, exc_value[, tracrback]])</code> 来让生成器在暂停的 <code>yield</code> 表达式处抛出指定异常</p><h2 id="预激协程的装饰器"><a class="markdownIt-Anchor" href="#预激协程的装饰器"></a> 预激协程的装饰器</h2><p>因为每次执行装饰器之前，都需要调用 <code>next</code> 方法来激活协程。引用装饰器的知识，我们可以很容易的构建一个预激协程的装饰器。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">star_coroutine</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">  @wraps(func)</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">worker</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">    _ = func(*args, **kwargs)</span><br><span class="line">    next(_)</span><br><span class="line">    <span class="keyword">return</span> _</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> workers</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 语言特性 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iterable </tag>
            
            <tag> 迭代器 </tag>
            
            <tag> 生成器 </tag>
            
            <tag> 协程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>闭包与装饰器——从变量的作用域说起</title>
      <link href="/2020/03/07/%E9%97%AD%E5%8C%85%E4%B8%8E%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
      <url>/2020/03/07/%E9%97%AD%E5%8C%85%E4%B8%8E%E8%A3%85%E9%A5%B0%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="变量与变量的作用域"><a class="markdownIt-Anchor" href="#变量与变量的作用域"></a> 变量与变量的作用域</h1><hr /><p>计算机语言中的变量（Variable）这一概念来源于数学，它是一个存储地址的映射。这个存储地址中通常包含了一段数据或一些抽象信息。你可以使用变量名来方便的引用存储值。</p><p>提到变量，就不得不提到 <code>作用域</code> 这个概念了。</p><p>实际上，作用域指的是一段计算机程序。在这段程序代码中，变量名与存储地址的映射关系一直保持有效。换句话说，作用域决定了当前程序是否能够访问到某个变量的值。</p><p>作用域的解析规则在不同的编程语言中都可能不相同。</p><p>作用域分为 <code>静态作用域</code> 和 <code>动态作用域</code> 。前者也叫做 <code>词法作用域</code> 。下面分析一下这两种作用域的区别。</p><a id="more"></a><h2 id="词法作用域"><a class="markdownIt-Anchor" href="#词法作用域"></a> 词法作用域</h2><p>采用词法作用域的变量被称为 <code>词法变量</code>。词法变量在编译时就会被确定，它的作用域可能是一个函数或者是一段代码，变量在这个区域外将无法访问。比如下面这个 JavaScript 的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> nameF = <span class="string">"Spike"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> nameS = <span class="string">"Shroud"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func();</span><br><span class="line"><span class="built_in">console</span>.log(nameF); <span class="comment">// Spike</span></span><br><span class="line"><span class="built_in">console</span>.log(nameS); <span class="comment">// ReferenceError: nameS is not defined</span></span><br></pre></td></tr></table></figure><h2 id="动态作用域"><a class="markdownIt-Anchor" href="#动态作用域"></a> 动态作用域</h2><p>采用动态作用域的变量被称为 <code>动态变量</code>。只要程序在执行的时候定义了一个变量，那么该变量将持续存在，直到代码段执行结束。比如下面这段 Shell 脚本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">name1="Spike"</span><br><span class="line"></span><br><span class="line">function func() &#123;</span><br><span class="line">    name2="Shroud"</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func;</span><br><span class="line">printf $name1# Spike</span><br><span class="line">printf $name2# Shroud</span><br></pre></td></tr></table></figure><h1 id="闭包"><a class="markdownIt-Anchor" href="#闭包"></a> 闭包</h1><hr /><p>闭包指的是一个函数，这个函数持有外部的环境变量。即使外部的作用域失效了，在这个函数中，依然留存有一份副本。</p><p>为了理解这个概念，我们设想一个使用场景：计算平均值。在某些时候，我们可能没办法一次性获取到所有的值，所以我们需要一个可以持续传入值的函数，它的返回值就是前面输入的所有值的平均值。下面是 Python 的实现，为了方便，将使用写在一起了。你也可以将其改写为 JavaScript 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_avg</span><span class="params">()</span>:</span></span><br><span class="line">  numbers = []</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">average</span><span class="params">(num)</span>:</span></span><br><span class="line">    numbers.append(num)</span><br><span class="line">    <span class="keyword">return</span> sum(numbers) / len(numbers)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> average</span><br><span class="line"></span><br><span class="line"><span class="comment"># avg = make_age()</span></span><br><span class="line"><span class="comment"># avg=&gt;  &lt;function __main__.avg.&lt;locals&gt;.average(num)&gt;</span></span><br><span class="line"><span class="comment"># avg(1)=&gt;  1.0</span></span><br><span class="line"><span class="comment"># avg(2)=&gt;  1.5</span></span><br></pre></td></tr></table></figure><p>你可以看到，<code>count</code>这个函数记住了它外部的 <code>numbers</code> 列表。每当传入一个新值时，就会返回计算好的平均值。假如你这样定义 <code>count</code>函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">average</span><span class="params">(num)</span>:</span></span><br><span class="line">  numbers = []</span><br><span class="line">  numbers.append(num)</span><br><span class="line">  <span class="keyword">return</span> sum(numbers) / len(numbers)</span><br><span class="line"></span><br><span class="line"><span class="comment"># average=&gt;  &lt;function __main__.average(num)&gt;</span></span><br><span class="line"><span class="comment"># average(1)=&gt;  1.0</span></span><br><span class="line"><span class="comment"># average(2)=&gt;  2.0</span></span><br></pre></td></tr></table></figure><p>这个结果是因为函数执行完成后，其内部的变量将会被销毁。列表将在 <code>count</code>函数每次执行时重新创建，所以它没办法记住先前传入的值。</p><p>当然，就 Python 来说，我们也可以对这个计算均值的函数进行一下改造。</p><p>因为没必要存储所有的值，对我们来说，核心信息是当前的总值和数字数量，所以我们可以这样改写：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_age</span><span class="params">()</span>:</span></span><br><span class="line">  count = <span class="number">0</span></span><br><span class="line">  total = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">average</span><span class="params">(num)</span>:</span></span><br><span class="line">    <span class="comment"># 将变量标记为自由变量</span></span><br><span class="line">    <span class="keyword">nonlocal</span> count, total</span><br><span class="line">    count += <span class="number">1</span></span><br><span class="line">    total += num</span><br><span class="line">    <span class="keyword">return</span> total / count</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> average</span><br></pre></td></tr></table></figure><p>对数字、字符串、元组等不可变类型来说，如果你在函数 <code>average</code>内重新赋值的话，其实是会隐式的创建局部变量。所以我们需要使用 <code>nonlocal</code> 关键字来将其声明为自由变量。</p><h1 id="一等函数"><a class="markdownIt-Anchor" href="#一等函数"></a> 一等函数</h1><hr /><p>在 Python 中，函数是一等对象。在编程语言理论中，一等对象的定义是这样的：</p><ul><li>在运行时创建</li><li>能赋值给变量或其他数据结构中的元素</li><li>能作为参数传给函数</li><li>能作为函数的返回值</li></ul><p>这是函数式编程的基础。比如下面这个简单应用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">result = map(<span class="keyword">lambda</span> n: n+<span class="number">1</span>, numbers)</span><br><span class="line">list(result)<span class="comment"># [2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure><p>我们传入了一个匿名函数，它的作用是对后面的列表中的每个元素依次加 1。当然，我们也可以将其改写为普通的样式，这样的可读性也许会更高：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plus_one</span><span class="params">(num)</span>:</span></span><br><span class="line">  <span class="keyword">return</span> num + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">result = map(plus_one, numebrs)</span><br><span class="line">list(result)<span class="comment"># [2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure><h1 id="装饰器"><a class="markdownIt-Anchor" href="#装饰器"></a> 装饰器</h1><hr /><p>装饰器被用于在源码中“标记”函数，它的作用是增加函数的功能。在实际开发中，我们经常使用装饰器来执行一些公共逻辑，以便于让代码更加简单易读。</p><p>我们可以自定义一个装饰器：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_user_name</span><span class="params">(func)</span>:</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">worker</span><span class="params">(*args)</span>:</span></span><br><span class="line">    print(func.__name__)</span><br><span class="line">    func(*args)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> worker</span><br><span class="line"></span><br><span class="line"><span class="meta">@print_user_name</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">average</span><span class="params">(numbers)</span>:</span></span><br><span class="line">  numbers = list(numbers)</span><br><span class="line">  print(sum(numbers) / len(numbers))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">average([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="comment"># average</span></span><br><span class="line"><span class="comment"># 2.0</span></span><br></pre></td></tr></table></figure><p>实际上，这段代码等价于：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">average = print_user_name(average)</span><br><span class="line"><span class="comment"># average</span></span><br><span class="line"><span class="comment"># 2.0</span></span><br></pre></td></tr></table></figure><p>从装饰器的代码也可以看出来。外层的函数接收了函数，由内层函数进行具体的工作。完成之后，使用被装饰函数的参数来调用那个函数。</p><p>另外的，你需要注意，我们传入的是 <code>average</code> 而不是 <code>average()</code>。后者使用了调用符号，也就是说，后者并不是一个指代函数的变量，而是函数的产出值。</p><p>不过，这个装饰器还是有些缺陷，比如如果执行这样的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">average.__name__</span><br><span class="line"><span class="comment"># 'worker'</span></span><br></pre></td></tr></table></figure><p>也就是说，装饰器遮盖了原函数的 <code>__name__</code> 和 <code>__doc__</code> 属性。另外的，函数还不能接收关键字参数。为了解决这个问题，我们可以使用 <code>functools</code> 包来改写装饰器函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_user_name</span><span class="params">(func)</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="meta">  @functools.wraps(func)</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">worker</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">    print(func.__name__)</span><br><span class="line">    func(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> worker</span><br></pre></td></tr></table></figure><h2 id="有参装饰器"><a class="markdownIt-Anchor" href="#有参装饰器"></a> 有参装饰器</h2><p>在实际使用中，一个强需求是让装饰器接收参数，以便于更好的执行一些逻辑。但目前定义的装饰器都不接受任何的参数。为了解决这个问题，我们可以定义一个装饰器工厂函数，来产出装饰器。由工厂函数接收装饰器的参数，原始函数的参数依旧由装饰器内的闭包来接收。这样便完美的解决了问题：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_user_name</span><span class="params">(name)</span>:</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">decorate</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">    @functools.wraps(func)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">worker</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">      print(<span class="string">'function name: '</span>, func.__name__)</span><br><span class="line">      print(<span class="string">'decorate name: '</span>, name)</span><br><span class="line">      func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> worker</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> decorate</span><br></pre></td></tr></table></figure><p>外层的 <code>print_user_name</code> 函数作为装饰器工厂函数，返回了 <code>decorate</code>装饰器函数。内层的 <code>decorate</code> 函数接收函数，装饰器里的闭包 <code>worker</code> 则接收原函数的参数。</p><p>第一句 <code>return worker</code> 返回的是装饰器内部的闭包，这样 <code>woker</code> 将一直存储着外部的变量。在这里就是 <code>func</code> ，被装饰的函数。</p><p>第二句 <code>return decorate</code> 返回了装饰器。</p><p>你可以这样使用这个装饰器：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@print_user_name('Spike')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">average</span><span class="params">(numbers)</span>:</span></span><br><span class="line">  numbers = list(numbers)</span><br><span class="line">  print(sum(numbers) / len(numbers))</span><br><span class="line"></span><br><span class="line">average([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="comment"># function name:  average</span></span><br><span class="line"><span class="comment"># decorate name:  Spike</span></span><br><span class="line"><span class="comment"># 2.0</span></span><br></pre></td></tr></table></figure><p>你可能会迷惑装饰器与闭包间的关系。那么我们将最开始的计算平均值的函数删减一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_avg</span><span class="params">(old)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">average</span><span class="params">(num)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> num + old</span><br><span class="line">  <span class="keyword">return</span> average</span><br><span class="line"></span><br><span class="line">avg = make_avg(<span class="number">1</span>)</span><br><span class="line">avg(<span class="number">2</span>)<span class="comment"># 3</span></span><br></pre></td></tr></table></figure><p>事实上，改写完后，形式上已经和装饰器函数非常相似了。唯一不同的是，装饰器函数应用了 <code>一等函数</code> 这个特性，将被装饰函数当做参数传进去了。</p><p>总之，装饰器的写法实质上就是一种语法糖。你也可以在 JavaScript 中这样写，尽管没啥意义，因为写出来更难看了（划掉）</p><h1 id="单分派泛函数"><a class="markdownIt-Anchor" href="#单分派泛函数"></a> 单分派泛函数</h1><hr /><p>在这里我们介绍一个非常实用的装饰器：<code>singledispatch</code></p><p>这个装饰器的意义是，将多个函数绑在一起，组成一个泛函数。被装饰的函数会根据第一个参数的类型来调用不同的函数。也就是低配版的重载。</p><p>这样做的意义是，你可能写了一个功能性的函数，它的作用是接收某些原始值，然后产出经过处理的新值。在这种情景下， 你很容易需要根据参数的不同，来执行不同的逻辑。</p><p>一个简单的解决办法是使用 <code>if/elif/else</code> 的组合，来调用不同的函数。但这样做的问题是，随着需求的增加，这个处理参数的函数将会变得十分巨大，它也将与各个专门的处理函数耦合的非常紧密。为了解决这个问题，你就需要这个装饰器了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> singledispatch</span><br><span class="line"></span><br><span class="line"><span class="meta">@singledispatch</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(name)</span>:</span></span><br><span class="line">  print(<span class="string">'Hello, '</span>, name)</span><br><span class="line"></span><br><span class="line"><span class="meta">@func.register(int)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_</span><span class="params">(number)</span>:</span></span><br><span class="line">  print(<span class="string">'Result is '</span>, number + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@func.register(tuple)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_</span><span class="params">(seq)</span>:</span></span><br><span class="line">  print(<span class="string">'List comprehension: '</span>, [i+<span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> seq])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func(<span class="string">'Spike'</span>)<span class="comment"># Hello, Spike</span></span><br><span class="line">func(<span class="number">1</span>)<span class="comment"># 2</span></span><br><span class="line">func((<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))<span class="comment"># List comprehension: [2, 3, 4]</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 语言特性 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 闭包 </tag>
            
            <tag> 作用域 </tag>
            
            <tag> 装饰器 </tag>
            
            <tag> 一等函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于我，关于本站的一些碎碎念</title>
      <link href="/2020/03/06/top/"/>
      <url>/2020/03/06/top/</url>
      
        <content type="html"><![CDATA[<ul><li>正常人，有头发，不穿格子衫</li><li>本科材料，半路出家的 Web 程序员</li><li>自顶向下生长的开发技能树</li><li>最近想要学习算法和 Android 开发</li><li>会弹吉他，但是完全看不懂五线谱</li><li>想把头发染成蓝色的，但是被价格劝退</li><li>steam 喜加一党，开放世界游戏党，Minecraft 挖矿平地爱好者，被铁拳锤爆的退坑安娜玩家</li><li>喜欢村上春树的小说，忠实的 Kindle 泡面用户</li><li>Windows / MacOS 双修，但其实更希望完全使用 Linux，因为 Ubuntu 有好看的主题（划掉）</li></ul><p>其实折腾博客很久了，但一直没输出什么像样的文章。很多笔记或者想法都是保存在本地自娱自乐。当然一方面是因为懒，但主要还是因为没做出什么像样的东西出来。毕竟总是觉得手头做的这些东西根本不值得写成文章分享出去。</p><p>后来在微博上读了一篇工业聚的<a href="https://www.weibo.com/islucifier?is_all=1#_0" target="_blank" rel="noopener">文章</a>。</p><blockquote><p>然而实际上，不管是开源还是 TS，它们其实是渐进的、有层次的，呈现的不是非黑即白，而是一段光谱。</p><p>…</p><p>你可以随意开源，即便跑不起来，即便没有单元测试，即便你连什么是代码覆盖率都不知道。</p><p>你可以去写 TypeScript，即便仅仅是把 .js 后缀改成 .ts。对刚开始的你而言，不改一行代码，你也已足够 TypeScript。</p><p>你可以在光谱的最左端停留，这是你的起点。等你变强之后，你可以提升你的项目的完成度和质量，往光谱的右侧移动。</p><p>每个人都需要经历起步阶段。所有项目都有希望变得更好，不管当前处于哪个阶段。</p><p>…</p><p>希望你能成长起来。</p></blockquote><p>深受鼓舞，于是决定重新开始。</p><p>大概就是这样。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>当我们谈跨域的时候,我们谈些什么</title>
      <link href="/2020/01/17/%E5%BD%93%E6%88%91%E4%BB%AC%E8%B0%88%E8%B7%A8%E5%9F%9F%E7%9A%84%E6%97%B6%E5%80%99-%E6%88%91%E4%BB%AC%E8%B0%88%E4%BA%9B%E4%BB%80%E4%B9%88/"/>
      <url>/2020/01/17/%E5%BD%93%E6%88%91%E4%BB%AC%E8%B0%88%E8%B7%A8%E5%9F%9F%E7%9A%84%E6%97%B6%E5%80%99-%E6%88%91%E4%BB%AC%E8%B0%88%E4%BA%9B%E4%BB%80%E4%B9%88/</url>
      
        <content type="html"><![CDATA[<p>关于域名和请求</p><p>客户端在加载资源时，会从服务端请求资源。而具体请求的是哪个资源，则是由<code>域名</code> 指示的。</p><p><img src="https://bebopfzj.oss-cn-hangzhou.aliyuncs.com/uPic/2020-03-09-nYVRk1.jpg" alt="域名" /></p><p>一个域名主要是由三部分组成的，即——协议，域名，端口号（这三者合起来被称为域）。这三者将指示出一个唯一的服务器主机。换句话说，如果协议，域名，端口号一致，那么我们称其为<code>同域</code></p><h3 id="关于跨域请求"><a class="markdownIt-Anchor" href="#关于跨域请求"></a> 关于跨域请求</h3><p>其定义是：当前发起请求的域与该请求指向的资源所在的域不一样。<br />浏览器基于安全问题，会限制这种请求。具体一点来说，请求会被发送至服务器，而服务器也会做出回应，但浏览器会拦截这次回应。</p><h3 id="关于跨域请求的安全问题"><a class="markdownIt-Anchor" href="#关于跨域请求的安全问题"></a> 关于跨域请求的安全问题</h3><h4 id="csrf-攻击"><a class="markdownIt-Anchor" href="#csrf-攻击"></a> CSRF 攻击</h4><p>CSRF（Cross-site request forgery），即跨站请求伪造。<br />如果没有跨域限制，当你登录了 A 网站，本地将会存储一个 A 网站相关的 Cookie，而浏览器也会维护这个 Session 会话。如果你在没有登出的时候，就访问了 B 网站，B 网站则可以通过这个 Cookie 来访问 A 网站的资源，从而造成信息泄露或是财产损失。、<br />简单来说，服务器仅识别身份验证信息，在上面的例子里，就是 Cookie。如果不将网站和服务器限制为同源的，那么任意网站都将可以使用这个身份验证信息来获取服务器的资源。从服务器的角度看过去，若没有做特殊限制，所有具有正确的身份验证信息的请求都是合法的。<br />你可以通过[这篇文章]详细了解 CSRF 攻击。</p><a id="more"></a><h3 id="同源策略"><a class="markdownIt-Anchor" href="#同源策略"></a> 同源策略</h3><ul><li>DOM 层面：来自不同源的 Document 对象或 JS 脚本将不能读取或是设置当前 Document 对象的某些属性</li><li>Cookie 与 XMLHttprequest 层面：拦截 Ajax 发起跨域 HTTP 请求的回复，同时 Ajax 请求不可懈怠与本网站不同源的 Cookie</li><li>同源策略的非绝对性：<code>&lt;script&gt;</code> <code>&lt;img&gt;</code> <code>&lt;iframe&gt;</code> <code>&lt;link&gt;</code> <code>&lt;video&gt;</code> <code>&lt;audio&gt;</code> 等带有<code>src</code> 属性的标签可以从不同的域加载和执行资源</li><li>其他插件的同源策略：flash、java applet、silverlight、googlegears 等浏览器加载的第三方插件会有各自的同源策略，但它们不同于浏览器原生的同源策略</li></ul><h3 id="跨域解决方法"><a class="markdownIt-Anchor" href="#跨域解决方法"></a> 跨域解决方法</h3><h4 id="配置-proxytable"><a class="markdownIt-Anchor" href="#配置-proxytable"></a> 配置 proxyTable</h4><ul><li>背景：在本地开发时，Vue 页面是类似于：<code>http://localhost:8080</code> 这样的访问页面，而接口如果部署在了服务器上，则会变成 <code>http://xxx.com/.../...</code> 这种的，直接使用则会存在跨域的请求。</li></ul><p>进入 <code>config/index.js</code> 文件，按如下配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">dev: &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 静态资源文件夹</span><br><span class="line">assetsSubDirectory: &#39;static&#39;,</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 发布路径</span><br><span class="line">assetsPublicPath: &#39;&#x2F;&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 代理配置表</span><br><span class="line">proxyTable: &#123;</span><br><span class="line">&#39;&#x2F;api&#39;: &#123;</span><br><span class="line">target: &#39;http:&#x2F;&#x2F;xxxxx.com&#39;,&#x2F;&#x2F; 接口的域名</span><br><span class="line">&#x2F;&#x2F; secure: false, &#x2F;&#x2F; https则删除注释</span><br><span class="line">changeOrigin: true,&#x2F;&#x2F; 切换源</span><br><span class="line">pathRewrite: &#123;</span><br><span class="line">&#39;^&#x2F;api&#39;: &#39;&#39;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="原理"><a class="markdownIt-Anchor" href="#原理"></a> 原理</h5><p><code>vue-cli</code> 使用 <code>http-proxy-middleware</code> 中间件来转发请求。更进一步的说，是当运行 Vue 项目的时候，会配置启动一个 node 服务，这个服务有两个作用：一，静态文件服务，以便于访问到本地的静态文件，同时监听文件变动。二，启动一个 http 代理，所有请求会被发送至这个代理 A，然后由代理 A 转发至你的目标服务器 B。而跨域是浏览器禁止的，服务器端不会禁止。</p><p>在浏览器端如果允许跨域，则会导致 B 网站获取到 A 网站的敏感信息。而服务器只能有自己网站的状态信息，所以没必要禁止跨域。</p>]]></content>
      
      
      <categories>
          
          <category> 核心概念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 同源策略 </tag>
            
            <tag> proxyTable </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
